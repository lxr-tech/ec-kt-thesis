[
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Example 2: Input: n = 1 Output: [[1]] Constraints: 1 <= n <= 20",
        "title": "Spiral Matrix II",
        "questionId": 52
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the longest palindromic substring in s. Example 1: Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: Input: s = \"cbbd\" Output: \"bb\" Constraints: 1 <= s.length <= 1000 s consist of only digits and English letters.",
        "title": "Longest Palindromic Substring",
        "questionId": 4
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2: Input: numRows = 1 Output: [[1]] Constraints: 1 <= numRows <= 30",
        "title": "Pascal's Triangle",
        "questionId": 102
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. Example 1: Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Example 2: Input: arr = [1,1] Output: 1 Constraints: 1 <= arr.length <= 104 0 <= arr[i] <= 105",
        "title": "Element Appearing More Than 25% In Sorted Array",
        "questionId": 791
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False. Follow up: Do not use any built-in library function such as sqrt. Example 1: Input: num = 16 Output: true Example 2: Input: num = 14 Output: false Constraints: 1 <= num <= 2^31 - 1",
        "title": "Valid Perfect Square",
        "questionId": 252
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return any array containing n unique integers such that they add up to 0. Example 1: Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: Input: n = 3 Output: [-1,0,1] Example 3: Input: n = 1 Output: [0] Constraints: 1 <= n <= 1000",
        "title": "Find N Unique Integers Sum up to Zero",
        "questionId": 914
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109",
        "title": "Contains Duplicate",
        "questionId": 169
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Constraints: 1 <= s.length <= 105 s[i] is a printable ascii character.",
        "title": "Reverse String",
        "questionId": 242
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false. Example 1: Input: arr = [2,6,4,1] Output: false Explanation: There are no three consecutive odds. Example 2: Input: arr = [1,2,34,3,4,5,7,23,12] Output: true Explanation: [5,7,23] are three consecutive odds. Constraints: 1 <= arr.length <= 1000 1 <= arr[i] <= 1000",
        "title": "Three Consecutive Odds",
        "questionId": 838
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n. Example 1: Input: n = 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99 Example 2: Input: n = 0 Output: 1 Constraints: 0 <= n <= 8",
        "title": "Count Numbers with Unique Digits",
        "questionId": 249
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order. Example 1: Input: mat = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,4,7,5,3,6,8,9] Example 2: Input: mat = [[1,2],[3,4]] Output: [1,2,3,4] Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 104 1 <= m * n <= 104 -105 <= mat[i][j] <= 105",
        "title": "Diagonal Traverse",
        "questionId": 352
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a binary tree, return the sum of all left leaves. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 24 Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2: Input: root = [1] Output: 0 Constraints: The number of nodes in the tree is in the range [1, 1000]. -1000 <= Node.val <= 1000",
        "title": "Sum of Left Leaves",
        "questionId": 284
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. Example 1: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Example 2: Input: n = 1, k = 1 Output: [[1]] Constraints: 1 <= n <= 20 1 <= k <= n",
        "title": "Combinations",
        "questionId": 69
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums, return the number of reverse pairs in the array. A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j]. Example 1: Input: nums = [1,3,2,3,1] Output: 2 Example 2: Input: nums = [2,4,3,5,1] Output: 3 Constraints: 1 <= nums.length <= 5 * 104 -231 <= nums[i] <= 231 - 1",
        "title": "Reverse Pairs",
        "questionId": 348
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 104]. -100 <= Node.val <= 100",
        "title": "Maximum Depth of Binary Tree",
        "questionId": 90
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2: Input: x = 2.10000, n = 3 Output: 9.26100 Example 3: Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints: -100.0 < x < 100.0 -231 <= n <= 231-1 -104 <= xn <= 104",
        "title": "Pow(x, n)",
        "questionId": 44
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Constraints: 1 <= nums.length <= 200 1 <= nums[i] <= 100",
        "title": "Partition Equal Subset Sum",
        "questionId": 294
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2. Given an integer n, return the number of square triples such that 1 <= a, b, c <= n. Example 1: Input: n = 5 Output: 2 Explanation: The square triples are (3,4,5) and (4,3,5). Example 2: Input: n = 10 Output: 4 Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10). Constraints: 1 <= n <= 250",
        "title": "Count Square Sum Triples",
        "questionId": 1339
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].\r \r Return the array in the form [x1,y1,x2,y2,...,xn,yn].\r \r \r Example 1:\r \r \r Input: nums = [2,5,1,3,4,7], n = 3\r Output: [2,3,5,4,1,7] \r Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].\r \r \r Example 2:\r \r \r Input: nums = [1,2,3,4,4,3,2,1], n = 4\r Output: [1,4,2,3,3,2,4,1]\r \r \r Example 3:\r \r \r Input: nums = [1,1,2,2], n = 2\r Output: [1,2,1,2]\r \r \r \r Constraints:\r \r \r 1 <= n <= 500\r nums.length == 2n\r 1 <= nums[i] <= 10^3",
        "title": "Shuffle the Array",
        "questionId": 1038
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]\u2026nums[i]).\r \r Return the running sum of nums.\r \r \r Example 1:\r \r \r Input: nums = [1,2,3,4]\r Output: [1,3,6,10]\r Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\r \r Example 2:\r \r \r Input: nums = [1,1,1,1,1]\r Output: [1,2,3,4,5]\r Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\r \r Example 3:\r \r \r Input: nums = [3,1,2,10,1]\r Output: [3,4,6,16,17]\r \r \r \r Constraints:\r \r \r 1 <= nums.length <= 1000\r -10^6 <= nums[i] <= 10^6",
        "title": "Running Sum of 1d Array",
        "questionId": 1046
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters. Example 1: Input: s = \"Hello, my name is John\" Output: 5 Explanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"] Example 2: Input: s = \"Hello\" Output: 1 Constraints: 0 <= s.length <= 300 s consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\". The only space character in s is ' '.",
        "title": "Number of Segments in a String",
        "questionId": 303
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] Constraints: 1 <= temperatures.length <= 105 30 <= temperatures[i] <= 100",
        "title": "Daily Temperatures",
        "questionId": 492
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Input: nums = [2,2,3,2] Output: 3 Example 2: Input: nums = [0,1,0,1,0,1,99] Output: 99 Constraints: 1 <= nums.length <= 3 * 104 -231 <= nums[i] <= 231 - 1 Each element in nums appears exactly three times except for one element which appears once.",
        "title": "Single Number II",
        "questionId": 121
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. Example 1: Input: word1 = \"sea\", word2 = \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Example 2: Input: word1 = \"leetcode\", word2 = \"etco\" Output: 4 Constraints: 1 <= word1.length, word2.length <= 500 word1 and word2 consist of only lowercase English letters.",
        "title": "Delete Operation for Two Strings",
        "questionId": 404
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Input: nums = [2,2,1] Output: 1 Example 2: Input: nums = [4,1,2,1,2] Output: 4 Example 3: Input: nums = [1] Output: 1 Constraints: 1 <= nums.length <= 3 * 104 -3 * 104 <= nums[i] <= 3 * 104 Each element in the array appears twice except for one element which appears only once.",
        "title": "Single Number",
        "questionId": 120
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer. Example 1: Input: nums = [1,5,1,1,6,4] Output: [1,6,1,5,1,4] Explanation: [1,4,1,5,1,6] is also accepted. Example 2: Input: nums = [1,3,2,2,3,1] Output: [2,3,1,3,1,2] Constraints: 1 <= nums.length <= 5 * 104 0 <= nums[i] <= 5000 It is guaranteed that there will be an answer for the given input nums. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?",
        "title": "Wiggle Sort II",
        "questionId": 227
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2.00000 Explanation: The five points are shown in the above figure. The red triangle is the largest. Example 2: Input: points = [[1,0],[0,0],[0,1]] Output: 0.50000 Constraints: 3 <= points.length <= 50 -50 <= xi, yi <= 50 All the given points are unique.",
        "title": "Largest Triangle Area",
        "questionId": 561
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum. Example 2: Input: grid = [[1,2,3],[4,5,6]] Output: 12 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100",
        "title": "Minimum Path Sum",
        "questionId": 56
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining. Example 1: Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output: 4 Explanation: After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4. Example 2: Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] Output: 10 Constraints: m == heightMap.length n == heightMap[i].length 1 <= m, n <= 200 0 <= heightMap[i][j] <= 2 * 104",
        "title": "Trapping Rain Water II",
        "questionId": 287
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's. Example 1: Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2: Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3 Output: 10 Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Constraints: 1 <= nums.length <= 105 nums[i] is either 0 or 1. 0 <= k <= nums.length",
        "title": "Max Consecutive Ones III",
        "questionId": 732
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 Example 2: Input: n = 1 Output: true Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Example 3: Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7. Constraints: -231 <= n <= 231 - 1",
        "title": "Ugly Number",
        "questionId": 194
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist. An alphanumeric string is a string consisting of lowercase English letters and digits. Example 1: Input: s = \"dfa12321afd\" Output: 2 Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2. Example 2: Input: s = \"abc1111\" Output: -1 Explanation: The digits that appear in s are [1]. There is no second largest digit. Constraints: 1 <= s.length <= 500 s consists of only lowercase English letters and/or digits.",
        "title": "Second Largest Digit in a String",
        "questionId": 1248
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target. Example 1: Input: nums = [1,1,1,1,1], target = 2 Output: 2 Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2). Example 2: Input: nums = [-1,3,5,1,4,2,-9], target = 6 Output: 2 Explanation: There are 3 subarrays with sum equal to 6. ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping. Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 0 <= target <= 106",
        "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "questionId": 1079
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array of unique positive integers nums. Consider the following graph: There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. Example 1: Input: nums = [4,6,15,35] Output: 4 Example 2: Input: nums = [20,50,9,63] Output: 2 Example 3: Input: nums = [2,3,6,7,4,12,21,39] Output: 8 Constraints: 1 <= nums.length <= 2 * 104 1 <= nums[i] <= 105 All the values of nums are unique.",
        "title": "Largest Component Size by Common Factor",
        "questionId": 684
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Example 1: Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000 Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75 Example 2: Input: nums = [5], k = 1 Output: 5.00000 Constraints: n == nums.length 1 <= k <= n <= 105 -104 <= nums[i] <= 104",
        "title": "Maximum Average Subarray I",
        "questionId": 430
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array nums of integers, return how many of them contain an even number of digits. Example 1: Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits. Example 2: Input: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. Constraints: 1 <= nums.length <= 500 1 <= nums[i] <= 105",
        "title": "Find Numbers with Even Number of Digits",
        "questionId": 910
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'. Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters. 1 <= k <= s.length",
        "title": "Maximum Number of Vowels in a Substring of Given Length",
        "questionId": 1027
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right]. The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3]. Example 2: Input: nums = [2,9,2,5,6], left = 2, right = 8 Output: 7 Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109 0 <= left <= right <= 109",
        "title": "Number of Subarrays with Bounded Maximum",
        "questionId": 543
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "content": "Given an array nums of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three. Example 1: Input: nums = [3,6,5,1,8] Output: 18 Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3). Example 2: Input: nums = [4] Output: 0 Explanation: Since 4 is not divisible by 3, do not pick any number. Example 3: Input: nums = [1,2,3,4,4] Output: 12 Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3). Constraints: 1 <= nums.length <= 4 * 10^4 1 <= nums[i] <= 10^4",
        "title": "Greatest Sum Divisible by Three",
        "questionId": 893
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] Constraints: 2 <= nums.length <= 104 1 <= nums[i] <= 104",
        "title": "Set Mismatch",
        "questionId": 431
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, return true if s is a good string, or false otherwise. A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency). Example 1: Input: s = \"abacbc\" Output: true Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s. Example 2: Input: s = \"aaabb\" Output: false Explanation: The characters that appear in s are 'a' and 'b'. 'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times. Constraints: 1 <= s.length <= 1000 s consists of lowercase English letters.",
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "questionId": 1351
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. Example 1: Input: nums = [10,5,2,6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6] Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Example 2: Input: nums = [1,2,3], k = 0 Output: 0 Constraints: 1 <= nums.length <= 3 * 104 1 <= nums[i] <= 1000 0 <= k <= 106",
        "title": "Subarray Product Less Than K",
        "questionId": 477
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Constraints: 1 <= pushed.length <= 1000 0 <= pushed[i] <= 1000 All the elements of pushed are unique. popped.length == pushed.length popped is a permutation of pushed.",
        "title": "Validate Stack Sequences",
        "questionId": 678
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf(). Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Example 3: Input: haystack = \"\", needle = \"\" Output: 0 Constraints: 0 <= haystack.length, needle.length <= 5 * 104 haystack and needle consist of only lower-case English characters.",
        "title": "Implement strStr()",
        "questionId": 22
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j). After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes. Return the total surface area of the resulting shapes. Note: The bottom face of each shape counts toward its surface area. Example 1: Input: grid = [[1,2],[3,4]] Output: 34 Example 2: Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 3: Input: grid = [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Constraints: n == grid.length == grid[i].length 1 <= n <= 50 0 <= grid[i][j] <= 50",
        "title": "Surface Area of 3D Shapes",
        "questionId": 637
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold. Example 1: Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4 Output: 3 Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold). Example 2: Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5 Output: 6 Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers. Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 104 1 <= k <= arr.length 0 <= threshold <= 104",
        "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
        "questionId": 926
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1: Input: s = \"ab#c\", t = \"ad#c\" Output: true Explanation: Both s and t become \"ac\". Example 2: Input: s = \"ab##\", t = \"c#d#\" Output: true Explanation: Both s and t become \"\". Example 3: Input: s = \"a#c\", t = \"b\" Output: false Explanation: s becomes \"c\" while t becomes \"b\". Constraints: 1 <= s.length, t.length <= 200 s and t only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(n) time and O(1) space?",
        "title": "Backspace String Compare",
        "questionId": 591
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive). Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false. Example 1: Input: matrix = [[1,2,3],[3,1,2],[2,3,1]] Output: true Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. Example 2: Input: matrix = [[1,1,1],[1,2,3],[1,2,3]] Output: false Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. Constraints: n == matrix.length == matrix[i].length 1 <= n <= 100 1 <= matrix[i][j] <= n",
        "title": "Check if Every Row and Column Contains All Numbers",
        "questionId": 1493
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either: Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ... Return the minimum number of moves to transform the given array nums into a zigzag array. Example 1: Input: nums = [1,2,3] Output: 2 Explanation: We can decrease 2 to 0 or 3 to 1. Example 2: Input: nums = [9,6,1,6,2] Output: 4 Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 1000",
        "title": "Decrease Elements To Make Array Zigzag",
        "questionId": 806
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times. Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] Constraints: m == grid.length n == grid[i].length 1 <= m <= 50 1 <= n <= 50 -1000 <= grid[i][j] <= 1000 0 <= k <= 100",
        "title": "Shift 2D Grid",
        "questionId": 891
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0,1,1] results in [1,0,0]. Example 1: Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Constraints: n == image.length n == image[i].length 1 <= n <= 20 images[i][j] is either 0 or 1.",
        "title": "Flipping an Image",
        "questionId": 581
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi). Return true if all the rectangles together form an exact cover of a rectangular region. Example 1: Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]] Output: true Explanation: All 5 rectangles together form an exact cover of a rectangular region. Example 2: Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]] Output: false Explanation: Because there is a gap between the two rectangular regions. Example 3: Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]] Output: false Explanation: Because two of the rectangles overlap with each other. Constraints: 1 <= rectangles.length <= 2 * 104 rectangles[i].length == 4 -105 <= xi, yi, ai, bi <= 105",
        "title": "Perfect Rectangle",
        "questionId": 272
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Example 1: Input: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Example 3: Input: coins = [1], amount = 0 Output: 0 Constraints: 1 <= coins.length <= 12 1 <= coins[i] <= 231 - 1 0 <= amount <= 104",
        "title": "Coin Change",
        "questionId": 226
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return the smallest prime palindrome greater than or equal to n. An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11, and 13 are all primes. An integer is a palindrome if it reads the same from left to right as it does from right to left. For example, 101 and 12321 are palindromes. The test cases are generated so that the answer always exists and is in the range [2, 2 * 108]. Example 1: Input: n = 6 Output: 7 Example 2: Input: n = 8 Output: 11 Example 3: Input: n = 13 Output: 101 Constraints: 1 <= n <= 108",
        "title": "Prime Palindrome",
        "questionId": 612
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions. Given the grid grid represented as a string array, return the number of regions. Note that backslash characters are escaped, so a '\\' is represented as '\\\\'. Example 1: Input: grid = [\" /\",\"/ \"] Output: 2 Example 2: Input: grid = [\" /\",\" \"] Output: 1 Example 3: Input: grid = [\"/\\\\\",\"\\\\/\"] Output: 5 Explanation: Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\. Constraints: n == grid.length == grid[i].length 1 <= n <= 30 grid[i][j] is either '/', '\\', or ' '.",
        "title": "Regions Cut By Slashes",
        "questionId": 690
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Example 1: Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"] Output: \"world\" Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\". Example 2: Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"] Output: \"apple\" Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\". Constraints: 1 <= words.length <= 1000 1 <= words[i].length <= 30 words[i] consists of lowercase English letters.",
        "title": "Longest Word in Dictionary",
        "questionId": 482
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values. Return the minimum number of moves required so that nums has k consecutive 1's. Example 1: Input: nums = [1,0,0,1,0,1], k = 2 Output: 1 Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's. Example 2: Input: nums = [1,0,0,0,0,0,1,1], k = 3 Output: 5 Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1]. Example 3: Input: nums = [1,1,0,1], k = 2 Output: 0 Explanation: nums already has 2 consecutive 1's. Constraints: 1 <= nums.length <= 105 nums[i] is 0 or 1. 1 <= k <= sum(nums)",
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "questionId": 1187
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of: Choosing any x with 0 < x < n and n % x == 0. Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally. Example 1: Input: n = 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves. Example 2: Input: n = 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves. Constraints: 1 <= n <= 1000",
        "title": "Divisor Game",
        "questionId": 747
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string text. You can swap two of the characters in the text. Return the length of the longest substring with repeated characters. Example 1: Input: text = \"ababa\" Output: 3 Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\" with length 3. Example 2: Input: text = \"aaabaaa\" Output: 6 Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\" with length 6. Example 3: Input: text = \"aaaaa\" Output: 5 Explanation: No need to swap, longest repeated character substring is \"aaaaa\" with length is 5. Constraints: 1 <= text.length <= 2 * 104 text consist of lowercase English characters only.",
        "title": "Swap For Longest Repeated Character Substring",
        "questionId": 815
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a subarray of size 1 is ascending. Example 1: Input: nums = [10,20,30,5,10,50] Output: 65 Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. Example 2: Input: nums = [10,20,30,40,50] Output: 150 Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150. Example 3: Input: nums = [12,17,15,13,10,11,12] Output: 33 Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33. Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100",
        "title": "Maximum Ascending Subarray Sum",
        "questionId": 1263
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of integers nums (0-indexed) and an integer k. The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j. Return the maximum possible score of a good subarray. Example 1: Input: nums = [1,4,3,7,4,5], k = 3 Output: 15 Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. Example 2: Input: nums = [5,5,4,5,4,1,1,1], k = 0 Output: 20 Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 2 * 104 0 <= k < nums.length",
        "title": "Maximum Score of a Good Subarray",
        "questionId": 1258
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false. Example 1: Input: s = \"aaabbb\" Output: true Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true. Example 2: Input: s = \"abab\" Output: false Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not every 'a' appears before every 'b' and we return false. Example 3: Input: s = \"bbb\" Output: true Explanation: There are no 'a's, hence, every 'a' appears before every 'b' and we return true. Constraints: 1 <= s.length <= 100 s[i] is either 'a' or 'b'.",
        "title": "Check if All A's Appears Before All B's",
        "questionId": 1489
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"] Output: [\"cats and dog\",\"cat sand dog\"] Example 2: Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"] Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: [] Constraints: 1 <= s.length <= 20 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique.",
        "title": "Word Break II",
        "questionId": 124
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0. Example 1: Input: time = [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: time = [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60. Constraints: 1 <= time.length <= 6 * 104 1 <= time[i] <= 500",
        "title": "Pairs of Songs With Total Durations Divisible by 60",
        "questionId": 736
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1]. Example 1: Input: nums = [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3. Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element 4. Example 2: Input: nums = [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly increasing. Constraints: 1 <= nums.length <= 104 -109 <= nums[i] <= 109",
        "title": "Longest Continuous Increasing Subsequence",
        "questionId": 454
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "content": "Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive. A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Return the maximum length of a subarray with positive product. Example 1: Input: nums = [1,-2,-3,4] Output: 4 Explanation: The array nums already has a positive product of 24. Example 2: Input: nums = [0,1,-2,-3,-4] Output: 3 Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6. Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive. Example 3: Input: nums = [-1,-2,-3,0,1] Output: 2 Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3]. Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109",
        "title": "Maximum Length of Subarray With Positive Product",
        "questionId": 1106
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\r \r In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\r \r If there is no way to make arr1 strictly increasing, return -1.\r \r \r Example 1:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\r Output: 1\r Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\r \r \r Example 2:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\r Output: 2\r Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\r \r \r Example 3:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\r Output: -1\r Explanation: You can't make arr1 strictly increasing.\r \r \r Constraints:\r \r \r 1 <= arr1.length, arr2.length <= 2000\r 0 <= arr1[i], arr2[i] <= 10^9",
        "title": "Make Array Strictly Increasing",
        "questionId": 837
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers arr of even length n and an integer k. We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k. Return true If you can find a way to do that or false otherwise. Example 1: Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5 Output: true Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10). Example 2: Input: arr = [1,2,3,4,5,6], k = 7 Output: true Explanation: Pairs are (1,6),(2,5) and(3,4). Example 3: Input: arr = [1,2,3,4,5,6], k = 10 Output: false Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10. Constraints: arr.length == n 1 <= n <= 105 n is even. -109 <= arr[i] <= 109 1 <= k <= 105",
        "title": "Check If Array Pairs Are Divisible by k",
        "questionId": 1057
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path. Example 1: Input: grid = [[0,1],[1,0]] Output: 2 Example 2: Input: grid = [[0,0,0],[1,1,0],[1,1,0]] Output: 4 Example 3: Input: grid = [[1,0,0],[1,1,0],[1,1,0]] Output: -1 Constraints: n == grid.length n == grid[i].length 1 <= n <= 100 grid[i][j] is 0 or 1",
        "title": "Shortest Path in Binary Matrix",
        "questionId": 778
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0. Given strings sequence and word, return the maximum k-repeating value of word in sequence. Example 1: Input: sequence = \"ababc\", word = \"ab\" Output: 2 Explanation: \"abab\" is a substring in \"ababc\". Example 2: Input: sequence = \"ababc\", word = \"ba\" Output: 1 Explanation: \"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\". Example 3: Input: sequence = \"ababc\", word = \"ac\" Output: 0 Explanation: \"ac\" is not a substring in \"ababc\". Constraints: 1 <= sequence.length <= 100 1 <= word.length <= 100 sequence and word contains only lowercase English letters.",
        "title": "Maximum Repeating Substring",
        "questionId": 1157
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person. The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die. Return the earliest year with the maximum population. Example 1: Input: logs = [[1993,1999],[2000,2010]] Output: 1993 Explanation: The maximum population is 1, and 1993 is the earliest year with this population. Example 2: Input: logs = [[1950,1961],[1960,1971],[1970,1981]] Output: 1960 Explanation: The maximum population is 2, and it had happened in years 1960 and 1970. The earlier year between them is 1960. Constraints: 1 <= logs.length <= 100 1950 <= birthi < deathi <= 2050",
        "title": "Maximum Population Year",
        "questionId": 1299
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 <= s.length <= 105 s[i] is either'(' , ')', or lowercase English letter.",
        "title": "Minimum Remove to Make Valid Parentheses",
        "questionId": 885
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi. Count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4. Example 2: Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] Output: 4 Example 3: Input: m = 3, n = 3, ops = [] Output: 9 Constraints: 1 <= m, n <= 4 * 104 0 <= ops.length <= 104 ops[i].length == 2 1 <= ai <= m 1 <= bi <= n",
        "title": "Range Addition II",
        "questionId": 410
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of positive integers arr, calculate the sum of all possible odd-length subarrays. A subarray is a contiguous subsequence of the array. Return the sum of all odd-length subarrays of arr. Example 1: Input: arr = [1,4,2,5,3] Output: 58 Explanation: The odd-length subarrays of arr and their sums are: [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 Example 2: Input: arr = [1,2] Output: 3 Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3. Example 3: Input: arr = [10,11,12] Output: 66 Constraints: 1 <= arr.length <= 100 1 <= arr[i] <= 1000",
        "title": "Sum of All Odd Length Subarrays",
        "questionId": 1109
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Example 1: Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example Example 2: Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5 Output: false Example 3: Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3 Output: true Constraints: 1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106",
        "title": "Water and Jug Problem",
        "questionId": 251
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"3+2*2\" Output: 7 Example 2: Input: s = \" 3/2 \" Output: 1 Example 3: Input: s = \" 3+5 / 2 \" Output: 5 Constraints: 1 <= s.length <= 3 * 105 s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces. s represents a valid expression. All the integers in the expression are non-negative integers in the range [0, 231 - 1]. The answer is guaranteed to fit in a 32-bit integer.",
        "title": "Basic Calculator II",
        "questionId": 178
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a hidden integer array arr that consists of n non-negative integers. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3]. You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0]. Return the original array arr. It can be proved that the answer exists and is unique. Example 1: Input: encoded = [1,2,3], first = 1 Output: [1,0,2,1] Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] Example 2: Input: encoded = [6,2,7,3], first = 4 Output: [4,2,0,7,4] Constraints: 2 <= n <= 104 encoded.length == n - 1 0 <= encoded[i] <= 105 0 <= first <= 105",
        "title": "Decode XORed Array",
        "questionId": 1210
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3]. Example 1: Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Example 2: Input: firstList = [[1,3],[5,9]], secondList = [] Output: [] Constraints: 0 <= firstList.length, secondList.length <= 1000 firstList.length + secondList.length >= 1 0 <= starti < endi <= 109 endi < starti+1 0 <= startj < endj <= 109 endj < startj+1",
        "title": "Interval List Intersections",
        "questionId": 715
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A complex number can be represented as a string on the form \"real+imaginaryi\" where: real is the real part and is an integer in the range [-100, 100]. imaginary is the imaginary part and is an integer in the range [-100, 100]. i2 == -1. Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications. Example 1: Input: num1 = \"1+1i\", num2 = \"1+1i\" Output: \"0+2i\" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2: Input: num1 = \"1+-1i\", num2 = \"1+-1i\" Output: \"0+-2i\" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. Constraints: num1 and num2 are valid complex numbers.",
        "title": "Complex Number Multiplication",
        "questionId": 378
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: 0 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 105 intervals is sorted by starti in ascending order. newInterval.length == 2 0 <= start <= end <= 105",
        "title": "Insert Interval",
        "questionId": 50
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that: 0 <= i, j, k, l < n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Example 1: Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 Example 2: Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] Output: 1 Constraints: n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 <= n <= 200 -228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228",
        "title": "4Sum II",
        "questionId": 319
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and space is marked as 1 and 0 respectively in the grid. Example 1: Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right Example 2: Input: obstacleGrid = [[0,1],[0,0]] Output: 1 Constraints: m == obstacleGrid.length n == obstacleGrid[i].length 1 <= m, n <= 100 obstacleGrid[i][j] is 0 or 1.",
        "title": "Unique Paths II",
        "questionId": 55
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a strange printer with the following two special requirements: On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle. Once the printer has used a color for the above operation, the same color cannot be used again. You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid. Return true if it is possible to print the matrix targetGrid, otherwise, return false. Example 1: Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]] Output: true Example 2: Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]] Output: true Example 3: Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]] Output: false Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns. Constraints: m == targetGrid.length n == targetGrid[i].length 1 <= m, n <= 60 1 <= targetGrid[row][col] <= 60",
        "title": "Strange Printer II",
        "questionId": 1112
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character. Return the minimum number of steps to make t an anagram of s. An Anagram of a string is a string that contains the same characters with a different (or the same) ordering. Example 1: Input: s = \"bab\", t = \"aba\" Output: 1 Explanation: Replace the first 'a' in t with b, t = \"bba\" which is anagram of s. Example 2: Input: s = \"leetcode\", t = \"practice\" Output: 5 Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s. Example 3: Input: s = \"anagram\", t = \"mangaar\" Output: 0 Explanation: \"anagram\" and \"mangaar\" are anagrams. Constraints: 1 <= s.length <= 5 * 104 s.length == t.length s and t consist of lowercase English letters only.",
        "title": "Minimum Number of Steps to Make Two Strings Anagram",
        "questionId": 946
    },
    {
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions: 0 <= i < j < nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7. Example 1: Input: nums = [42,11,1,97] Output: 2 Explanation: The two pairs are: - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121. - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12. Example 2: Input: nums = [13,10,35,24,76] Output: 4 Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109",
        "title": "Count Nice Pairs in an Array",
        "questionId": 1262
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become: [4,5,6,7,0,1,4] if it was rotated 4 times. [0,1,4,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array. You must decrease the overall operation steps as much as possible. Example 1: Input: nums = [1,3,5] Output: 1 Example 2: Input: nums = [2,2,2,0,1] Output: 0 Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 nums is sorted and rotated between 1 and n times. Follow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "title": "Find Minimum in Rotated Sorted Array II",
        "questionId": 137
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. Example 1: Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on. Example 2: Input: n = 0 Output: 0 Example 3: Input: n = 1 Output: 1 Constraints: 0 <= n <= 109",
        "title": "Bulb Switcher",
        "questionId": 224
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k. You are allowed to choose exactly one element from each row to form an array. Return the kth smallest array sum among all possible arrays. Example 1: Input: mat = [[1,3,11],[2,4,6]], k = 5 Output: 7 Explanation: Choosing one element from each row, the first k smallest sum are: [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7. Example 2: Input: mat = [[1,3,11],[2,4,6]], k = 9 Output: 17 Example 3: Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 Output: 9 Explanation: Choosing one element from each row, the first k smallest sum are: [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9. Constraints: m == mat.length n == mat.length[i] 1 <= m, n <= 40 1 <= mat[i][j] <= 5000 1 <= k <= min(200, nm) mat[i] is a non-decreasing array.",
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "questionId": 1013
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: Input: root = [2,2,5,null,null,5,7] Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. Example 2: Input: root = [2,2,2] Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value. Constraints: The number of nodes in the tree is in the range [1, 25]. 1 <= Node.val <= 231 - 1 root.val == min(root.left.val, root.right.val) for each internal node of the tree.",
        "title": "Second Minimum Node In a Binary Tree",
        "questionId": 451
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "An ugly number is a positive integer that is divisible by a, b, or c. Given four integers n, a, b, and c, return the nth ugly number. Example 1: Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. Example 2: Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6. Example 3: Input: n = 5, a = 2, b = 11, c = 13 Output: 10 Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10. Constraints: 1 <= n, a, b, c <= 109 1 <= a * b * c <= 1018 It is guaranteed that the result will be in range [1, 2 * 109].",
        "title": "Ugly Number III",
        "questionId": 851
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile. Also, if a player cannot make a move, he/she loses the game. Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally. Example 1: Input: n = 1 Output: true Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves. Example 2: Input: n = 2 Output: false Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0). Example 3: Input: n = 4 Output: true Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0). Constraints: 1 <= n <= 105",
        "title": "Stone Game IV",
        "questionId": 1055
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti]. For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where answer[i] is the answer to the ith query. Example 1: Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2: Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] Output: [8,0,4,4] Constraints: 1 <= arr.length, queries.length <= 3 * 104 1 <= arr[i] <= 109 queries[i].length == 2 0 <= lefti <= righti < arr.length",
        "title": "XOR Queries of a Subarray",
        "questionId": 919
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). The test cases are generated so that there will be an answer. Example 1: Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). Example 2: Input: nums = [44,22,33,11,1], threshold = 5 Output: 44 Constraints: 1 <= nums.length <= 5 * 104 1 <= nums[i] <= 106 nums.length <= threshold <= 106",
        "title": "Find the Smallest Divisor Given a Threshold",
        "questionId": 905
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. Example 1: Input: n = 2, trust = [[1,2]] Output: 2 Example 2: Input: n = 3, trust = [[1,3],[2,3]] Output: 3 Example 3: Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 Constraints: 1 <= n <= 1000 0 <= trust.length <= 104 trust[i].length == 2 All the pairs of trust are unique. ai != bi 1 <= ai, bi <= n",
        "title": "Find the Town Judge",
        "questionId": 726
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u') Each vowel 'a' may only be followed by an 'e'. Each vowel 'e' may only be followed by an 'a' or an 'i'. Each vowel 'i' may not be followed by another 'i'. Each vowel 'o' may only be followed by an 'i' or a 'u'. Each vowel 'u' may only be followed by an 'a'. Since the answer may be too large, return it modulo 10^9 + 7. Example 1: Input: n = 1 Output: 5 Explanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\". Example 2: Input: n = 2 Output: 10 Explanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\". Example 3: Input: n = 5 Output: 68 Constraints: 1 <= n <= 2 * 10^4",
        "title": "Count Vowels Permutation",
        "questionId": 866
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible. Note that the subarray needs to be non-empty after deleting one element. Example 1: Input: arr = [1,-2,0,3] Output: 4 Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value. Example 2: Input: arr = [1,-2,-2,3] Output: 3 Explanation: We just choose [3] and it's the maximum sum. Example 3: Input: arr = [-1,-1,-1,-1] Output: -1 Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0. Constraints: 1 <= arr.length <= 105 -104 <= arr[i] <= 104",
        "title": "Maximum Subarray Sum with One Deletion",
        "questionId": 835
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ],
        "content": "There are n couples sitting in 2n seats arranged in a row and want to hold hands. The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1). Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. Example 1: Input: row = [0,2,1,3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input: row = [3,2,0,1] Output: 0 Explanation: All couples are already seated side by side. Constraints: 2n == row.length 2 <= n <= 30 n is even. 0 <= row[i] < 2n All the elements of row are unique.",
        "title": "Couples Holding Hands",
        "questionId": 512
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. Example 1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2: Input: arr = [1,7], k = 1 Output: [1,7] Constraints: 2 <= arr.length <= 1000 1 <= arr[i] <= 3 * 104 arr[0] == 1 arr[i] is a prime number for i > 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 <= k <= arr.length * (arr.length - 1) / 2",
        "title": "K-th Smallest Prime Fraction",
        "questionId": 534
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other. Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1. A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent. Example 1: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown. The first move swaps the first and second column. The second move swaps the second and third row. Example 2: Input: board = [[0,1],[1,0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard. Example 3: Input: board = [[1,0],[1,0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard. Constraints: n == board.length n == board[i].length 2 <= n <= 30 board[i][j] is either 0 or 1.",
        "title": "Transform to Chessboard",
        "questionId": 530
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square. Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid. Example 1: Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]] Output: 3 Explanation: The largest magic square has a size of 3. Every row sum, column sum, and diagonal sum of this magic square is equal to 12. - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12 - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12 - Diagonal sums: 5+4+3 = 6+4+2 = 12 Example 2: Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]] Output: 2 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 1 <= grid[i][j] <= 106",
        "title": "Largest Magic Square",
        "questionId": 855
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given two arrays nums1 and nums2. Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length. A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not). Example 1: Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6] Output: 18 Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2. Their dot product is (2*3 + (-2)*(-6)) = 18. Example 2: Input: nums1 = [3,-2], nums2 = [2,-6,7] Output: 21 Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2. Their dot product is (3*7) = 21. Example 3: Input: nums1 = [-1,-1], nums2 = [1,1] Output: -1 Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2. Their dot product is -1. Constraints: 1 <= nums1.length, nums2.length <= 500 -1000 <= nums1[i], nums2[i] <= 1000",
        "title": "Max Dot Product of Two Subsequences",
        "questionId": 1029
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "We define str = [s, n] as the string str which consists of the string s concatenated n times. For example, str == [\"abc\", 3] ==\"abcabcabc\". We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters. You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2]. Return the maximum integer m such that str = [str2, m] can be obtained from str1. Example 1: Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2 Output: 2 Example 2: Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1 Output: 1 Constraints: 1 <= s1.length, s2.length <= 100 s1 and s2 consist of lowercase English letters. 1 <= n1, n2 <= 106",
        "title": "Count The Repetitions",
        "questionId": 329
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Winston was given the above mysterious function func. He has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible. Return the minimum possible value of |func(arr, l, r) - target|. Notice that func should be called with the values l and r where 0 <= l, r < arr.length. Example 1: Input: arr = [9,12,3,7,15], target = 5 Output: 2 Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2. Example 2: Input: arr = [1000000,1000000,1000000], target = 1 Output: 999999 Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999. Example 3: Input: arr = [1,2,4,8,16], target = 0 Output: 0 Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 106 0 <= target <= 107",
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "questionId": 1075
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i]. Return true if it is possible to form the array arr from pieces. Otherwise, return false. Example 1: Input: arr = [15,88], pieces = [[88],[15]] Output: true Explanation: Concatenate [15] then [88] Example 2: Input: arr = [49,18,16], pieces = [[16,18,49]] Output: false Explanation: Even though the numbers match, we cannot reorder pieces[0]. Example 3: Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]] Output: true Explanation: Concatenate [91] then [4,64] then [78] Constraints: 1 <= pieces.length <= arr.length <= 100 sum(pieces[i].length) == arr.length 1 <= pieces[i].length <= arr.length 1 <= arr[i], pieces[i][j] <= 100 The integers in arr are distinct. The integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).",
        "title": "Check Array Formation Through Concatenation",
        "questionId": 1154
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: 'a' maps to \".-\", 'b' maps to \"-...\", 'c' maps to \"-.-.\", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. Example 1: Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" There are 2 different transformations: \"--...-.\" and \"--...--.\". Example 2: Input: words = [\"a\"] Output: 1 Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 12 words[i] consists of lowercase English letters.",
        "title": "Unique Morse Code Words",
        "questionId": 553
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n. Example 1: Input: nums = [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3. Example 2: Input: nums = [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10. Example 3: Input: nums = [-3,-2,-3] Output: -2 Explanation: Subarray [-2] has maximum sum -2. Constraints: n == nums.length 1 <= n <= 3 * 104 -3 * 104 <= nums[i] <= 3 * 104",
        "title": "Maximum Sum Circular Subarray",
        "questionId": 657
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k. The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all the coordinates of matrix. Example 1: Input: matrix = [[5,2],[1,6]], k = 1 Output: 7 Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. Example 2: Input: matrix = [[5,2],[1,6]], k = 2 Output: 5 Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. Example 3: Input: matrix = [[5,2],[1,6]], k = 3 Output: 4 Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 1000 0 <= matrix[i][j] <= 106 1 <= k <= m * n",
        "title": "Find Kth Largest XOR Coordinate Value",
        "questionId": 1221
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string of digits num, such as \"123456579\". We can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] < 231, (that is, each integer fits in a 32-bit signed integer type), f.length >= 3, and f[i] + f[i + 1] == f[i + 2] for all 0 <= i < f.length - 2. Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from num, or return [] if it cannot be done. Example 1: Input: num = \"1101111\" Output: [11,0,11,11] Explanation: The output [110, 1, 111] would also be accepted. Example 2: Input: num = \"112358130\" Output: [] Explanation: The task is impossible. Example 3: Input: num = \"0123\" Output: [] Explanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid. Constraints: 1 <= num.length <= 200 num contains only digits.",
        "title": "Split Array into Fibonacci Sequence",
        "questionId": 589
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A string is considered beautiful if it satisfies the following conditions: Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it. The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.). For example, strings \"aeiou\" and \"aaaaaaeiiiioou\" are considered beautiful, but \"uaeio\", \"aeoiu\", and \"aaaeeeooo\" are not beautiful. Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0. A substring is a contiguous sequence of characters in a string. Example 1: Input: word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\" Output: 13 Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13. Example 2: Input: word = \"aeeeiiiioooauuuaeiou\" Output: 5 Explanation: The longest beautiful substring in word is \"aeiou\" of length 5. Example 3: Input: word = \"a\" Output: 0 Explanation: There is no beautiful substring, so return 0. Constraints: 1 <= word.length <= 5 * 105 word consists of characters 'a', 'e', 'i', 'o', and 'u'.",
        "title": "Longest Substring Of All Vowels in Order",
        "questionId": 1291
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true. The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length). Example 1: Input: nums = [1,2,10,5,7] Output: true Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7]. [1,2,5,7] is strictly increasing, so return true. Example 2: Input: nums = [2,3,1,2] Output: false Explanation: [3,1,2] is the result of removing the element at index 0. [2,1,2] is the result of removing the element at index 1. [2,3,2] is the result of removing the element at index 2. [2,3,1] is the result of removing the element at index 3. No resulting array is strictly increasing, so return false. Example 3: Input: nums = [1,1,1] Output: false Explanation: The result of removing any element is [1,1]. [1,1] is not strictly increasing, so return false. Constraints: 2 <= nums.length <= 1000 1 <= nums[i] <= 1000",
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "questionId": 1326
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design a data structure that efficiently finds the majority element of a given subarray. The majority element of a subarray is an element that occurs threshold times or more in the subarray. Implementing the MajorityChecker class: MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr. int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists. Example 1: Input [\"MajorityChecker\", \"query\", \"query\", \"query\"] [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]] Output [null, 1, -1, 2] Explanation MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]); majorityChecker.query(0, 5, 4); // return 1 majorityChecker.query(0, 3, 3); // return -1 majorityChecker.query(2, 3, 2); // return 2 Constraints: 1 <= arr.length <= 2 * 104 1 <= arr[i] <= 2 * 104 0 <= left <= right < arr.length threshold <= right - left + 1 2 * threshold > right - left + 1 At most 104 calls will be made to query.",
        "title": "Online Majority Element In Subarray",
        "questionId": 816
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed. Example 1: Input: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\" Output: [ [\"mobile\",\"moneypot\",\"monitor\"], [\"mobile\",\"moneypot\",\"monitor\"], [\"mouse\",\"mousepad\"], [\"mouse\",\"mousepad\"], [\"mouse\",\"mousepad\"] ] Explanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"] After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"] After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"] Example 2: Input: products = [\"havana\"], searchWord = \"havana\" Output: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]] Example 3: Input: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\" Output: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]] Constraints: 1 <= products.length <= 1000 1 <= products[i].length <= 3000 1 <= sum(products[i].length) <= 2 * 104 All the strings of products are unique. products[i] consists of lowercase English letters. 1 <= searchWord.length <= 1000 searchWord consists of lowercase English letters.",
        "title": "Search Suggestions System",
        "questionId": 897
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class: Solution() Initializes the object of the system. String encode(String longUrl) Returns a tiny URL for the given longUrl. String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object. Example 1: Input: url = \"https://leetcode.com/problems/design-tinyurl\" Output: \"https://leetcode.com/problems/design-tinyurl\" Explanation: Solution obj = new Solution(); string tiny = obj.encode(url); // returns the encoded tiny url. string ans = obj.decode(tiny); // returns the original url after deconding it. Constraints: 1 <= url.length <= 104 url is guranteed to be a valid URL.",
        "title": "Encode and Decode TinyURL",
        "questionId": 377
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "A transaction is possibly invalid if: the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city. You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction. Return a list of transactions that are possibly invalid. You may return the answer in any order. Example 1: Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"] Output: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"] Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. Example 2: Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"] Output: [\"alice,50,1200,mtv\"] Example 3: Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"] Output: [\"bob,50,1200,mtv\"] Constraints: transactions.length <= 1000 Each transactions[i] takes the form \"{name},{time},{amount},{city}\" Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10. Each {time} consist of digits, and represent an integer between 0 and 1000. Each {amount} consist of digits, and represent an integer between 0 and 2000.",
        "title": "Invalid Transactions",
        "questionId": 821
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given two integer arrays nums1 and nums2 of length n. The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed). For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4. Rearrange the elements of nums2 such that the resulting XOR sum is minimized. Return the XOR sum after the rearrangement. Example 1: Input: nums1 = [1,2], nums2 = [2,3] Output: 2 Explanation: Rearrange nums2 so that it becomes [3,2]. The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2. Example 2: Input: nums1 = [1,0,3], nums2 = [5,3,4] Output: 8 Explanation: Rearrange nums2 so that it becomes [5,4,3]. The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8. Constraints: n == nums1.length n == nums2.length 1 <= n <= 14 0 <= nums1[i], nums2[i] <= 107",
        "title": "Minimum XOR Sum of Two Arrays",
        "questionId": 1305
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Example 1: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move. Example 2: Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved. Example 3: Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]] Constraints: board.length == 2 board[i].length == 3 0 <= board[i][j] <= 5 Each value board[i][j] is unique.",
        "title": "Sliding Puzzle",
        "questionId": 522
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order). You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation. Return the smallest possible total score that you can achieve with some triangulation of the polygon. Example 1: Input: values = [1,2,3] Output: 6 Explanation: The polygon is already triangulated, and the score of the only triangle is 6. Example 2: Input: values = [3,7,4,5] Output: 144 Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144. The minimum score is 144. Example 3: Input: values = [1,3,1,4,1,5] Output: 13 Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13. Constraints: n == values.length 3 <= n <= 50 1 <= values[i] <= 100",
        "title": "Minimum Score Triangulation of Polygon",
        "questionId": 757
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step. Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1. Example 1: Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1 Output: 6 Explanation: The shortest path without eliminating any obstacle is 10. The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2). Example 2: Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1 Output: -1 Explanation: We need to eliminate at least two obstacles to find such a walk. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 40 1 <= k <= m * n grid[i][j] is either 0 or 1. grid[0][0] == grid[m - 1][n - 1] == 0",
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "questionId": 909
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals: 2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1. 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied. 0, if none of the previous conditions holds. Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2. Example 1: Input: nums = [1,2,3] Output: 2 Explanation: For each index i in the range 1 <= i <= 1: - The beauty of nums[1] equals 2. Example 2: Input: nums = [2,4,6,4] Output: 1 Explanation: For each index i in the range 1 <= i <= 2: - The beauty of nums[1] equals 1. - The beauty of nums[2] equals 0. Example 3: Input: nums = [3,2,1] Output: 0 Explanation: For each index i in the range 1 <= i <= 1: - The beauty of nums[1] equals 0. Constraints: 3 <= nums.length <= 105 1 <= nums[i] <= 105",
        "title": "Sum of Beauty in the Array",
        "questionId": 1412
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1. Example 1: Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 Example 2: Input: nums = [1,2] Output: 1 Explanation: Minimum start value should be positive. Example 3: Input: nums = [1,-2,-3] Output: 5 Constraints: 1 <= nums.length <= 100 -100 <= nums[i] <= 100",
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "questionId": 984
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: Solution(ListNode head) Initializes the object with the head of the singly-linked list head. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen. Example 1: Input [\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 3, 2, 2, 3] Explanation Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // return 1 solution.getRandom(); // return 3 solution.getRandom(); // return 2 solution.getRandom(); // return 2 solution.getRandom(); // return 3 // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. Constraints: The number of nodes in the linked list will be in the range [1, 104]. -104 <= Node.val <= 104 At most 104 calls will be made to getRandom. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?",
        "title": "Linked List Random Node",
        "questionId": 263
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that: The ith customer gets exactly quantity[i] integers, The integers the ith customer gets are all equal, and Every customer is satisfied. Return true if it is possible to distribute nums according to the above conditions. Example 1: Input: nums = [1,2,3,4], quantity = [2] Output: false Explanation: The 0th customer cannot be given two different integers. Example 2: Input: nums = [1,2,3,3], quantity = [2] Output: true Explanation: The 0th customer is given [3,3]. The integers [1,2] are not used. Example 3: Input: nums = [1,1,2,2], quantity = [2,2] Output: true Explanation: The 0th customer is given [1,1], and the 1st customer is given [2,2]. Constraints: n == nums.length 1 <= n <= 105 1 <= nums[i] <= 1000 m == quantity.length 1 <= m <= 10 1 <= quantity[i] <= 105 There are at most 50 unique values in nums.",
        "title": "Distribute Repeating Integers",
        "questionId": 1153
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x. Return the maximum number of consecutive integer values that you can make with your coins starting from and including 0. Note that you may have multiple coins of the same value. Example 1: Input: coins = [1,3] Output: 2 Explanation: You can make the following values: - 0: take [] - 1: take [1] You can make 2 consecutive integer values starting from 0. Example 2: Input: coins = [1,1,1,4] Output: 8 Explanation: You can make the following values: - 0: take [] - 1: take [1] - 2: take [1,1] - 3: take [1,1,1] - 4: take [4] - 5: take [4,1] - 6: take [4,1,1] - 7: take [4,1,1,1] You can make 8 consecutive integer values starting from 0. Example 3: Input: nums = [1,4,10,3,1] Output: 20 Constraints: coins.length == n 1 <= n <= 4 * 104 1 <= coins[i] <= 4 * 104",
        "title": "Maximum Number of Consecutive Values You Can Make",
        "questionId": 1266
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules: If the current number is even, you have to divide it by 2. If the current number is odd, you have to add 1 to it. It is guaranteed that you can always reach one for all test cases. Example 1: Input: s = \"1101\" Output: 6 Explanation: \"1101\" corressponds to number 13 in their decimal representation. Step 1) 13 is odd, add 1 and obtain 14. Step 2) 14 is even, divide by 2 and obtain 7. Step 3) 7 is odd, add 1 and obtain 8. Step 4) 8 is even, divide by 2 and obtain 4. Step 5) 4 is even, divide by 2 and obtain 2. Step 6) 2 is even, divide by 2 and obtain 1. Example 2: Input: s = \"10\" Output: 1 Explanation: \"10\" corressponds to number 2 in their decimal representation. Step 1) 2 is even, divide by 2 and obtain 1. Example 3: Input: s = \"1\" Output: 0 Constraints: 1 <= s.length <= 500 s consists of characters '0' or '1' s[0] == '1'",
        "title": "Number of Steps to Reduce a Number in Binary Representation to One",
        "questionId": 989
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values. We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images. Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased. Return the largest possible overlap. Example 1: Input: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]] Output: 3 Explanation: We translate img1 to right by 1 unit and down by 1 unit. The number of positions that have a 1 in both images is 3 (shown in red). Example 2: Input: img1 = [[1]], img2 = [[1]] Output: 1 Example 3: Input: img1 = [[0]], img2 = [[0]] Output: 0 Constraints: n == img1.length == img1[i].length n == img2.length == img2[i].length 1 <= n <= 30 img1[i][j] is either 0 or 1. img2[i][j] is either 0 or 1.",
        "title": "Image Overlap",
        "questionId": 582
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network. You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1. Example 1: Input: n = 4, connections = [[0,1],[0,2],[1,2]] Output: 1 Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3. Example 2: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output: 2 Example 3: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output: -1 Explanation: There are not enough cables. Constraints: 1 <= n <= 105 1 <= connections.length <= min(n * (n - 1) / 2, 105) connections[i].length == 2 0 <= ai, bi < n ai != bi There are no repeated connections. No two computers are connected by more than one cable.",
        "title": "Number of Operations to Make Network Connected",
        "questionId": 923
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x. Notice that x does not have to be an element in nums. Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique. Example 1: Input: nums = [3,5] Output: 2 Explanation: There are 2 values (3 and 5) that are greater than or equal to 2. Example 2: Input: nums = [0,0] Output: -1 Explanation: No numbers fit the criteria for x. If x = 0, there should be 0 numbers >= x, but there are 2. If x = 1, there should be 1 number >= x, but there are 0. If x = 2, there should be 2 numbers >= x, but there are 0. x cannot be greater since there are only 2 numbers in nums. Example 3: Input: nums = [0,4,3,0,4] Output: 3 Explanation: There are 3 values that are greater than or equal to 3. Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 1000",
        "title": "Special Array With X Elements Greater Than or Equal X",
        "questionId": 1134
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number of white bishops 'B', black pawns 'p', and empty squares '.'. When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking. Return the number of available captures for the white rook. Example 1: Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: In this example, the rook is attacking all the pawns. Example 2: Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 0 Explanation: The bishops are blocking the rook from attacking any of the pawns. Example 3: Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: The rook is attacking the pawns at positions b5, d6, and f5. Constraints: board.length == 8 board[i].length == 8 board[i][j] is either 'R', '.', 'B', or 'p' There is exactly one cell with board[i][j] == 'R'",
        "title": "Available Captures for Rook",
        "questionId": 727
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design a data structure to find the frequency of a given value in a given subarray. The frequency of a value in a subarray is the number of occurrences of that value in the subarray. Implement the RangeFreqQuery class: RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr. int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left...right]. A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive). Example 1: Input [\"RangeFreqQuery\", \"query\", \"query\"] [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]] Output [null, 1, 2] Explanation RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]); rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4] rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array. Constraints: 1 <= arr.length <= 105 1 <= arr[i], value <= 104 0 <= left <= right < arr.length At most 105 calls will be made to query",
        "title": "Range Frequency Queries",
        "questionId": 839
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array arr of distinct integers and an integer k. A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds. Return the integer which will win the game. It is guaranteed that there will be a winner of the game. Example 1: Input: arr = [2,1,3,5,4,6,7], k = 2 Output: 5 Explanation: Let's see the rounds of the game: Round | arr | winner | win_count 1 | [2,1,3,5,4,6,7] | 2 | 1 2 | [2,3,5,4,6,7,1] | 3 | 1 3 | [3,5,4,6,7,1,2] | 5 | 1 4 | [5,4,6,7,1,2,3] | 5 | 2 So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games. Example 2: Input: arr = [3,2,1], k = 10 Output: 3 Explanation: 3 will win the first 10 rounds consecutively. Constraints: 2 <= arr.length <= 105 1 <= arr[i] <= 106 arr contains distinct integers. 1 <= k <= 109",
        "title": "Find the Winner of an Array Game",
        "questionId": 1084
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alice and Bob take turns, with Alice starting first. Initially, M = 1. On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M. Then, we set M = max(M, X). The game continues until all the stones have been taken. Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get. Example 1: Input: piles = [2,7,9,4,4] Output: 10 Explanation: If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. Example 2: Input: piles = [1,2,3,4,5,100] Output: 104 Constraints: 1 <= piles.length <= 100 1 <= piles[i] <= 104",
        "title": "Stone Game II",
        "questionId": 802
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1. You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3. Return a list of groups such that each person i is in a group of size groupSizes[i]. Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. Example 1: Input: groupSizes = [3,3,3,3,3,1,3] Output: [[5],[0,1,2],[3,4,6]] Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. Example 2: Input: groupSizes = [2,1,3,3,3,2] Output: [[1],[0,5],[2,3,4]] Constraints: groupSizes.length == n 1 <= n <= 500 1 <= groupSizes[i] <= n",
        "title": "Group the People Given the Group Size They Belong To",
        "questionId": 904
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain. Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. Constraints: 1 <= cardPoints.length <= 105 1 <= cardPoints[i] <= 104 1 <= k <= cardPoints.length",
        "title": "Maximum Points You Can Obtain from Cards",
        "questionId": 1004
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "The min-product of an array is equal to the minimum value in the array multiplied by the array's sum. For example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20. Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7. Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer. A subarray is a contiguous part of an array. Example 1: Input: nums = [1,2,3,2] Output: 14 Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2). 2 * (2+3+2) = 2 * 7 = 14. Example 2: Input: nums = [2,3,3,1,2] Output: 18 Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3). 3 * (3+3) = 3 * 6 = 18. Example 3: Input: nums = [3,1,5,6,4,2] Output: 60 Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4). 4 * (5+6+4) = 4 * 15 = 60. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 107",
        "title": "Maximum Subarray Min-Product",
        "questionId": 1301
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6) \"KJF\" with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Input: s = \"12\" Output: 2 Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). Constraints: 1 <= s.length <= 100 s contains only digits and may contain leading zero(s).",
        "title": "Decode Ways",
        "questionId": 80
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied). You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements: Cover all the empty cells. Do not cover any of the occupied cells. We can put as many stamps as we want. Stamps can overlap with each other. Stamps are not allowed to be rotated. Stamps must stay completely inside the grid. Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false. Example 1: Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 Output: true Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. Example 2: Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 Output: false Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 105 1 <= m * n <= 2 * 105 grid[r][c] is either 0 or 1. 1 <= stampHeight, stampWidth <= 105",
        "title": "Stamping the Grid",
        "questionId": 1459
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'. Return the number of positive integers that can be generated that are less than or equal to a given integer n. Example 1: Input: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100 Output: 20 Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. Example 2: Input: digits = [\"1\",\"4\",\"9\"], n = 1000000000 Output: 29523 Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits array. Example 3: Input: digits = [\"7\"], n = 8 Output: 1 Constraints: 1 <= digits.length <= 9 digits[i].length == 1 digits[i] is a digit from '1' to '9'. All the values in digits are unique. digits is sorted in non-decreasing order. 1 <= n <= 109",
        "title": "Numbers At Most N Given Digit Set",
        "questionId": 643
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two strings s and t of the same length and an integer maxCost. You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters). Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0. Example 1: Input: s = \"abcd\", t = \"bcdf\", maxCost = 3 Output: 3 Explanation: \"abc\" of s can change to \"bcd\". That costs 3, so the maximum length is 3. Example 2: Input: s = \"abcd\", t = \"cdef\", maxCost = 3 Output: 1 Explanation: Each character in s costs 2 to change to character in t, so the maximum length is 1. Example 3: Input: s = \"abcd\", t = \"acde\", maxCost = 0 Output: 1 Explanation: You cannot make any change, so the maximum length is 1. Constraints: 1 <= s.length <= 105 t.length == s.length 0 <= maxCost <= 106 s and t consist of only lowercase English letters.",
        "title": "Get Equal Substrings Within Budget",
        "questionId": 859
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A string is a valid parentheses string (denoted VPS) if it meets one of the following: It is an empty string \"\", or a single character not equal to \"(\" or \")\", It can be written as AB (A concatenated with B), where A and B are VPS's, or It can be written as (A), where A is a VPS. We can similarly define the nesting depth depth(S) of any VPS S as follows: depth(\"\") = 0 depth(C) = 0, where C is a string with a single character not equal to \"(\" or \")\". depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's. depth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS. For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's. Given a VPS represented as string s, return the nesting depth of s. Example 1: Input: s = \"(1+(2*3)+((8)/4))+1\" Output: 3 Explanation: Digit 8 is inside of 3 nested parentheses in the string. Example 2: Input: s = \"(1)+((2))+(((3)))\" Output: 3 Constraints: 1 <= s.length <= 100 s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'. It is guaranteed that parentheses expression s is a VPS.",
        "title": "Maximum Nesting Depth of the Parentheses",
        "questionId": 1137
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s. The distance between two indices i and j is abs(i - j), where abs is the absolute value function. Example 1: Input: s = \"loveleetcode\", c = \"e\" Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2. Example 2: Input: s = \"aaab\", c = \"b\" Output: [3,2,1,0] Constraints: 1 <= s.length <= 104 s[i] and c are lowercase English letters. It is guaranteed that c occurs at least once in s.",
        "title": "Shortest Distance to a Character",
        "questionId": 569
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target. In one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'. Return the minimum number of operations needed to make s equal to target. Example 1: Input: target = \"10111\" Output: 3 Explanation: Initially, s = \"00000\". Choose index i = 2: \"00000\" -> \"00111\" Choose index i = 0: \"00111\" -> \"11000\" Choose index i = 1: \"11000\" -> \"10111\" We need at least 3 flip operations to form target. Example 2: Input: target = \"101\" Output: 3 Explanation: Initially, s = \"000\". Choose index i = 0: \"000\" -> \"111\" Choose index i = 1: \"111\" -> \"100\" Choose index i = 2: \"100\" -> \"101\" We need at least 3 flip operations to form target. Example 3: Input: target = \"00000\" Output: 0 Explanation: We do not need any operations since the initial s already equals target. Constraints: n == target.length 1 <= n <= 105 target[i] is either '0' or '1'.",
        "title": "Minimum Suffix Flips",
        "questionId": 1081
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. \r \r For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\r \r Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\r \r \r Example 1:\r \r \r \r \r Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\r Output: 3 \r Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\r \r \r Example 2:\r \r \r Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\r Output: 1\r \r \r Example 3:\r \r \r Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\r Output: 1\r \r \r \r Constraints:\r \r \r 1 <= rows, cols <= 50\r rows == pizza.length\r cols == pizza[i].length\r 1 <= k <= 10\r pizza consists of characters 'A' and '.' only.",
        "title": "Number of Ways of Cutting a Pizza",
        "questionId": 1017
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules: The cost of painting a digit (i + 1) is given by cost[i] (0-indexed). The total cost used must be equal to target. The integer does not have 0 digits. Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return \"0\". Example 1: Input: cost = [4,3,2,5,6,7,2,5,5], target = 9 Output: \"7772\" Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number. Digit cost 1 -> 4 2 -> 3 3 -> 2 4 -> 5 5 -> 6 6 -> 7 7 -> 2 8 -> 5 9 -> 5 Example 2: Input: cost = [7,6,5,5,5,6,8,7,8], target = 12 Output: \"85\" Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12. Example 3: Input: cost = [2,4,6,2,4,6,4,4,4], target = 5 Output: \"0\" Explanation: It is impossible to paint any integer with total cost equal to target. Constraints: cost.length == 9 1 <= cost[i], target <= 5000",
        "title": "Form Largest Integer With Digits That Add up to Target",
        "questionId": 1009
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Example 1: Input: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2: Input: g = [1,2], s = [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Constraints: 1 <= g.length <= 3 * 104 0 <= s.length <= 3 * 104 1 <= g[i], s[j] <= 231 - 1",
        "title": "Assign Cookies",
        "questionId": 320
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an integer array nums of length n. Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow: F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]. Return the maximum value of F(0), F(1), ..., F(n-1). The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Input: nums = [4,3,2,6] Output: 26 Explanation: F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26 So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26. Example 2: Input: nums = [100] Output: 0 Constraints: n == nums.length 1 <= n <= 105 -100 <= nums[i] <= 100",
        "title": "Rotate Function",
        "questionId": 277
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string s that consists of only digits. Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and the difference between numerical values of every two adjacent substrings is equal to 1. For example, the string s = \"0090089\" can be split into [\"0090\", \"089\"] with numerical values [90,89]. The values are in descending order and adjacent values differ by 1, so this way is valid. Another example, the string s = \"001\" can be split into [\"0\", \"01\"], [\"00\", \"1\"], or [\"0\", \"0\", \"1\"]. However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order. Return true if it is possible to split s\u200b\u200b\u200b\u200b\u200b\u200b as described above, or false otherwise. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"1234\" Output: false Explanation: There is no valid way to split s. Example 2: Input: s = \"050043\" Output: true Explanation: s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3]. The values are in descending order with adjacent values differing by 1. Example 3: Input: s = \"9080701\" Output: false Explanation: There is no valid way to split s. Constraints: 1 <= s.length <= 20 s only consists of digits.",
        "title": "Splitting a String Into Descending Consecutive Values",
        "questionId": 1296
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "content": "You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi. We can cut these clips into segments freely. For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7]. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1. Example 1: Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10 Output: 3 Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10]. Example 2: Input: clips = [[0,1],[1,2]], time = 5 Output: -1 Explanation: We cannot cover [0,5] with only [0,1] and [1,2]. Example 3: Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9 Output: 3 Explanation: We can take clips [0,4], [4,7], and [6,9]. Constraints: 1 <= clips.length <= 100 0 <= starti <= endi <= 100 1 <= time <= 100",
        "title": "Video Stitching",
        "questionId": 746
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], otherwise, you will not receive any discount at all. Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount. Example 1: Input: prices = [8,4,6,2,3] Output: [4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. Example 2: Input: prices = [1,2,3,4,5] Output: [1,2,3,4,5] Explanation: In this case, for all items, you will not receive any discount at all. Example 3: Input: prices = [10,1,1,6] Output: [9,0,1,6] Constraints: 1 <= prices.length <= 500 1 <= prices[i] <= 10^3",
        "title": "Final Prices With a Special Discount in a Shop",
        "questionId": 1030
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums. For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST. Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums. Since the answer may be very large, return it modulo 109 + 7. Example 1: Input: nums = [2,1,3] Output: 1 Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST. Example 2: Input: nums = [3,4,5,1,2] Output: 5 Explanation: The following 5 arrays will yield the same BST: [3,1,2,4,5] [3,1,4,2,5] [3,1,4,5,2] [3,4,1,2,5] [3,4,1,5,2] Example 3: Input: nums = [1,2,3] Output: 0 Explanation: There are no other orderings of nums that will yield the same BST. Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= nums.length All integers in nums are distinct.",
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "questionId": 1108
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer. Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. Example 1: Input [\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 2, 2, 3, false] Explanation PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3] peekingIterator.next(); // return 1, the pointer moves to the next element [1,2,3]. peekingIterator.peek(); // return 2, the pointer does not move [1,2,3]. peekingIterator.next(); // return 2, the pointer moves to the next element [1,2,3] peekingIterator.next(); // return 3, the pointer moves to the next element [1,2,3] peekingIterator.hasNext(); // return False Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 1000 All the calls to next and peek are valid. At most 1000 calls will be made to next, hasNext, and peek. Follow up: How would you extend your design to be generic and work with all types, not just integer?",
        "title": "Peeking Iterator",
        "questionId": 203
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute. On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied. The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once. Return the maximum number of customers that can be satisfied throughout the day. Example 1: Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. Example 2: Input: customers = [1], grumpy = [0], minutes = 1 Output: 1 Constraints: n == customers.length == grumpy.length 1 <= minutes <= n <= 2 * 104 0 <= customers[i] <= 1000 grumpy[i] is either 0 or 1.",
        "title": "Grumpy Bookstore Owner",
        "questionId": 767
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream. Implement the ProductOfNumbers class: ProductOfNumbers() Initializes the object with an empty stream. void add(int num) Appends the integer num to the stream. int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers. The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. Example: Input [\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"] [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]] Output [null,null,null,null,null,null,20,40,0,null,32] Explanation ProductOfNumbers productOfNumbers = new ProductOfNumbers(); productOfNumbers.add(3); // [3] productOfNumbers.add(0); // [3,0] productOfNumbers.add(2); // [3,0,2] productOfNumbers.add(5); // [3,0,2,5] productOfNumbers.add(4); // [3,0,2,5,4] productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20 productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40 productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0 productOfNumbers.add(8); // [3,0,2,5,4,8] productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 Constraints: 0 <= num <= 100 1 <= k <= 4 * 104 At most 4 * 104 calls will be made to add and getProduct. The product of the stream at any point in time will fit in a 32-bit integer.",
        "title": "Product of the Last K Numbers",
        "questionId": 954
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes. The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes. Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2 Output: 0.78333 Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333. Example 2: Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 Output: 0.53485 Constraints: 1 <= classes.length <= 105 classes[i].length == 2 1 <= passi <= totali <= 105 1 <= extraStudents <= 105",
        "title": "Maximum Average Pass Ratio",
        "questionId": 1257
    },
    {
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are 8 prison cells in a row and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors. You are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n. Return the state of the prison after n days (i.e., n such changes described above). Example 1: Input: cells = [0,1,0,1,1,0,0,1], n = 7 Output: [0,0,1,1,0,0,0,0] Explanation: The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0] Example 2: Input: cells = [1,0,0,1,0,0,1,0], n = 1000000000 Output: [0,0,1,1,1,1,1,0] Constraints: cells.length == 8 cells[i] is either 0 or 1. 1 <= n <= 109",
        "title": "Prison Cells After N Days",
        "questionId": 689
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive. In one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive. Return the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. Return -1\u200b\u200b\u200b\u200b\u200b if it is not possible to make the sum of the two arrays equal. Example 1: Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] Output: 3 Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. - Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2]. - Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2]. - Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2]. Example 2: Input: nums1 = [1,1,1,1,1,1,1], nums2 = [6] Output: -1 Explanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal. Example 3: Input: nums1 = [6,6], nums2 = [1] Output: 3 Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. - Change nums1[0] to 2. nums1 = [2,6], nums2 = [1]. - Change nums1[1] to 2. nums1 = [2,2], nums2 = [1]. - Change nums2[0] to 4. nums1 = [2,2], nums2 = [4]. Constraints: 1 <= nums1.length, nums2.length <= 105 1 <= nums1[i], nums2[i] <= 6",
        "title": "Equal Sum Arrays With Minimum Number of Operations",
        "questionId": 1246
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities. There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively. Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all. A subpath of a path is a contiguous sequence of cities within that path. Example 1: Input: n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] Output: 2 Explanation: The longest common subpath is [2,3]. Example 2: Input: n = 3, paths = [[0],[1],[2]] Output: 0 Explanation: There is no common subpath shared by the three paths. Example 3: Input: n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] Output: 1 Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1. Constraints: 1 <= n <= 105 m == paths.length 2 <= m <= 105 sum(paths[i].length) <= 105 0 <= paths[i][j] < n The same city is not listed multiple times consecutively in paths[i].",
        "title": "Longest Common Subpath",
        "questionId": 1350
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order). Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them. An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0. Note: Test cases are generated such that there will always be at least one correct answer. Example 1: Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3] Output: [1,2,-3] Explanation: [1,2,-3] is able to achieve the given subset sums: - []: sum is 0 - [1]: sum is 1 - [2]: sum is 2 - [1,2]: sum is 3 - [-3]: sum is -3 - [1,-3]: sum is -2 - [2,-3]: sum is -1 - [1,2,-3]: sum is 0 Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted. Example 2: Input: n = 2, sums = [0,0,0,0] Output: [0,0] Explanation: The only correct answer is [0,0]. Example 3: Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] Output: [0,-1,4,5] Explanation: [0,-1,4,5] is able to achieve the given subset sums. Constraints: 1 <= n <= 15 sums.length == 2n -104 <= sums[i] <= 104",
        "title": "Find Array Given Subset Sums",
        "questionId": 1389
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words. For example, if words = [\"abc\", \"xyz\"] and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', your algorithm should detect that the suffix \"xyz\" of the characters \"axyz\" matches \"xyz\" from words. Implement the StreamChecker class: StreamChecker(String[] words) Initializes the object with the strings array words. boolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words. Example 1: Input [\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"] [[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]] Output [null, false, false, false, true, false, true, false, false, false, false, false, true] Explanation StreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]); streamChecker.query(\"a\"); // return False streamChecker.query(\"b\"); // return False streamChecker.query(\"c\"); // return False streamChecker.query(\"d\"); // return True, because 'cd' is in the wordlist streamChecker.query(\"e\"); // return False streamChecker.query(\"f\"); // return True, because 'f' is in the wordlist streamChecker.query(\"g\"); // return False streamChecker.query(\"h\"); // return False streamChecker.query(\"i\"); // return False streamChecker.query(\"j\"); // return False streamChecker.query(\"k\"); // return False streamChecker.query(\"l\"); // return True, because 'kl' is in the wordlist Constraints: 1 <= words.length <= 2000 1 <= words[i].length <= 2000 words[i] consists of lowercase English letters. letter is a lowercase English letter. At most 4 * 104 calls will be made to query.",
        "title": "Stream of Characters",
        "questionId": 753
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happen before addition and subtraction. It is not allowed to use the unary negation operator (-). For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. Example 2: Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations. Constraints: 2 <= x <= 100 1 <= target <= 2 * 108",
        "title": "Least Operators to Express Number",
        "questionId": 695
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer n, the number of teams in a tournament that has strange rules: If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round. If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round. Return the number of matches played in the tournament until a winner is decided. Example 1: Input: n = 7 Output: 6 Explanation: Details of the tournament: - 1st Round: Teams = 7, Matches = 3, and 4 teams advance. - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. Example 2: Input: n = 14 Output: 13 Explanation: Details of the tournament: - 1st Round: Teams = 14, Matches = 7, and 7 teams advance. - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. Constraints: 1 <= n <= 200",
        "title": "Count of Matches in Tournament",
        "questionId": 1188
    },
    {
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1: Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: -231 <= val <= 231 - 1 At most 2 * 105 calls will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called.",
        "title": "Insert Delete GetRandom O(1)",
        "questionId": 261
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1). In one move the snake can: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is. Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is. Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c). Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1). Return the minimum number of moves to reach the target. If there is no way to reach the target, return -1. Example 1: Input: grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] Output: 11 Explanation: One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]. Example 2: Input: grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] Output: 9 Constraints: 2 <= n <= 100 0 <= grid[i][j] <= 1 It is guaranteed that the snake starts at empty cells.",
        "title": "Minimum Moves to Reach Target with Rotations",
        "questionId": 860
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] Constraints: n == candies.length 2 <= n <= 100 1 <= candies[i] <= 100 1 <= extraCandies <= 50",
        "title": "Kids With the Greatest Number of Candies",
        "questionId": 995
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible. Example 1: Input: original = [1,2,3,4], m = 2, n = 2 Output: [[1,2],[3,4]] Explanation: The constructed 2D array should contain 2 rows and 2 columns. The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array. The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array. Example 2: Input: original = [1,2,3], m = 1, n = 3 Output: [[1,2,3]] Explanation: The constructed 2D array should contain 1 row and 3 columns. Put all three elements in original into the first row of the constructed 2D array. Example 3: Input: original = [1,2], m = 1, n = 1 Output: [] Explanation: There are 2 elements in original. It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array. Constraints: 1 <= original.length <= 5 * 104 1 <= original[i] <= 105 1 <= m, n <= 4 * 104",
        "title": "Convert 1D Array Into 2D Array",
        "questionId": 1407
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes. Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise. Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query. Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. Constraints: 2 <= n <= 105 1 <= edgeList.length, queries.length <= 105 edgeList[i].length == 3 queries[j].length == 3 0 <= ui, vi, pj, qj <= n - 1 ui != vi pj != qj 1 <= disi, limitj <= 109 There may be multiple edges between two nodes.",
        "title": "Checking Existence of Edge Length Limited Paths",
        "questionId": 1194
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. Example 1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example 2: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. Example 3: Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] Output: 0 Constraints: n == source.length == target.length 1 <= n <= 105 1 <= source[i], target[i] <= 105 0 <= allowedSwaps.length <= 105 allowedSwaps[i].length == 2 0 <= ai, bi <= n - 1 ai != bi",
        "title": "Minimize Hamming Distance After Swap Operations",
        "questionId": 1211
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "You are given a string num, representing a large integer, and an integer k. We call some integer wonderful if it is a permutation of the digits in num and is greater in value than num. There can be many wonderful integers. However, we only care about the smallest-valued ones. For example, when num = \"5489355142\": The 1st smallest wonderful integer is \"5489355214\". The 2nd smallest wonderful integer is \"5489355241\". The 3rd smallest wonderful integer is \"5489355412\". The 4th smallest wonderful integer is \"5489355421\". Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer. The tests are generated in such a way that kth smallest wonderful integer exists. Example 1: Input: num = \"5489355142\", k = 4 Output: 2 Explanation: The 4th smallest wonderful number is \"5489355421\". To get this number: - Swap index 7 with index 8: \"5489355142\" -> \"5489355412\" - Swap index 8 with index 9: \"5489355412\" -> \"5489355421\" Example 2: Input: num = \"11112\", k = 4 Output: 4 Explanation: The 4th smallest wonderful number is \"21111\". To get this number: - Swap index 3 with index 4: \"11112\" -> \"11121\" - Swap index 2 with index 3: \"11121\" -> \"11211\" - Swap index 1 with index 2: \"11211\" -> \"12111\" - Swap index 0 with index 1: \"12111\" -> \"21111\" Example 3: Input: num = \"00123\", k = 1 Output: 1 Explanation: The 1st smallest wonderful number is \"00132\". To get this number: - Swap index 3 with index 4: \"00123\" -> \"00132\" Constraints: 2 <= num.length <= 1000 1 <= k <= 1000 num only consists of digits.",
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "questionId": 1298
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot. The lock initially starts at '0000', a string representing the state of the 4 wheels. You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible. Example 1: Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". Example 2: Input: deadends = [\"8888\"], target = \"0009\" Output: 1 Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\". Example 3: Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\" Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints: 1 <= deadends.length <= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only.",
        "title": "Open the Lock",
        "questionId": 503
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Under the grammar given below, strings can represent a set of lowercase words. Let R(expr) denote the set of words the expression represents. The grammar can best be understood through simple examples: Single letters represent a singleton set containing that word. R(\"a\") = {\"a\"} R(\"w\") = {\"w\"} When we take a comma-delimited list of two or more expressions, we take the union of possibilities. R(\"{a,b,c}\") = {\"a\",\"b\",\"c\"} R(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once) When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. R(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"} R(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"} Formally, the three rules for our grammar: For every lowercase letter x, we have R(x) = {x}. For expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ... For expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product. Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents. Example 1: Input: expression = \"{a,b}{c,{d,e}}\" Output: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"] Example 2: Input: expression = \"{{a,z},a{b,c},{ab,z}}\" Output: [\"a\",\"ab\",\"ac\",\"z\"] Explanation: Each distinct word is written only once in the final answer. Constraints: 1 <= expression.length <= 60 expression[i] consists of '{', '}', ','or lowercase English letters. The given expression represents a set of words based on the grammar given in the description.",
        "title": "Brace Expansion II",
        "questionId": 780
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "You are given a string s, an integer k, a letter letter, and an integer repetition. Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. Example 1: Input: s = \"leet\", k = 3, letter = \"e\", repetition = 1 Output: \"eet\" Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time: - \"lee\" (from \"leet\") - \"let\" (from \"leet\") - \"let\" (from \"leet\") - \"eet\" (from \"leet\") The lexicographically smallest subsequence among them is \"eet\". Example 2: Input: s = \"leetcode\", k = 4, letter = \"e\", repetition = 2 Output: \"ecde\" Explanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times. Example 3: Input: s = \"bb\", k = 2, letter = \"b\", repetition = 2 Output: \"bb\" Explanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times. Constraints: 1 <= repetition <= k <= s.length <= 5 * 104 s consists of lowercase English letters. letter is a lowercase English letter, and appears in s at least repetition times.",
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "questionId": 1426
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations. The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box. Your task is to move the box 'B' to the target position 'T' under the following rules: The character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell). The character '.' represents the floor which means a free cell to walk. The character '#' represents the wall which means an obstacle (impossible to walk there). There is only one box 'B' and one target cell 'T' in the grid. The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push. The player cannot walk through the box. Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1. Example 1: Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"], [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"], [\"#\",\".\",\".\",\"B\",\".\",\"#\"], [\"#\",\".\",\"#\",\"#\",\".\",\"#\"], [\"#\",\".\",\".\",\".\",\"S\",\"#\"], [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]] Output: 3 Explanation: We return only the number of times the box is pushed. Example 2: Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"], [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"], [\"#\",\".\",\".\",\"B\",\".\",\"#\"], [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"], [\"#\",\".\",\".\",\".\",\"S\",\"#\"], [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]] Output: -1 Example 3: Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"], [\"#\",\"T\",\".\",\".\",\"#\",\"#\"], [\"#\",\".\",\"#\",\"B\",\".\",\"#\"], [\"#\",\".\",\".\",\".\",\".\",\"#\"], [\"#\",\".\",\".\",\".\",\"S\",\"#\"], [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]] Output: 5 Explanation: push the box down, left, left, up and up. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 20 grid contains only characters '.', '#', 'S', 'T', or 'B'. There is only one character 'S', 'B', and 'T' in the grid.",
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "questionId": 894
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -109 <= nums1[i], nums2[j] <= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time?",
        "title": "Merge Sorted Array",
        "questionId": 77
    },
    {
        "class": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1. Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls. Example 1: Input: lowLimit = 1, highLimit = 10 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 2 1 1 1 1 1 1 1 1 0 0 ... Box 1 has the most number of balls with 2 balls. Example 2: Input: lowLimit = 5, highLimit = 15 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 1 1 1 1 2 2 1 1 1 0 0 ... Boxes 5 and 6 have the most number of balls with 2 balls in each. Example 3: Input: lowLimit = 19, highLimit = 28 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 12 ... Ball Count: 0 1 1 1 1 1 1 1 1 2 0 0 ... Box 10 has the most number of balls with 2 balls. Constraints: 1 <= lowLimit <= highLimit <= 105",
        "title": "Maximum Number of Balls in a Box",
        "questionId": 1213
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. Example 1: Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Example 2: Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 25 board[i][j] is 0 or 1. Follow up: Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",
        "title": "Game of Life",
        "questionId": 205
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods: 1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2). 2. getValue(int row, int col) Returns the current value of the coordinate (row,col) from the rectangle. Example 1: Input [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] Output [null,1,null,5,5,null,10,5] Explanation SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // The initial rectangle (4x3) looks like: // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.getValue(0, 2); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 5 5 5 subrectangleQueries.getValue(0, 2); // return 5 subrectangleQueries.getValue(3, 1); // return 5 subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 10 10 10 subrectangleQueries.getValue(3, 1); // return 10 subrectangleQueries.getValue(0, 2); // return 5 Example 2: Input [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"] [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] Output [null,1,null,100,100,null,20] Explanation SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]); subrectangleQueries.getValue(0, 0); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100); subrectangleQueries.getValue(0, 0); // return 100 subrectangleQueries.getValue(2, 2); // return 100 subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20); subrectangleQueries.getValue(2, 2); // return 20 Constraints: There will be at most 500 operations considering both methods: updateSubrectangle and getValue. 1 <= rows, cols <= 100 rows == rectangle.length cols == rectangle[i].length 0 <= row1 <= row2 < rows 0 <= col1 <= col2 < cols 1 <= newValue, rectangle[i][j] <= 10^9 0 <= row < rows 0 <= col < cols",
        "title": "Subrectangle Queries",
        "questionId": 1032
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix. To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score. Return the maximum number of points you can achieve. abs(x) is defined as: x for x >= 0. -x for x < 0. Example 1: Input: points = [[1,2,3],[1,5,1],[3,1,1]] Output: 9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. Example 2: Input: points = [[1,5],[2,3],[4,2]] Output: 11 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11. Constraints: m == points.length n == points[r].length 1 <= m, n <= 105 1 <= m * n <= 105 0 <= points[r][c] <= 105",
        "title": "Maximum Number of Points with Cost",
        "questionId": 1359
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i: If nums[i] is positive, move nums[i] steps forward, and If nums[i] is negative, move nums[i] steps backward. Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element. A cycle in the array consists of a sequence of indices seq of length k where: Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ... Every nums[seq[j]] is either all positive or all negative. k > 1 Return true if there is a cycle in nums, or false otherwise. Example 1: Input: nums = [2,-1,1,2,2] Output: true Explanation: There is a cycle from index 0 -> 2 -> 3 -> 0 -> ... The cycle's length is 3. Example 2: Input: nums = [-1,2] Output: false Explanation: The sequence from index 1 -> 1 -> 1 -> ... is not a cycle because the sequence's length is 1. By definition the sequence's length must be strictly greater than 1 to be a cycle. Example 3: Input: nums = [-2,1,-1,-2,-2] Output: false Explanation: The sequence from index 1 -> 2 -> 1 -> ... is not a cycle because nums[1] is positive, but nums[2] is negative. Every nums[seq[j]] must be either all positive or all negative. Constraints: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000 nums[i] != 0 Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?",
        "title": "Circular Array Loop",
        "questionId": 322
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order. Example 1: Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output: [[0,1],[2,3,4,5]] Explanation: The figure above describes the graph. The following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output. The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output. Example 2: Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output: [[],[0,1,2,3]] Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical. Constraints: 2 <= n <= 100 1 <= edges.length <= min(200, n * (n - 1) / 2) edges[i].length == 3 0 <= ai < bi < n 1 <= weighti <= 1000 All pairs (ai, bi) are distinct.",
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "questionId": 1052
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'. Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal). A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below: Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal. Example 1: Input: board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\" Output: true Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'. The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles. Example 2: Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\" Output: false Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint. Constraints: board.length == board[r].length == 8 0 <= rMove, cMove < 8 board[rMove][cMove] == '.' color is either 'B' or 'W'.",
        "title": "Check if Move is Legal",
        "questionId": 1365
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.). The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer. For example, if s = \"acb\", we concatenate each letter's letter value, resulting in \"021\". After converting it, we get 21. You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters 'a' through 'j' inclusive. Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise. Example 1: Input: firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\" Output: true Explanation: The numerical value of firstWord is \"acb\" -> \"021\" -> 21. The numerical value of secondWord is \"cba\" -> \"210\" -> 210. The numerical value of targetWord is \"cdb\" -> \"231\" -> 231. We return true because 21 + 210 == 231. Example 2: Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\" Output: false Explanation: The numerical value of firstWord is \"aaa\" -> \"000\" -> 0. The numerical value of secondWord is \"a\" -> \"0\" -> 0. The numerical value of targetWord is \"aab\" -> \"001\" -> 1. We return false because 0 + 0 != 1. Example 3: Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\" Output: true Explanation: The numerical value of firstWord is \"aaa\" -> \"000\" -> 0. The numerical value of secondWord is \"a\" -> \"0\" -> 0. The numerical value of targetWord is \"aaaa\" -> \"0000\" -> 0. We return true because 0 + 0 == 0. Constraints: 1 <= firstWord.length, secondWord.length, targetWord.length <= 8 firstWord, secondWord, and targetWord consist of lowercase English letters from 'a' to 'j' inclusive.",
        "title": "Check if Word Equals Summation of Two Words",
        "questionId": 1318
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 0 <= nums.length <= 3 * 104 -100 <= nums[i] <= 100 nums is sorted in non-decreasing order.",
        "title": "Remove Duplicates from Sorted Array",
        "questionId": 20
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365. Train tickets are sold in three different ways: a 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total, you spent $17 and covered all the days of your travel. Constraints: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000",
        "title": "Minimum Cost For Tickets",
        "questionId": 712
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb. The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range. You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges. Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb. Example 1: Input: bombs = [[2,1,3],[6,1,4]] Output: 2 Explanation: The above figure shows the positions and ranges of the 2 bombs. If we detonate the left bomb, the right bomb will not be affected. But if we detonate the right bomb, both bombs will be detonated. So the maximum bombs that can be detonated is max(1, 2) = 2. Example 2: Input: bombs = [[1,1,5],[10,10,5]] Output: 1 Explanation: Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1. Example 3: Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]] Output: 5 Explanation: The best bomb to detonate is bomb 0 because: - Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0. - Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2. - Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3. Thus all 5 bombs are detonated. Constraints: 1 <= bombs.length <= 100 bombs[i].length == 3 1 <= xi, yi, ri <= 105",
        "title": "Detonate the Maximum Bombs",
        "questionId": 1464
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]. You play a game with the following rules: You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1. You must eat at least one candy per day until you have eaten all the candies. Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return the constructed array answer. Example 1: Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] Output: [true,false,true] Explanation: 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2. 2- You can eat at most 4 candies each day. If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1. On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2. 3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13. Example 2: Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] Output: [false,true,true,false,false] Constraints: 1 <= candiesCount.length <= 105 1 <= candiesCount[i] <= 105 1 <= queries.length <= 105 queries[i].length == 3 0 <= favoriteTypei < candiesCount.length 0 <= favoriteDayi <= 109 1 <= dailyCapi <= 109",
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
        "questionId": 1225
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries. Example 1: Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] Output: [3,3,1,4] Explanation: The queries are processed as follows: - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3. - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3. - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1. - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4. Example 2: Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] Output: [2,-1,4,6] Explanation: The queries are processed as follows: - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2. - Query = 19: None of the intervals contain 19. The answer is -1. - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4. - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6. Constraints: 1 <= intervals.length <= 105 1 <= queries.length <= 105 intervals[i].length == 2 1 <= lefti <= righti <= 107 1 <= queries[j] <= 107",
        "title": "Minimum Interval to Include Each Query",
        "questionId": 1297
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "content": "A car travels from a starting position to a destination which is target miles east of the starting position. There are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. Return the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived. Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling. Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can not reach the target (or even the first gas station). Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation: We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel. We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas. We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2. Constraints: 1 <= target, startFuel <= 109 0 <= stations.length <= 500 0 <= positioni <= positioni+1 < target 1 <= fueli < 109",
        "title": "Minimum Number of Refueling Stops",
        "questionId": 616
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ],
        "content": "In the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door. Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword. Initially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]: You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i]. If the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling. Example 1: Input: ring = \"godding\", key = \"gd\" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character. For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\". Also, we need 1 more step for spelling. So the final output is 4. Example 2: Input: ring = \"godding\", key = \"godding\" Output: 13 Constraints: 1 <= ring.length, key.length <= 100 ring and key consist of only lower case English letters. It is guaranteed that key could always be spelled by rotating ring.",
        "title": "Freedom Trail",
        "questionId": 362
    },
    {
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List<Node> neighbors; } Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. Constraints: The number of nodes in the graph is in the range [0, 100]. 1 <= Node.val <= 100 Node.val is unique for each node. There are no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node.",
        "title": "Clone Graph",
        "questionId": 117
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 0 <= nums.length <= 100 0 <= nums[i] <= 50 0 <= val <= 100",
        "title": "Remove Element",
        "questionId": 21
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1. Example 1: Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. Example 2: Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3: Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 Output: 12 Explanation: We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. Constraints: bloomDay.length == n 1 <= n <= 105 1 <= bloomDay[i] <= 109 1 <= m <= 106 1 <= k <= n",
        "title": "Minimum Number of Days to Make m Bouquets",
        "questionId": 1048
    },
    {
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can: Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j]. Replace the leaf node in trees[i] with trees[j]. Remove trees[j] from trees. Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: Every node in the node's left subtree has a value strictly less than the node's value. Every node in the node's right subtree has a value strictly greater than the node's value. A leaf is a node that has no children. Example 1: Input: trees = [[2,1],[3,2,5],[5,4]] Output: [3,2,5,1,null,4] Explanation: In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root. Example 2: Input: trees = [[5,3,8],[3,2,6]] Output: [] Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null. Example 3: Input: trees = [[5,4],[3]] Output: [] Explanation: It is impossible to perform any operations. Constraints: n == trees.length 1 <= n <= 5 * 104 The number of nodes in each tree is in the range [1, 3]. Each node in the input may have children but no grandchildren. No two roots of trees have the same value. All the trees in the input are valid BSTs. 1 <= TreeNode.val <= 5 * 104.",
        "title": "Merge BSTs to Create Single BST",
        "questionId": 1356
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if: It is directly connected to the top of the grid, or At least one other brick in its four adjacent cells is stable. You are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks). Return an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied. Note that an erasure may refer to a location with no brick, and if it does, no bricks drop. Example 1: Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]] Output: [2] Explanation: Starting with the grid: [[1,0,0,0], [1,1,1,0]] We erase the underlined brick at (1,0), resulting in the grid: [[1,0,0,0], [0,1,1,0]] The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is: [[1,0,0,0], [0,0,0,0]] Hence the result is [2]. Example 2: Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]] Output: [0,0] Explanation: Starting with the grid: [[1,0,0,0], [1,1,0,0]] We erase the underlined brick at (1,1), resulting in the grid: [[1,0,0,0], [1,0,0,0]] All remaining bricks are still stable, so no bricks fall. The grid remains the same: [[1,0,0,0], [1,0,0,0]] Next, we erase the underlined brick at (1,0), resulting in the grid: [[1,0,0,0], [0,0,0,0]] Once again, all remaining bricks are still stable, so no bricks fall. Hence the result is [0,0]. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 200 grid[i][j] is 0 or 1. 1 <= hits.length <= 4 * 104 hits[i].length == 2 0 <= xi <= m - 1 0 <= yi <= n - 1 All (xi, yi) are unique.",
        "title": "Bricks Falling When Hit",
        "questionId": 552
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only. For each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords. The conversion operation is described in the following two steps: Append any lowercase letter that is not present in the string to its end. For example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\". Rearrange the letters of the new string in any arbitrary order. For example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself. Return the number of strings in targetWords that can be obtained by performing the operations on any string of startWords. Note that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process. Example 1: Input: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"] Output: 2 Explanation: - In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\". - There is no string in startWords that can be used to obtain targetWords[1] = \"act\". Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it. - In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself. Example 2: Input: startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"] Output: 1 Explanation: - In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\". - There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\". Constraints: 1 <= startWords.length, targetWords.length <= 5 * 104 1 <= startWords[i].length, targetWords[j].length <= 26 Each string of startWords and targetWords consists of lowercase English letters only. No letter occurs more than once in any string of startWords or targetWords.",
        "title": "Count Words Obtained After Adding a Letter",
        "questionId": 1495
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix. Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another. The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot. Example 1: Input: grid = [[2,5,4],[1,5,1]] Output: 4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 0 + 4 + 0 = 4 points. Example 2: Input: grid = [[3,3,1],[8,5,2]] Output: 4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 3 + 1 + 0 = 4 points. Example 3: Input: grid = [[1,3,1,15],[1,3,3,1]] Output: 7 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points. Constraints: grid.length == 2 n == grid[r].length 1 <= n <= 5 * 104 1 <= grid[r][c] <= 105",
        "title": "Grid Game",
        "questionId": 1416
    },
    {
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1. void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated. To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, 3, null, -1, 3, 4] Explanation // cnt(x) = the use counter for key x // cache=[] will show the last used order for tiebreakers (leftmost element is most recent) LFUCache lfu = new LFUCache(2); lfu.put(1, 1); // cache=[1,_], cnt(1)=1 lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1 lfu.get(1); // return 1 // cache=[1,2], cnt(2)=1, cnt(1)=2 lfu.put(3, 3); // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2. // cache=[3,1], cnt(3)=1, cnt(1)=2 lfu.get(2); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,1], cnt(3)=2, cnt(1)=2 lfu.put(4, 4); // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1. // cache=[4,3], cnt(4)=1, cnt(3)=2 lfu.get(1); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,4], cnt(4)=1, cnt(3)=3 lfu.get(4); // return 4 // cache=[4,3], cnt(4)=2, cnt(3)=3 Constraints: 0 <= capacity <= 104 0 <= key <= 105 0 <= value <= 109 At most 2 * 105 calls will be made to get and put.",
        "title": "LFU Cache",
        "questionId": 325
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row. You start on square 1 of the board. In each move, starting from square curr, do the following: Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)]. This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board. If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next. The game ends when you reach the square n2. A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder. Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder. For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4. Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1. Example 1: Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] Output: 4 Explanation: In the beginning, you start at square 1 (at row 5, column 0). You decide to move to square 2 and must take the ladder to square 15. You then decide to move to square 17 and must take the snake to square 13. You then decide to move to square 14 and must take the ladder to square 35. You then decide to move to square 36, ending the game. This is the lowest possible number of moves to reach the last square, so return 4. Example 2: Input: board = [[-1,-1],[-1,3]] Output: 1 Constraints: n == board.length == board[i].length 2 <= n <= 20 grid[i][j] is either -1 or in the range [1, n2]. The squares labeled 1 and n2 do not have any ladders or snakes.",
        "title": "Snakes and Ladders",
        "questionId": 649
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has. You can work on the projects following these two rules: Every week, you will finish exactly one milestone of one project. You must work every week. You cannot work on two milestones from the same project for two consecutive weeks. Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints. Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above. Example 1: Input: milestones = [1,2,3] Output: 6 Explanation: One possible scenario is: \u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 2. - During the 3rd week, you will work on a milestone of project 1. - During the 4th week, you will work on a milestone of project 2. - During the 5th week, you will work on a milestone of project 1. - During the 6th week, you will work on a milestone of project 2. The total number of weeks is 6. Example 2: Input: milestones = [5,2,1] Output: 7 Explanation: One possible scenario is: - During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 1. - During the 3rd week, you will work on a milestone of project 0. - During the 4th week, you will work on a milestone of project 1. - During the 5th week, you will work on a milestone of project 0. - During the 6th week, you will work on a milestone of project 2. - During the 7th week, you will work on a milestone of project 0. The total number of weeks is 7. Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules. Thus, one milestone in project 0 will remain unfinished. Constraints: n == milestones.length 1 <= n <= 105 1 <= milestones[i] <= 109",
        "title": "Maximum Number of Weeks for Which You Can Work",
        "questionId": 1368
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system. For example, [\"one\", \"two\", \"three\"] represents the path \"/one/two/three\". Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders. For example, folders \"/a\" and \"/b\" in the file structure below are identical. They (as well as their subfolders) should all be marked: /a /a/x /a/x/y /a/z /b /b/x /b/x/y /b/z However, if the file structure also included the path \"/b/w\", then the folders \"/a\" and \"/b\" would not be identical. Note that \"/a/x\" and \"/b/x\" would still be considered identical even with the added folder. Once all the identical folders and their subfolders have been marked, the file system will delete all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted. Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order. Example 1: Input: paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]] Output: [[\"d\"],[\"d\",\"a\"]] Explanation: The file structure is as shown. Folders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"b\". Example 2: Input: paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]] Output: [[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]] Explanation: The file structure is as shown. Folders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\". Note that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand. Example 3: Input: paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]] Output: [[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]] Explanation: All folders are unique in the file system. Note that the returned array can be in a different order as the order does not matter. Constraints: 1 <= paths.length <= 2 * 104 1 <= paths[i].length <= 500 1 <= paths[i][j].length <= 10 1 <= sum(paths[i][j].length) <= 2 * 105 path[i][j] consists of lowercase English letters. No two paths lead to the same folder. For any folder not at the root level, its parent folder will also be in the input.",
        "title": "Delete Duplicate Folders in System",
        "questionId": 1364
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class: void checkIn(int id, string stationName, int t) A customer with a card ID equal to id, checks in at the station stationName at time t. A customer can only be checked into one place at a time. void checkOut(int id, string stationName, int t) A customer with a card ID equal to id, checks out from the station stationName at time t. double getAverageTime(string startStation, string endStation) Returns the average time it takes to travel from startStation to endStation. The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation. The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. Example 1: Input [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]] Output [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, \"Leyton\", 3); undergroundSystem.checkIn(32, \"Paradise\", 8); undergroundSystem.checkIn(27, \"Leyton\", 10); undergroundSystem.checkOut(45, \"Waterloo\", 15); // Customer 45 \"Leyton\" -> \"Waterloo\" in 15-3 = 12 undergroundSystem.checkOut(27, \"Waterloo\", 20); // Customer 27 \"Leyton\" -> \"Waterloo\" in 20-10 = 10 undergroundSystem.checkOut(32, \"Cambridge\", 22); // Customer 32 \"Paradise\" -> \"Cambridge\" in 22-8 = 14 undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. One trip \"Paradise\" -> \"Cambridge\", (14) / 1 = 14 undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000. Two trips \"Leyton\" -> \"Waterloo\", (10 + 12) / 2 = 11 undergroundSystem.checkIn(10, \"Leyton\", 24); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000 undergroundSystem.checkOut(10, \"Waterloo\", 38); // Customer 10 \"Leyton\" -> \"Waterloo\" in 38-24 = 14 undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 12.00000. Three trips \"Leyton\" -> \"Waterloo\", (10 + 12 + 14) / 3 = 12 Example 2: Input [\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"] [[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]] Output [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(10, \"Leyton\", 3); undergroundSystem.checkOut(10, \"Paradise\", 8); // Customer 10 \"Leyton\" -> \"Paradise\" in 8-3 = 5 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.00000, (5) / 1 = 5 undergroundSystem.checkIn(5, \"Leyton\", 10); undergroundSystem.checkOut(5, \"Paradise\", 16); // Customer 5 \"Leyton\" -> \"Paradise\" in 16-10 = 6 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.50000, (5 + 6) / 2 = 5.5 undergroundSystem.checkIn(2, \"Leyton\", 21); undergroundSystem.checkOut(2, \"Paradise\", 30); // Customer 2 \"Leyton\" -> \"Paradise\" in 30-21 = 9 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667 Constraints: 1 <= id, t <= 106 1 <= stationName.length, startStation.length, endStation.length <= 10 All strings consist of uppercase and lowercase English letters and digits. There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime. Answers within 10-5 of the actual value will be accepted.",
        "title": "Design Underground System",
        "questionId": 982
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies.\r \r Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. Each shop carries at most one copy of a movie moviei.\r \r The system should support the following functions:\r \r \r Search: Finds the cheapest 5 shops that have an unrented copy of a given movie. The shops should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopi should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned.\r Rent: Rents an unrented copy of a given movie from a given shop.\r Drop: Drops off a previously rented copy of a given movie at a given shop.\r Report: Returns the cheapest 5 rented movies (possibly of the same movie ID) as a 2D list res where res[j] = [shopj, moviej] describes that the jth cheapest rented movie moviej was rented from the shop shopj. The movies in res should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopj should appear first, and if there is still tie, the one with the smaller moviej should appear first. If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned.\r \r \r Implement the MovieRentingSystem class:\r \r \r MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem object with n shops and the movies in entries.\r List<Integer> search(int movie) Returns a list of shops that have an unrented copy of the given movie as described above.\r void rent(int shop, int movie) Rents the given movie from the given shop.\r void drop(int shop, int movie) Drops off a previously rented movie at the given shop.\r List<List<Integer>> report() Returns a list of cheapest rented movies as described above.\r \r \r Note: The test cases will be generated such that rent will only be called if the shop has an unrented copy of the movie, and drop will only be called if the shop had previously rented out the movie.\r \r \r Example 1:\r \r \r Input\r [\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\r [[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\r Output\r [null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\r \r Explanation\r MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\r movieRentingSystem.search(1); // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.\r movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].\r movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].\r movieRentingSystem.report(); // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.\r movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].\r movieRentingSystem.search(2); // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.\r \r \r \r Constraints:\r \r \r 1 <= n <= 3 * 105\r 1 <= entries.length <= 105\r 0 <= shopi < n\r 1 <= moviei, pricei <= 104\r Each shop carries at most one copy of a movie moviei.\r At most 105 calls in total will be made to search, rent, drop and report.",
        "title": "Design Movie Rental System",
        "questionId": 1329
    }
]