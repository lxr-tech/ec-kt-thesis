[
    {
        "content": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example 1: Input: n = 13 Output: 6 Example 2: Input: n = 0 Output: 0 Constraints: 0 <= n <= 109",
        "title": "Number of Digit One",
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of integers nums, sort the array in ascending order. Example 1: Input: nums = [5,2,3,1] Output: [1,2,3,5] Example 2: Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Constraints: 1 <= nums.length <= 5 * 104 -5 * 104 <= nums[i] <= 5 * 104",
        "title": "Sort an Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order. Example 1: Input: s = \"owoztneoer\" Output: \"012\" Example 2: Input: s = \"fviefuro\" Output: \"45\" Constraints: 1 <= s.length <= 105 s[i] is one of the characters [\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"]. s is guaranteed to be valid.",
        "title": "Reconstruct Original Digits from English",
        "class": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. Example 1: Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Example 2: Input: arr = [1,1] Output: 1 Constraints: 1 <= arr.length <= 104 0 <= arr[i] <= 105",
        "title": "Element Appearing More Than 25% In Sorted Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, return the leftmost value in the last row of the tree. Example 1: Input: root = [2,1,3] Output: 1 Example 2: Input: root = [1,2,3,4,null,5,6,null,null,7] Output: 7 Constraints: The number of nodes in the tree is in the range [1, 104]. -231 <= Node.val <= 231 - 1",
        "title": "Find Bottom Left Tree Value",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Example 2: Input: nums = [0] Output: [[],[0]] Constraints: 1 <= nums.length <= 10 -10 <= nums[i] <= 10",
        "title": "Subsets II",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Example 1: Input: root = [1,2,3,null,5] Output: [\"1->2->5\",\"1->3\"] Example 2: Input: root = [1] Output: [\"1\"] Constraints: The number of nodes in the tree is in the range [1, 100]. -100 <= Node.val <= 100",
        "title": "Binary Tree Paths",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images. Example 1: Input: nums = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,4,2,7,5,3,8,6,9] Example 2: Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] Constraints: 1 <= nums.length <= 105 1 <= nums[i].length <= 105 1 <= sum(nums[i].length) <= 105 1 <= nums[i][j] <= 105",
        "title": "Diagonal Traverse II",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given an integer n, return any array containing n unique integers such that they add up to 0. Example 1: Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: Input: n = 3 Output: [-1,0,1] Example 3: Input: n = 1 Output: [0] Constraints: 1 <= n <= 1000",
        "title": "Find N Unique Integers Sum up to Zero",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Convert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 <= num <= 231 - 1",
        "title": "Integer to English Words",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Example 1: Input: nums = [10,2] Output: \"210\" Example 2: Input: nums = [3,30,34,5,9] Output: \"9534330\" Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 109",
        "title": "Largest Number",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i]. Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. Example 1: Input: barcodes = [1,1,1,2,2,2] Output: [2,1,2,1,2,1] Example 2: Input: barcodes = [1,1,1,1,2,2,3,3] Output: [1,3,1,3,1,2,1,2] Constraints: 1 <= barcodes.length <= 10000 1 <= barcodes[i] <= 10000",
        "title": "Distant Barcodes",
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "Given two binary strings a and b, return their sum as a binary string. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Constraints: 1 <= a.length, b.length <= 104 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.",
        "title": "Add Binary",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space. Example 1: Input: nums = [1,2,0] Output: 3 Example 2: Input: nums = [3,4,-1,1] Output: 2 Example 3: Input: nums = [7,8,9,11,12] Output: 1 Constraints: 1 <= nums.length <= 5 * 105 -231 <= nums[i] <= 231 - 1",
        "title": "First Missing Positive",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. Example 1: Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 5000 0 <= nums[i] <= 5000",
        "title": "Sort Array By Parity",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times. Example 1: Input: nums = [3,2,3] Output: [3] Example 2: Input: nums = [1] Output: [1] Example 3: Input: nums = [1,2] Output: [1,2] Constraints: 1 <= nums.length <= 5 * 104 -109 <= nums[i] <= 109 Follow up: Could you solve the problem in linear time and in O(1) space?",
        "title": "Majority Element II",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, return the postorder traversal of its nodes' values. Example 1: Input: root = [1,null,2,3] Output: [3,2,1] Example 2: Input: root = [] Output: [] Example 3: Input: root = [1] Output: [1] Constraints: The number of the nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively?",
        "title": "Binary Tree Postorder Traversal",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2: Input: x = 2.10000, n = 3 Output: 9.26100 Example 3: Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints: -100.0 < x < 100.0 -231 <= n <= 231-1 -104 <= xn <= 104",
        "title": "Pow(x, n)",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2: Input: root = [1,null,3] Output: [1,3] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100",
        "title": "Binary Tree Right Side View",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. Example 2: Input: s = \"a\" Output: 0 Example 3: Input: s = \"ab\" Output: 1 Constraints: 1 <= s.length <= 2000 s consists of lowercase English letters only.",
        "title": "Palindrome Partitioning II",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. Example 1: Input: date = \"2019-01-09\" Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2: Input: date = \"2019-02-10\" Output: 41 Constraints: date.length == 10 date[4] == date[7] == '-', and all other date[i]'s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.",
        "title": "Day of the Year",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order. The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence. Example 1: Input: nums = [4,6,7,7] Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] Example 2: Input: nums = [4,4,3,2,1] Output: [[4,4]] Constraints: 1 <= nums.length <= 15 -100 <= nums[i] <= 100",
        "title": "Increasing Subsequences",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109 0 <= k <= 105",
        "title": "Contains Duplicate II",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. Example 1: Input: n = 1 Output: true Explanation: 20 = 1 Example 2: Input: n = 16 Output: true Explanation: 24 = 16 Example 3: Input: n = 3 Output: false Constraints: -231 <= n <= 231 - 1 Follow up: Could you solve it without loops/recursion?",
        "title": "Power of Two",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi]. Return the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0. Example 1: Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4 Example 2: Input: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2 Constraints: 1 <= points.length <= 500 points[i].length == 2 0 <= xi, yi <= 4 * 104 All the given points are unique.",
        "title": "Minimum Area Rectangle",
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] Constraints: 1 <= temperatures.length <= 105 30 <= temperatures[i] <= 100",
        "title": "Daily Temperatures",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false Constraints: The number of nodes in the tree is in the range [1, 104]. -104 <= Node.val <= 104 root is guaranteed to be a valid binary search tree. -105 <= k <= 105",
        "title": "Two Sum IV - Input is a BST",
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2.00000 Explanation: The five points are shown in the above figure. The red triangle is the largest. Example 2: Input: points = [[1,0],[0,0],[0,1]] Output: 0.50000 Constraints: 3 <= points.length <= 50 -50 <= xi, yi <= 50 All the given points are unique.",
        "title": "Largest Triangle Area",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, \"Aa\" is not considered a palindrome here. Example 1: Input: s = \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. Example 2: Input: s = \"a\" Output: 1 Example 3: Input: s = \"bb\" Output: 2 Constraints: 1 <= s.length <= 2000 s consists of lowercase and/or uppercase English letters only.",
        "title": "Longest Palindrome",
        "class": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the kth permutation sequence. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Example 3: Input: n = 3, k = 1 Output: \"123\" Constraints: 1 <= n <= 9 1 <= k <= n!",
        "title": "Permutation Sequence",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining. Example 1: Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output: 4 Explanation: After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4. Example 2: Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] Output: 10 Constraints: m == heightMap.length n == heightMap[i].length 1 <= m, n <= 200 0 <= heightMap[i][j] <= 2 * 104",
        "title": "Trapping Rain Water II",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's. Example 1: Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2: Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3 Output: 10 Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Constraints: 1 <= nums.length <= 105 nums[i] is either 0 or 1. 0 <= k <= nums.length",
        "title": "Max Consecutive Ones III",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2: Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] Constraints: 1 <= arr.length <= 104 0 <= arr[i] <= 9",
        "title": "Duplicate Zeros",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2: Input: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] Constraints: The number of nodes in the tree is in the range [1, 104]. -231 <= Node.val <= 231 - 1",
        "title": "Average of Levels in Binary Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square. Example 1: Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4 Output: 2 Explanation: The maximum side length of square with sum less than 4 is 2 as shown. Example 2: Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1 Output: 0 Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 300 0 <= mat[i][j] <= 104 0 <= threshold <= 105",
        "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two integers a and b, return any string s such that: s has length a + b and contains exactly a 'a' letters, and exactly b 'b' letters, The substring 'aaa' does not occur in s, and The substring 'bbb' does not occur in s. Example 1: Input: a = 1, b = 2 Output: \"abb\" Explanation: \"abb\", \"bab\" and \"bba\" are all correct answers. Example 2: Input: a = 4, b = 1 Output: \"aabaa\" Constraints: 0 <= a, b <= 100 It is guaranteed such an s exists for the given a and b.",
        "title": "String Without AAA or BBB",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist. An alphanumeric string is a string consisting of lowercase English letters and digits. Example 1: Input: s = \"dfa12321afd\" Output: 2 Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2. Example 2: Input: s = \"abc1111\" Output: -1 Explanation: The digits that appear in s are [1]. There is no second largest digit. Constraints: 1 <= s.length <= 500 s consists of only lowercase English letters and/or digits.",
        "title": "Second Largest Digit in a String",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1 Example 2: Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 300 grid[i][j] is '0' or '1'.",
        "title": "Number of Islands",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 Example 2: Input: n = 1 Output: true Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Example 3: Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7. Constraints: -231 <= n <= 231 - 1",
        "title": "Ugly Number",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. Example 1: Input: x = 4 Output: 2 Example 2: Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints: 0 <= x <= 231 - 1",
        "title": "Sqrt(x)",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: Input: nums = [1] Output: 1 Example 3: Input: nums = [5,4,-1,7,8] Output: 23 Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
        "title": "Maximum Subarray",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array of unique positive integers nums. Consider the following graph: There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. Example 1: Input: nums = [4,6,15,35] Output: 4 Example 2: Input: nums = [20,50,9,63] Output: 2 Example 3: Input: nums = [2,3,6,7,4,12,21,39] Output: 8 Constraints: 1 <= nums.length <= 2 * 104 1 <= nums[i] <= 105 All the values of nums are unique.",
        "title": "Largest Component Size by Common Factor",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter. Example 1: Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[3,3],[2,4],[4,2]] Example 2: Input: points = [[1,2],[2,2],[4,2]] Output: [[4,2],[2,2],[1,2]] Constraints: 1 <= points.length <= 3000 points[i].length == 2 0 <= xi, yi <= 100 All the given points are unique.",
        "title": "Erect the Fence",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs. Example 1: Input: numerator = 1, denominator = 2 Output: \"0.5\" Example 2: Input: numerator = 2, denominator = 1 Output: \"2\" Example 3: Input: numerator = 4, denominator = 333 Output: \"0.(012)\" Constraints: -231 <= numerator, denominator <= 231 - 1 denominator != 0",
        "title": "Fraction to Recurring Decimal",
        "class": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. Example 1: Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above Example 2: Input: n = 1 Output: [[\"Q\"]] Constraints: 1 <= n <= 9",
        "title": "N-Queens",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false. Example 1: Input: arr = [3,5,1] Output: true Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. Example 2: Input: arr = [1,2,4] Output: false Explanation: There is no way to reorder the elements to obtain an arithmetic progression. Constraints: 2 <= arr.length <= 1000 -106 <= arr[i] <= 106",
        "title": "Can Make Arithmetic Progression From Sequence",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j]. Example 1: Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1 Example 2: Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]] Output: 3 Constraints: 1 <= dominoes.length <= 4 * 104 dominoes[i].length == 2 1 <= dominoes[i][j] <= 9",
        "title": "Number of Equivalent Domino Pairs",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string s. In one step you can insert any character at any index of the string. Return the minimum number of steps to make s palindrome. A Palindrome String is one that reads the same backward as well as forward. Example 1: Input: s = \"zzazz\" Output: 0 Explanation: The string \"zzazz\" is already palindrome we don't need any insertions. Example 2: Input: s = \"mbadm\" Output: 2 Explanation: String can be \"mbdadbm\" or \"mdbabdm\". Example 3: Input: s = \"leetcode\" Output: 5 Explanation: Inserting 5 characters the string becomes \"leetcodocteel\". Constraints: 1 <= s.length <= 500 s consists of lowercase English letters.",
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array nums of integers, return how many of them contain an even number of digits. Example 1: Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits. Example 2: Input: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. Constraints: 1 <= nums.length <= 500 1 <= nums[i] <= 105",
        "title": "Find Numbers with Even Number of Digits",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order. Example 1: Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2: Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] Constraints: 1 <= arr1.length, arr2.length <= 1000 0 <= arr1[i], arr2[i] <= 1000 All the elements of arr2 are distinct. Each arr2[i] is in arr1.",
        "title": "Relative Sort Array",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2]. Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix. Example 1: Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]] Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]] Example 2: Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]] Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]] Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 100 1 <= mat[i][j] <= 100",
        "title": "Sort the Matrix Diagonally",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.\r \r After doing so, return the head of the final linked list. You may return any such answer.\r (Note that in the examples below, all sequences are serializations of ListNode objects.) Example 1: Input: head = [1,2,-3,3,1] Output: [3,1] Note: The answer [1,2,1] would also be accepted. Example 2: Input: head = [1,2,3,-3,4] Output: [1,2,4] Example 3: Input: head = [1,2,3,-3,-2] Output: [1] Constraints: The given linked list will contain between 1 and 1000 nodes. Each node in the linked list has -1000 <= node.val <= 1000.",
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Take their own seat if it is still available, and Pick other seats randomly when they find their seat occupied Return the probability that the nth person gets his own seat. Example 1: Input: n = 1 Output: 1.00000 Explanation: The first person can only get the first seat. Example 2: Input: n = 2 Output: 0.50000 Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat). Constraints: 1 <= n <= 105",
        "title": "Airplane Seat Assignment Probability",
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example 1: Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 Output: true Example 2: Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20 Output: false Constraints: m == matrix.length n == matrix[i].length 1 <= n, m <= 300 -109 <= matrix[i][j] <= 109 All the integers in each row are sorted in ascending order. All the integers in each column are sorted in ascending order. -109 <= target <= 109",
        "title": "Search a 2D Matrix II",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :\r \r \r p[0] = start\r p[i] and p[i+1] differ by only one bit in their binary representation.\r p[0] and p[2^n -1] must also differ by only one bit in their binary representation.\r \r \r \r Example 1:\r \r \r Input: n = 2, start = 3\r Output: [3,2,0,1]\r Explanation: The binary representation of the permutation is (11,10,00,01). \r All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]\r \r \r Example 2:\r \r \r Input: n = 3, start = 2\r Output: [2,6,7,5,4,0,1,3]\r Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).\r \r \r \r Constraints:\r \r \r 1 <= n <= 16\r 0 <= start < 2 ^ n",
        "title": "Circular Permutation in Binary Representation",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example 1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Example 2: Input: nums = [-1] Output: [0] Example 3: Input: nums = [-1,-1] Output: [0,0] Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104",
        "title": "Count of Smaller Numbers After Self",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There is an integer array perm that is a permutation of the first n positive integers, where n is always odd. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1]. Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique. Example 1: Input: encoded = [3,1] Output: [1,2,3] Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1] Example 2: Input: encoded = [6,5,4,6] Output: [2,4,1,5,3] Constraints: 3 <= n < 105 n is odd. encoded.length == n - 1",
        "title": "Decode XORed Permutation",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists. A substring is a contiguous sequence of characters within a string. Example 1: Input: num = \"52\" Output: \"5\" Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number. Example 2: Input: num = \"4206\" Output: \"\" Explanation: There are no odd numbers in \"4206\". Example 3: Input: num = \"35427\" Output: \"35427\" Explanation: \"35427\" is already an odd number. Constraints: 1 <= num.length <= 105 num only consists of digits and does not contain any leading zeros.",
        "title": "Largest Odd Number in String",
        "class": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf(). Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Example 3: Input: haystack = \"\", needle = \"\" Output: 0 Constraints: 0 <= haystack.length, needle.length <= 5 * 104 haystack and needle consist of only lower-case English characters.",
        "title": "Implement strStr()",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [2,1,3] Output: true Example 2: Input: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Constraints: The number of nodes in the tree is in the range [1, 104]. -231 <= Node.val <= 231 - 1",
        "title": "Validate Binary Search Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. Example 1: Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). Example 2: Input: envelopes = [[1,1],[1,1],[1,1]] Output: 1 Constraints: 1 <= envelopes.length <= 5000 envelopes[i].length == 2 1 <= wi, hi <= 104",
        "title": "Russian Doll Envelopes",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible. The string is called alternating if no two adjacent characters are equal. For example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not. Any two characters may be swapped, even if they are not adjacent. Example 1: Input: s = \"111000\" Output: 1 Explanation: Swap positions 1 and 4: \"111000\" -> \"101010\" The string is now alternating. Example 2: Input: s = \"010\" Output: 0 Explanation: The string is already alternating, no swaps are needed. Example 3: Input: s = \"1110\" Output: -1 Constraints: 1 <= s.length <= 1000 s[i] is either '0' or '1'.",
        "title": "Minimum Number of Swaps to Make the Binary String Alternating",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Constraints: 0 <= word1.length, word2.length <= 500 word1 and word2 consist of lowercase English letters.",
        "title": "Edit Distance",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves). Example 1: Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2: Input: grid = [[0]] Output: 1 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 20 grid[i][j] is either 0 or 1.",
        "title": "Score After Flipping Matrix",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given two strings first and second, consider occurrences in some text of the form \"first second third\", where second comes immediately after first, and third comes immediately after second. Return an array of all the words third for each occurrence of \"first second third\". Example 1: Input: text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" Output: [\"girl\",\"student\"] Example 2: Input: text = \"we will we will rock you\", first = \"we\", second = \"will\" Output: [\"we\",\"rock\"] Constraints: 1 <= text.length <= 1000 text consists of lowercase English letters and spaces. All the words in text a separated by a single space. 1 <= first.length, second.length <= 10 first and second consist of lowercase English letters.",
        "title": "Occurrences After Bigram",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Constraints: 1 <= n <= 105 nums.length == n + 1 1 <= nums[i] <= n All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity?",
        "title": "Find the Duplicate Number",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number. Example 1: Input: nums = [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number. The second 1's next greater number needs to search circularly, which is also 2. Example 2: Input: nums = [1,2,3,4,3] Output: [2,3,4,-1,4] Constraints: 1 <= nums.length <= 104 -109 <= nums[i] <= 109",
        "title": "Next Greater Element II",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Example 1: Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true Example 2: Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false Example 3: Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false Constraints: 1 <= pattern.length <= 300 pattern contains only lower-case English letters. 1 <= s.length <= 3000 s contains only lowercase English letters and spaces ' '. s does not contain any leading or trailing spaces. All the words in s are separated by a single space.",
        "title": "Word Pattern",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return true if the square is white, and false if the square is black. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. Example 1: Input: coordinates = \"a1\" Output: false Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false. Example 2: Input: coordinates = \"h3\" Output: true Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true. Example 3: Input: coordinates = \"c7\" Output: false Constraints: coordinates.length == 2 'a' <= coordinates[0] <= 'h' '1' <= coordinates[1] <= '8'",
        "title": "Determine Color of a Chessboard Square",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A string is good if there are no repeated characters. Given a string s\u200b\u200b\u200b\u200b\u200b, return the number of good substrings of length three in s\u200b\u200b\u200b\u200b\u200b\u200b. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"xyzzaz\" Output: 1 Explanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". The only good substring of length 3 is \"xyz\". Example 2: Input: s = \"aababcabc\" Output: 4 Explanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\". The good substrings are \"abc\", \"bca\", \"cab\", and \"abc\". Constraints: 1 <= s.length <= 100 s\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.",
        "title": "Substrings of Size Three with Distinct Characters",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string. Example 1: Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] Output: true Explanation: word1 represents string \"ab\" + \"c\" -> \"abc\" word2 represents string \"a\" + \"bc\" -> \"abc\" The strings are the same, so return true. Example 2: Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] Output: false Example 3: Input: word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] Output: true Constraints: 1 <= word1.length, word2.length <= 103 1 <= word1[i].length, word2[i].length <= 103 1 <= sum(word1[i].length), sum(word2[i].length) <= 103 word1[i] and word2[i] consist of lowercase letters.",
        "title": "Check If Two String Arrays are Equivalent",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s consisting only of characters 'a' and 'b'\u200b\u200b\u200b\u200b. You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'. Return the minimum number of deletions needed to make s balanced. Example 1: Input: s = \"aababbab\" Output: 2 Explanation: You can either: Delete the characters at 0-indexed positions 2 and 6 (\"aababbab\" -> \"aaabbb\"), or Delete the characters at 0-indexed positions 3 and 6 (\"aababbab\" -> \"aabbbb\"). Example 2: Input: s = \"bbaaaaabb\" Output: 2 Explanation: The only solution is to delete the first two characters. Constraints: 1 <= s.length <= 105 s[i] is 'a' or 'b'\u200b\u200b.",
        "title": "Minimum Deletions to Make String Balanced",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color). Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7. Example 1: Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. Example 2: Input: n = 5000 Output: 30228214 Constraints: n == grid.length 1 <= n <= 5000",
        "title": "Number of Ways to Paint N \u00d7 3 Grid",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 <= nums.length <= 105 -30 <= nums[i] <= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
        "title": "Product of Array Except Self",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j]. Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7. Example 1: Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Example 2: Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. Constraints: 1 <= n <= 1000 0 <= k <= 1000",
        "title": "K Inverse Pairs Array",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise. Example 1: Input: s = \"annabelle\", k = 2 Output: true Explanation: You can construct two palindromes using all characters in s. Some possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\" Example 2: Input: s = \"leetcode\", k = 3 Output: false Explanation: It is impossible to construct 3 palindromes using all the characters of s. Example 3: Input: s = \"true\", k = 4 Output: true Explanation: The only possible solution is to put each character in a separate string. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters. 1 <= k <= 105",
        "title": "Construct K Palindrome Strings",
        "class": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values. Return the minimum number of moves required so that nums has k consecutive 1's. Example 1: Input: nums = [1,0,0,1,0,1], k = 2 Output: 1 Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's. Example 2: Input: nums = [1,0,0,0,0,0,1,1], k = 3 Output: 5 Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1]. Example 3: Input: nums = [1,1,0,1], k = 2 Output: 0 Explanation: nums already has 2 consecutive 1's. Constraints: 1 <= nums.length <= 105 nums[i] is 0 or 1. 1 <= k <= sum(nums)",
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times. Example 1: Input: s = \"eleetminicoworoep\" Output: 13 Explanation: The longest substring is \"leetminicowor\" which contains two each of the vowels: e, i and o and zero of the vowels: a and u. Example 2: Input: s = \"leetcodeisgreat\" Output: 5 Explanation: The longest substring is \"leetc\" which contains two e's. Example 3: Input: s = \"bcbcbc\" Output: 6 Explanation: In this case, the given string \"bcbcbc\" is the longest because all vowels: a, e, i, o and u appear zero times. Constraints: 1 <= s.length <= 5 x 10^5 s contains only lowercase English letters.",
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Example 1: Input: s = \"ABAB\", k = 2 Output: 4 Explanation: Replace the two 'A's with two 'B's or vice versa. Example 2: Input: s = \"AABABBA\", k = 1 Output: 4 Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\". The substring \"BBBB\" has the longest repeating letters, which is 4. Constraints: 1 <= s.length <= 105 s consists of only uppercase English letters. 0 <= k <= s.length",
        "title": "Longest Repeating Character Replacement",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 <= s.length <= 2 * 105 s consists only of printable ASCII characters.",
        "title": "Valid Palindrome",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return \"No solution\" if there is no solution for the equation, or \"Infinite solutions\" if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer. Example 1: Input: equation = \"x+5-3+x=6+x-2\" Output: \"x=2\" Example 2: Input: equation = \"x=x\" Output: \"Infinite solutions\" Example 3: Input: equation = \"2x=x\" Output: \"x=0\" Constraints: 3 <= equation.length <= 1000 equation has exactly one '='. equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable 'x'.",
        "title": "Solve the Equation",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted. Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7. Example 1: Input: m = 1, n = 1 Output: 3 Explanation: The three possible colorings are shown in the image above. Example 2: Input: m = 1, n = 2 Output: 6 Explanation: The six possible colorings are shown in the image above. Example 3: Input: m = 5, n = 5 Output: 580986 Constraints: 1 <= m <= 5 1 <= n <= 1000",
        "title": "Painting a Grid With Three Different Colors",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "title": "Two Sum",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. Example 1: Input: s = \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Example 2: Input: s = \"azxxzy\" Output: \"ay\" Constraints: 1 <= s.length <= 105 s consists of lowercase English letters.",
        "title": "Remove All Adjacent Duplicates In String",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome. Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right]. Example 1: Input: left = \"4\", right = \"1000\" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome. Example 2: Input: left = \"1\", right = \"2\" Output: 1 Constraints: 1 <= left.length, right.length <= 18 left and right consist of only digits. left and right cannot have leading zeros. left and right represent integers in the range [1, 1018 - 1]. left is less than or equal to right.",
        "title": "Super Palindromes",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros. Example 1: Input: num = \"123\", target = 6 Output: [\"1*2*3\",\"1+2+3\"] Explanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6. Example 2: Input: num = \"232\", target = 8 Output: [\"2*3+2\",\"2+3*2\"] Explanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8. Example 3: Input: num = \"3456237490\", target = 9191 Output: [] Explanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191. Constraints: 1 <= num.length <= 10 num consists of only digits. -231 <= target <= 231 - 1",
        "title": "Expression Add Operators",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not. Example 1: Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Example 2: Input: n = 2 Output: false Constraints: 1 <= n <= 231 - 1",
        "title": "Happy Number",
        "class": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [7,2,4,3], l2 = [5,6,4] Output: [7,8,0,7] Example 2: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [8,0,7] Example 3: Input: l1 = [0], l2 = [0] Output: [0] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Follow up: Could you solve it without reversing the input lists?",
        "title": "Add Two Numbers II",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree. If node i has no left child then leftChild[i] will equal -1, similarly for the right child. Note that the nodes have no values and that we only use the node numbers in this problem. Example 1: Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1] Output: true Example 2: Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1] Output: false Example 3: Input: n = 2, leftChild = [1,0], rightChild = [-1,-1] Output: false Constraints: n == leftChild.length == rightChild.length 1 <= n <= 104 -1 <= leftChild[i], rightChild[i] <= n - 1",
        "title": "Validate Binary Tree Nodes",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1. For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end. Given an integer k, return the number of non-negative integers x have the property that f(x) = k. Example 1: Input: k = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes. Example 2: Input: k = 5 Output: 0 Explanation: There is no x such that x! ends in k = 5 zeroes. Example 3: Input: k = 3 Output: 5 Constraints: 0 <= k <= 109",
        "title": "Preimage Size of Factorial Zeroes Function",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A substring is a contiguous (non-empty) sequence of characters within a string. A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given a string word, return the number of vowel substrings in word. Example 1: Input: word = \"aeiouu\" Output: 2 Explanation: The vowel substrings of word are as follows (underlined): - \"aeiouu\" - \"aeiouu\" Example 2: Input: word = \"unicornarihan\" Output: 0 Explanation: Not all 5 vowels are present, so there are no vowel substrings. Example 3: Input: word = \"cuaieuouac\" Output: 7 Explanation: The vowel substrings of word are as follows (underlined): - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" Constraints: 1 <= word.length <= 100 word consists of lowercase English letters only.",
        "title": "Count Vowel Substrings of a String",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array nums\u200b\u200b\u200b and an integer k\u200b\u200b\u200b\u200b\u200b. The XOR of a segment [left, right] where left <= right is the XOR of all the elements with indices between left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right]. Return the minimum number of elements to change in the array such that the XOR of all segments of size k\u200b\u200b\u200b\u200b\u200b\u200b is equal to zero. Example 1: Input: nums = [1,2,0,3,0], k = 1 Output: 3 Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0]. Example 2: Input: nums = [3,4,5,2,1,7,3,4,7], k = 3 Output: 3 Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7]. Example 3: Input: nums = [1,2,4,1,2,5,1,2,6], k = 3 Output: 3 Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3]. Constraints: 1 <= k <= nums.length <= 2000 \u200b\u200b\u200b\u200b\u200b\u200b0 <= nums[i] < 210",
        "title": "Make the XOR of All Segments Equal to Zero",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string s, return the maximum number of ocurrences of any substring under the following rules: The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive. Example 1: Input: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4 Output: 2 Explanation: Substring \"aab\" has 2 ocurrences in the original string. It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize). Example 2: Input: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3 Output: 2 Explanation: Substring \"aaa\" occur 2 times in the string. It can overlap. Constraints: 1 <= s.length <= 105 1 <= maxLetters <= 26 1 <= minSize <= maxSize <= min(26, s.length) s consists of only lowercase English letters.",
        "title": "Maximum Number of Occurrences of a Substring",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0. Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors. Example 1: Input: n = 12, k = 3 Output: 3 Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3. Example 2: Input: n = 7, k = 2 Output: 7 Explanation: Factors list is [1, 7], the 2nd factor is 7. Example 3: Input: n = 4, k = 4 Output: -1 Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1. Constraints: 1 <= k <= n <= 1000",
        "title": "The kth Factor of n",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API. Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10(). Example 1: Input: n = 1 Output: [2] Example 2: Input: n = 2 Output: [2,8] Example 3: Input: n = 3 Output: [3,8,10] Constraints: 1 <= n <= 105 Follow up: What is the expected value for the number of calls to rand7() function? Could you minimize the number of calls to rand7()?",
        "title": "Implement Rand10() Using Rand7()",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit. Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit. Note that abs(x) equals x if x >= 0, and -x otherwise. Example 1: Input: nums = [1,-1,1], limit = 3, goal = -4 Output: 2 Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4. Example 2: Input: nums = [1,-10,9,1], limit = 100, goal = 0 Output: 1 Constraints: 1 <= nums.length <= 105 1 <= limit <= 106 -limit <= nums[i] <= limit -109 <= goal <= 109",
        "title": "Minimum Elements to Add to Form a Given Sum",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\r \r In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\r \r If there is no way to make arr1 strictly increasing, return -1.\r \r \r Example 1:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\r Output: 1\r Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\r \r \r Example 2:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\r Output: 2\r Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\r \r \r Example 3:\r \r \r Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\r Output: -1\r Explanation: You can't make arr1 strictly increasing.\r \r \r Constraints:\r \r \r 1 <= arr1.length, arr2.length <= 2000\r 0 <= arr1[i], arr2[i] <= 10^9",
        "title": "Make Array Strictly Increasing",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not. Example 1: Input: s = \"abc\" Output: 7 Explanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\". Example 2: Input: s = \"aba\" Output: 6 Explanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"aa\", \"ba\", and \"aba\". Example 3: Input: s = \"aaa\" Output: 3 Explanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\". Constraints: 1 <= s.length <= 2000 s consists of lowercase English letters.",
        "title": "Distinct Subsequences II",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path. Example 1: Input: grid = [[0,1],[1,0]] Output: 2 Example 2: Input: grid = [[0,0,0],[1,1,0],[1,1,0]] Output: 4 Example 3: Input: grid = [[1,0,0],[1,1,0],[1,1,0]] Output: -1 Constraints: n == grid.length n == grid[i].length 1 <= n <= 100 grid[i][j] is 0 or 1",
        "title": "Shortest Path in Binary Matrix",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b. Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has a size of at least two. Example 1: Input: intervals = [[1,3],[1,4],[2,5],[3,5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}. For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3. Example 2: Input: intervals = [[1,2],[2,3],[2,4],[4,5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}. Constraints: 1 <= intervals.length <= 3000 intervals[i].length == 2 0 <= ai < bi <= 108",
        "title": "Set Intersection Size At Least Two",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "You are given an integer array nums sorted in non-decreasing order. Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array. In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed). Example 1: Input: nums = [2,3,5] Output: [4,3,5] Explanation: Assuming the arrays are 0-indexed, then result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4, result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3, result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5. Example 2: Input: nums = [1,4,6,8,10] Output: [24,15,13,15,21] Constraints: 2 <= nums.length <= 105 1 <= nums[i] <= nums[i + 1] <= 104",
        "title": "Sum of Absolute Differences in a Sorted Array",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 <= prices.length <= 105 0 <= prices[i] <= 104",
        "title": "Best Time to Buy and Sell Stock",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely. Example 1: Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Example 2: Input: nums = [1,5] Output: 10 Constraints: n == nums.length 1 <= n <= 300 0 <= nums[i] <= 100",
        "title": "Burst Balloons",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing. Return the length of the shortest subarray to remove. A subarray is a contiguous subsequence of the array. Example 1: Input: arr = [1,2,3,10,4,2,3,5] Output: 3 Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted. Another correct solution is to remove the subarray [3,10,4]. Example 2: Input: arr = [5,4,3,2,1] Output: 4 Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1]. Example 3: Input: arr = [1,2,3] Output: 0 Explanation: The array is already non-decreasing. We do not need to remove any elements. Constraints: 1 <= arr.length <= 105 0 <= arr[i] <= 109",
        "title": "Shortest Subarray to be Removed to Make Array Sorted",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. Example 1: Input: grid = [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: grid = [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: grid = [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 grid[i][j] is 0, 1, or 2.",
        "title": "Rotting Oranges",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2: Input: root = [1,2,3], targetSum = 5 Output: [] Example 3: Input: root = [1,2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000",
        "title": "Path Sum II",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed. Example 1: Input: arr = [3,3,3,3,5,5,5,2,2,7] Output: 2 Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array). Possible sets of size 2 are {3,5},{3,2},{5,2}. Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array. Example 2: Input: arr = [7,7,7,7,7,7] Output: 1 Explanation: The only possible set you can choose is {7}. This will make the new array empty. Constraints: 1 <= arr.length <= 105 arr.length is even. 1 <= arr[i] <= 105",
        "title": "Reduce Array Size to The Half",
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input: root = [0,null,1] Output: [1,null,1] Constraints: The number of nodes in the tree is in the range [1, 100]. 0 <= Node.val <= 100 All the values in the tree are unique. Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/",
        "title": "Binary Search Tree to Greater Sum Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return the reformatted string or return an empty string if it is impossible to reformat the string. Example 1: Input: s = \"a0b1c2\" Output: \"0a1b2c\" Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations. Example 2: Input: s = \"leetcode\" Output: \"\" Explanation: \"leetcode\" has only characters so we cannot separate them by digits. Example 3: Input: s = \"1229857369\" Output: \"\" Explanation: \"1229857369\" has only digits so we cannot separate them by characters. Constraints: 1 <= s.length <= 500 s consists of only lowercase English letters and/or digits.",
        "title": "Reformat The String",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head. The steps of the insertion sort algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] Constraints: The number of nodes in the list is in the range [1, 5000]. -5000 <= Node.val <= 5000",
        "title": "Insertion Sort List",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n). Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams). Example 1: Input: rating = [2,5,3,4,1] Output: 3 Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2: Input: rating = [2,1,3] Output: 0 Explanation: We can't form any team given the conditions. Example 3: Input: rating = [1,2,3,4] Output: 4 Constraints: n == rating.length 3 <= n <= 1000 1 <= rating[i] <= 105 All the integers in rating are unique.",
        "title": "Count Number of Teams",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. Example 1: Input: s = \"book\" Output: true Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. Example 2: Input: s = \"textbook\" Output: false Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. Constraints: 2 <= s.length <= 1000 s.length is even. s consists of uppercase and lowercase letters.",
        "title": "Determine if String Halves Are Alike",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order. A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column. Example 1: Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2: Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3: Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. Constraints: m == mat.length n == mat[i].length 1 <= n, m <= 50 1 <= matrix[i][j] <= 105. All elements in the matrix are distinct.",
        "title": "Lucky Numbers in a Matrix",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] Example 2: Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]] Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 100 -1000 <= mat[i][j] <= 1000 1 <= r, c <= 300",
        "title": "Reshape the Matrix",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j). We view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. Example 1: Input: grid = [[1,2],[3,4]] Output: 17 Explanation: Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane. Example 2: Input: grid = [[2]] Output: 5 Example 3: Input: grid = [[1,0],[0,2]] Output: 8 Constraints: n == grid.length == grid[i].length 1 <= n <= 50 0 <= grid[i][j] <= 50",
        "title": "Projection Area of 3D Shapes",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. Example 1: Input: asteroids = [5,10,-5] Output: [5,10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide. Example 2: Input: asteroids = [8,-8] Output: [] Explanation: The 8 and -8 collide exploding each other. Example 3: Input: asteroids = [10,2,-5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10. Constraints: 2 <= asteroids.length <= 104 -1000 <= asteroids[i] <= 1000 asteroids[i] != 0",
        "title": "Asteroid Collision",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. It is guaranteed that the answer will in the range of 32-bit signed integer. Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9). Example 2: Input: root = [1,3,null,5,3] Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3). Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2). Constraints: The number of nodes in the tree is in the range [1, 3000]. -100 <= Node.val <= 100",
        "title": "Maximum Width of Binary Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum. Return any such subsequence as an integer array of length k. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: nums = [2,1,3,3], k = 2 Output: [3,3] Explanation: The subsequence has the largest sum of 3 + 3 = 6. Example 2: Input: nums = [-1,-2,3,4], k = 3 Output: [-1,3,4] Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6. Example 3: Input: nums = [3,4,3,3], k = 2 Output: [3,4] Explanation: The subsequence has the largest sum of 3 + 4 = 7. Another possible subsequence is [4, 3]. Constraints: 1 <= nums.length <= 1000 -105 <= nums[i] <= 105 1 <= k <= nums.length",
        "title": "Find Subsequence of Length K With the Largest Sum",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "You are given a string word that consists of digits and lowercase English letters. You will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123 34 8 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\". Return the number of different integers after performing the replacement operations on word. Two integers are considered different if their decimal representations without any leading zeros are different. Example 1: Input: word = \"a123bc34d8ef34\" Output: 3 Explanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once. Example 2: Input: word = \"leet1234code234\" Output: 2 Example 3: Input: word = \"a1b01c001\" Output: 1 Explanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because the leading zeros are ignored when comparing their decimal values. Constraints: 1 <= word.length <= 1000 word consists of digits and lowercase English letters.",
        "title": "Number of Different Integers in a String",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: Input: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 6000]. -100 <= Node.val <= 100 Follow-up: You may only use constant extra space. The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
        "title": "Populating Next Right Pointers in Each Node II",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index. According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n - h papers have no more than h citations each. If there are several possible values for h, the maximum one is taken as the h-index. Example 1: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: Input: citations = [1,3,1] Output: 1 Constraints: n == citations.length 1 <= n <= 5000 0 <= citations[i] <= 1000",
        "title": "H-Index",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation. Example 1: Input: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]. Example 2: Input: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums. Example 3: Input: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums. Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100",
        "title": "Check if Array Is Sorted and Rotated",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums and an integer k. For each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after changing the values at each index. Example 1: Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: Input: nums = [1,3,6], k = 3 Output: 3 Explanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3. Constraints: 1 <= nums.length <= 104 0 <= nums[i] <= 104 0 <= k <= 104",
        "title": "Smallest Range II",
        "class": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile. Also, if a player cannot make a move, he/she loses the game. Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally. Example 1: Input: n = 1 Output: true Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves. Example 2: Input: n = 2 Output: false Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0). Example 3: Input: n = 4 Output: true Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0). Constraints: 1 <= n <= 105",
        "title": "Stone Game IV",
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: 'A': Absent. 'L': Late. 'P': Present. The student is eligible for an attendance award if they meet both of the following criteria: The student was absent ('A') for strictly fewer than 2 days total. The student was never late ('L') for 3 or more consecutive days. Return true if the student is eligible for an attendance award, or false otherwise. Example 1: Input: s = \"PPALLP\" Output: true Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days. Example 2: Input: s = \"PPALLL\" Output: false Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award. Constraints: 1 <= s.length <= 1000 s[i] is either 'A', 'L', or 'P'.",
        "title": "Student Attendance Record I",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u') Each vowel 'a' may only be followed by an 'e'. Each vowel 'e' may only be followed by an 'a' or an 'i'. Each vowel 'i' may not be followed by another 'i'. Each vowel 'o' may only be followed by an 'i' or a 'u'. Each vowel 'u' may only be followed by an 'a'. Since the answer may be too large, return it modulo 10^9 + 7. Example 1: Input: n = 1 Output: 5 Explanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\". Example 2: Input: n = 2 Output: 10 Explanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\". Example 3: Input: n = 5 Output: 68 Constraints: 1 <= n <= 2 * 10^4",
        "title": "Count Vowels Permutation",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once. Example 1: Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]] Output: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"] Example 2: Input: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] Output: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"] Explanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order. Constraints: 1 <= tickets.length <= 300 tickets[i].length == 2 fromi.length == 3 toi.length == 3 fromi and toi consist of uppercase English letters. fromi != toi",
        "title": "Reconstruct Itinerary",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it. You will buy an axis-aligned square plot of land that is centered at (0, 0). Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot. The value of |x| is defined as: x if x >= 0 -x if x < 0 Example 1: Input: neededApples = 1 Output: 8 Explanation: A square plot of side length 1 does not contain any apples. However, a square plot of side length 2 has 12 apples inside (as depicted in the image above). The perimeter is 2 * 4 = 8. Example 2: Input: neededApples = 13 Output: 16 Example 3: Input: neededApples = 1000000000 Output: 5040 Constraints: 1 <= neededApples <= 1015",
        "title": "Minimum Garden Perimeter to Collect Enough Apples",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0. Example 1: Input: rods = [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. Example 2: Input: rods = [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. Example 3: Input: rods = [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. Constraints: 1 <= rods.length <= 20 1 <= rods[i] <= 1000 sum(rods[i]) <= 5000",
        "title": "Tallest Billboard",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "There are n couples sitting in 2n seats arranged in a row and want to hold hands. The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1). Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. Example 1: Input: row = [0,2,1,3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input: row = [3,2,0,1] Output: 0 Explanation: All couples are already seated side by side. Constraints: 2n == row.length 2 <= n <= 30 n is even. 0 <= row[i] < 2n All the elements of row are unique.",
        "title": "Couples Holding Hands",
        "class": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "content": "You are given a string s of lowercase English letters and an integer array shifts of the same length. Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a'). For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times. Return the final string after all such shifts to s are applied. Example 1: Input: s = \"abc\", shifts = [3,5,9] Output: \"rpl\" Explanation: We start with \"abc\". After shifting the first 1 letters of s by 3, we have \"dbc\". After shifting the first 2 letters of s by 5, we have \"igc\". After shifting the first 3 letters of s by 9, we have \"rpl\", the answer. Example 2: Input: s = \"aaa\", shifts = [1,2,3] Output: \"gfd\" Constraints: 1 <= s.length <= 105 s consists of lowercase English letters. shifts.length == s.length 0 <= shifts[i] <= 109",
        "title": "Shifting Letters",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure : let x be the sum of all elements currently in your array. choose index i, such that 0 <= i < n and set the value of arr at index i to x. You may repeat this procedure as many times as needed. Return true if it is possible to construct the target array from arr, otherwise, return false. Example 1: Input: target = [9,3,5] Output: true Explanation: Start with arr = [1, 1, 1] [1, 1, 1], sum = 3 choose index 1 [1, 3, 1], sum = 5 choose index 2 [1, 3, 5], sum = 9 choose index 0 [9, 3, 5] Done Example 2: Input: target = [1,1,1,2] Output: false Explanation: Impossible to create target array from [1,1,1,1]. Example 3: Input: target = [8,5] Output: true Constraints: n == target.length 1 <= n <= 5 * 104 1 <= target[i] <= 109",
        "title": "Construct Target Array With Multiple Sums",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Winston was given the above mysterious function func. He has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible. Return the minimum possible value of |func(arr, l, r) - target|. Notice that func should be called with the values l and r where 0 <= l, r < arr.length. Example 1: Input: arr = [9,12,3,7,15], target = 5 Output: 2 Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2. Example 2: Input: arr = [1000000,1000000,1000000], target = 1 Output: 999999 Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999. Example 3: Input: arr = [1,2,4,8,16], target = 0 Output: 0 Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 106 0 <= target <= 107",
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 <= Node.val <= 109 All Node.val are unique. p != q p and q will exist in the tree.",
        "title": "Lowest Common Ancestor of a Binary Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. In other words s2 can break s1 or vice-versa. A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1. Example 1: Input: s1 = \"abc\", s2 = \"xya\" Output: true Explanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\". Example 2: Input: s1 = \"abe\", s2 = \"acd\" Output: false Explanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa. Example 3: Input: s1 = \"leetcodee\", s2 = \"interview\" Output: true Constraints: s1.length == n s2.length == n 1 <= n <= 10^5 All strings consist of lowercase English letters.",
        "title": "Check If a String Can Break Another String",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k. The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all the coordinates of matrix. Example 1: Input: matrix = [[5,2],[1,6]], k = 1 Output: 7 Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. Example 2: Input: matrix = [[5,2],[1,6]], k = 2 Output: 5 Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. Example 3: Input: matrix = [[5,2],[1,6]], k = 3 Output: 4 Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 1000 0 <= matrix[i][j] <= 106 1 <= k <= m * n",
        "title": "Find Kth Largest XOR Coordinate Value",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"ababbb\" Output: 9 Explanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Example 2: Input: s = \"zaaaxbbby\" Output: 9 Explanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Constraints: 2 <= s.length <= 105 s consists of lowercase English letters.",
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times.",
        "title": "Find Minimum in Rotated Sorted Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray. Note that the partition must use every integer in nums, and that the score is not necessarily an integer. Return the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted. Example 1: Input: nums = [9,1,2,3,9], k = 3 Output: 20.00000 Explanation: The best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned nums into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse. Example 2: Input: nums = [1,2,3,4,5,6,7], k = 4 Output: 20.50000 Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 104 1 <= k <= nums.length",
        "title": "Largest Sum of Averages",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2: Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3: Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination. Constraints: 2 <= k <= 9 1 <= n <= 60",
        "title": "Combination Sum III",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: Input: candidates = [2], target = 1 Output: [] Constraints: 1 <= candidates.length <= 30 1 <= candidates[i] <= 200 All elements of candidates are distinct. 1 <= target <= 500",
        "title": "Combination Sum",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n). In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations. Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal. Example 1: Input: n = 3 Output: 2 Explanation: arr = [1, 3, 5] First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4] In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3]. Example 2: Input: n = 6 Output: 9 Constraints: 1 <= n <= 104",
        "title": "Minimum Operations to Make Array Equal",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target. Example 1: Input: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\" Output: 4 Explanation: Valid pairs are: - (0, 1): \"777\" + \"7\" - (1, 0): \"7\" + \"777\" - (2, 3): \"77\" + \"77\" - (3, 2): \"77\" + \"77\" Example 2: Input: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\" Output: 2 Explanation: Valid pairs are: - (0, 1): \"123\" + \"4\" - (2, 3): \"12\" + \"34\" Example 3: Input: nums = [\"1\",\"1\",\"1\"], target = \"11\" Output: 6 Explanation: Valid pairs are: - (0, 1): \"1\" + \"1\" - (1, 0): \"1\" + \"1\" - (0, 2): \"1\" + \"1\" - (2, 0): \"1\" + \"1\" - (1, 2): \"1\" + \"1\" - (2, 1): \"1\" + \"1\" Constraints: 2 <= nums.length <= 100 1 <= nums[i].length <= 100 2 <= target.length <= 100 nums[i] and target consist of digits. nums[i] and target do not have leading zeros.",
        "title": "Number of Pairs of Strings With Concatenation Equal to Target",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array of integers arr and an integer target. You have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum. Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays. Example 1: Input: arr = [3,2,2,4,3], target = 3 Output: 2 Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2. Example 2: Input: arr = [7,3,4,7], target = 7 Output: 2 Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2. Example 3: Input: arr = [4,3,2,6,2,3,4], target = 6 Output: -1 Explanation: We have only one sub-array of sum = 6. Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 1000 1 <= target <= 108",
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "class": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range. If you choose a job that ends at time X you will be able to start another job that starts at time X. Example 1: Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Example 3: Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] Output: 6 Constraints: 1 <= startTime.length == endTime.length == profit.length <= 5 * 104 1 <= startTime[i] < endTime[i] <= 109 1 <= profit[i] <= 104",
        "title": "Maximum Profit in Job Scheduling",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "content": "You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed. Example 1: Input: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\" Output: [ [\"mobile\",\"moneypot\",\"monitor\"], [\"mobile\",\"moneypot\",\"monitor\"], [\"mouse\",\"mousepad\"], [\"mouse\",\"mousepad\"], [\"mouse\",\"mousepad\"] ] Explanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"] After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"] After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"] Example 2: Input: products = [\"havana\"], searchWord = \"havana\" Output: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]] Example 3: Input: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\" Output: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]] Constraints: 1 <= products.length <= 1000 1 <= products[i].length <= 3000 1 <= sum(products[i].length) <= 2 * 104 All the strings of products are unique. products[i] consists of lowercase English letters. 1 <= searchWord.length <= 1000 searchWord consists of lowercase English letters.",
        "title": "Search Suggestions System",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater's warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses. Notice that all the heaters follow your radius standard, and the warm radius will the same. Example 1: Input: houses = [1,2,3], heaters = [2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. Example 2: Input: houses = [1,2,3,4], heaters = [1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. Example 3: Input: houses = [1,5], heaters = [2] Output: 3 Constraints: 1 <= houses.length, heaters.length <= 3 * 104 1 <= houses[i], heaters[i] <= 109",
        "title": "Heaters",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum. Rick stated that magnetic force between two different balls at positions x and y is |x - y|. Given the integer array position and the integer m. Return the required force. Example 1: Input: position = [1,2,3,4,7], m = 3 Output: 3 Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. Example 2: Input: position = [5,4,3,2,1,1000000000], m = 2 Output: 999999999 Explanation: We can use baskets 1 and 1000000000. Constraints: n == position.length 2 <= n <= 105 1 <= position[i] <= 109 All integers in position are distinct. 2 <= m <= position.length",
        "title": "Magnetic Force Between Two Balls",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: 2 <= cost.length <= 1000 0 <= cost[i] <= 999",
        "title": "Min Cost Climbing Stairs",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two integer arrays startTime and endTime and given an integer queryTime. The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i]. Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive. Example 1: Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 Output: 1 Explanation: We have 3 students where: The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4. The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4. The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4. Example 2: Input: startTime = [4], endTime = [4], queryTime = 4 Output: 1 Explanation: The only student was doing their homework at the queryTime. Constraints: startTime.length == endTime.length 1 <= startTime.length <= 100 1 <= startTime[i] <= endTime[i] <= 1000 1 <= queryTime <= 1000",
        "title": "Number of Students Doing Homework at a Given Time",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order). You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation. Return the smallest possible total score that you can achieve with some triangulation of the polygon. Example 1: Input: values = [1,2,3] Output: 6 Explanation: The polygon is already triangulated, and the score of the only triangle is 6. Example 2: Input: values = [3,7,4,5] Output: 144 Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144. The minimum score is 144. Example 3: Input: values = [1,3,1,4,1,5] Output: 13 Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13. Constraints: n == values.length 3 <= n <= 50 1 <= values[i] <= 100",
        "title": "Minimum Score Triangulation of Polygon",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle. Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time. Example 1: Input: radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1 Output: true Explanation: Circle and rectangle share the point (1,0). Example 2: Input: radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1 Output: false Example 3: Input: radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1 Output: true Constraints: 1 <= radius <= 2000 -104 <= xCenter, yCenter <= 104 -104 <= x1 < x2 <= 104 -104 <= y1 < y2 <= 104",
        "title": "Circle and Rectangle Overlapping",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word. A substring is a contiguous sequence of characters within a string. Example 1: Input: patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\" Output: 3 Explanation: - \"a\" appears as a substring in \"abc\". - \"abc\" appears as a substring in \"abc\". - \"bc\" appears as a substring in \"abc\". - \"d\" does not appear as a substring in \"abc\". 3 of the strings in patterns appear as a substring in word. Example 2: Input: patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\" Output: 2 Explanation: - \"a\" appears as a substring in \"aaaaabbbbb\". - \"b\" appears as a substring in \"aaaaabbbbb\". - \"c\" does not appear as a substring in \"aaaaabbbbb\". 2 of the strings in patterns appear as a substring in word. Example 3: Input: patterns = [\"a\",\"a\",\"a\"], word = \"ab\" Output: 3 Explanation: Each of the patterns appears as a substring in word \"ab\". Constraints: 1 <= patterns.length <= 100 1 <= patterns[i].length <= 100 1 <= word.length <= 100 patterns[i] and word consist of lowercase English letters.",
        "title": "Number of Strings That Appear as Substrings in Word",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct. Example 1: Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Constraints: 1 <= nestedList.length <= 500 The values of the integers in the nested list is in the range [-106, 106].",
        "title": "Flatten Nested List Iterator",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "The frequency of an element is the number of times it occurs in an array. You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1. Return the maximum possible frequency of an element after performing at most k operations. Example 1: Input: nums = [1,2,4], k = 5 Output: 3 Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4]. 4 has a frequency of 3. Example 2: Input: nums = [1,4,8,13], k = 5 Output: 2 Explanation: There are multiple optimal solutions: - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2. - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2. - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2. Example 3: Input: nums = [3,9,6], k = 2 Output: 1 Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105 1 <= k <= 105",
        "title": "Frequency of the Most Frequent Element",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring. Example 1: Input: s = \"011101\" Output: 5 Explanation: All possible ways of splitting s into two non-empty substrings are: left = \"0\" and right = \"11101\", score = 1 + 4 = 5 left = \"01\" and right = \"1101\", score = 1 + 3 = 4 left = \"011\" and right = \"101\", score = 1 + 2 = 3 left = \"0111\" and right = \"01\", score = 1 + 1 = 2 left = \"01110\" and right = \"1\", score = 2 + 1 = 3 Example 2: Input: s = \"00111\" Output: 5 Explanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5 Example 3: Input: s = \"1111\" Output: 3 Constraints: 2 <= s.length <= 500 The string s consists of characters '0' and '1' only.",
        "title": "Maximum Score After Splitting a String",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '\u2205', where '\u2205' is defined as the blank character which is less than any other character (More info). Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in words[i] and order are English lowercase letters.",
        "title": "Verifying an Alien Dictionary",
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules: Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length. Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length. Example 1: Input: nums1 = [7,4], nums2 = [5,2,8,9] Output: 1 Explanation: Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). Example 2: Input: nums1 = [1,1], nums2 = [1,1,1] Output: 9 Explanation: All Triplets are valid, because 12 = 1 * 1. Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2). nums1[i]2 = nums2[j] * nums2[k]. Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k]. Example 3: Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7] Output: 2 Explanation: There are 2 valid triplets. Type 1: (3,0,2). nums1[3]2 = nums2[0] * nums2[2]. Type 2: (3,0,1). nums2[3]2 = nums1[0] * nums1[1]. Constraints: 1 <= nums1.length, nums2.length <= 1000 1 <= nums1[i], nums2[i] <= 105",
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\r \r \r For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.\r \r \r Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).\r \r \r \r \r A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\r \r \r Example 1:\r \r \r Input: nums = [4,2,5,3]\r Output: 7\r Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.\r \r \r Example 2:\r \r \r Input: nums = [5,6,7,8]\r Output: 8\r Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.\r \r \r Example 3:\r \r \r Input: nums = [6,2,1,2,4,5]\r Output: 10\r Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.\r \r \r \r Constraints:\r \r \r 1 <= nums.length <= 105\r 1 <= nums[i] <= 105",
        "title": "Maximum Alternating Subsequence Sum",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums. You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums. It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order. Return the original array nums. If there are multiple solutions, return any of them. Example 1: Input: adjacentPairs = [[2,1],[3,4],[3,2]] Output: [1,2,3,4] Explanation: This array has all its adjacent pairs in adjacentPairs. Notice that adjacentPairs[i] may not be in left-to-right order. Example 2: Input: adjacentPairs = [[4,-2],[1,4],[-3,1]] Output: [-2,4,1,-3] Explanation: There can be negative numbers. Another solution is [-3,1,4,-2], which would also be accepted. Example 3: Input: adjacentPairs = [[100000,-100000]] Output: [100000,-100000] Constraints: nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 <= n <= 105 -105 <= nums[i], ui, vi <= 105 There exists some nums that has adjacentPairs as its pairs.",
        "title": "Restore the Array From Adjacent Pairs",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers: You should build the array arr which has the following properties: arr has exactly n integers. 1 <= arr[i] <= m where (0 <= i < n). After applying the mentioned algorithm to arr, the value search_cost is equal to k. Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7. Example 1: Input: n = 2, m = 3, k = 1 Output: 6 Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3] Example 2: Input: n = 5, m = 2, k = 3 Output: 0 Explanation: There are no possible arrays that satisify the mentioned conditions. Example 3: Input: n = 9, m = 1, k = 1 Output: 1 Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1] Constraints: 1 <= n <= 50 1 <= m <= 100 0 <= k <= n",
        "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible. Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, \"abcc\" is lexicographically smaller than \"abcd\" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'. Example 1: Input: palindrome = \"abccba\" Output: \"aaccba\" Explanation: There are many ways to make \"abccba\" not a palindrome, such as \"zbccba\", \"aaccba\", and \"abacba\". Of all the ways, \"aaccba\" is the lexicographically smallest. Example 2: Input: palindrome = \"a\" Output: \"\" Explanation: There is no way to replace a single character to make \"a\" not a palindrome, so return an empty string. Constraints: 1 <= palindrome.length <= 1000 palindrome consists of only lowercase English letters.",
        "title": "Break a Palindrome",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input: expression = \"-1/2+1/2\" Output: \"0/1\" Example 2: Input: expression = \"-1/2+1/2+1/3\" Output: \"1/3\" Example 3: Input: expression = \"1/3-1/2\" Output: \"-1/6\" Constraints: The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1, 10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.",
        "title": "Fraction Addition and Subtraction",
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person. A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]). Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue. Example 1: Input: heights = [10,6,8,5,11,9] Output: [3,1,2,1,1,0] Explanation: Person 0 can see person 1, 2, and 4. Person 1 can see person 2. Person 2 can see person 3 and 4. Person 3 can see person 4. Person 4 can see person 5. Person 5 can see no one since nobody is to the right of them. Example 2: Input: heights = [5,1,2,3,10] Output: [4,1,1,1,0] Constraints: n == heights.length 1 <= n <= 105 1 <= heights[i] <= 105 All the values of heights are unique.",
        "title": "Number of Visible People in a Queue",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure. Implement the MagicDictionary class: MagicDictionary() Initializes the object. void buildDict(String[] dictionary) Sets the data structure with an array of distinct strings dictionary. bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false. Example 1: Input [\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"] [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]] Output [null, null, false, true, false, false] Explanation MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([\"hello\", \"leetcode\"]); magicDictionary.search(\"hello\"); // return False magicDictionary.search(\"hhllo\"); // We can change the second 'h' to 'e' to match \"hello\" so we return True magicDictionary.search(\"hell\"); // return False magicDictionary.search(\"leetcoded\"); // return False Constraints: 1 <= dictionary.length <= 100 1 <= dictionary[i].length <= 100 dictionary[i] consists of only lower-case English letters. All the strings in dictionary are distinct. 1 <= searchWord.length <= 100 searchWord consists of only lower-case English letters. buildDict will be called only once before search. At most 100 calls will be made to search.",
        "title": "Implement Magic Dictionary",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums, and you can perform the following operation any number of times on nums: Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j]. Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise. Example 1: Input: nums = [7,21,3] Output: true Explanation: We can sort [7,21,3] by performing the following operations: - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3] - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21] Example 2: Input: nums = [5,2,6,2] Output: false Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element. Example 3: Input: nums = [10,5,9,3,15] Output: true We can sort [10,5,9,3,15] by performing the following operations: - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10] - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10] - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15] Constraints: 1 <= nums.length <= 3 * 104 2 <= nums[i] <= 105",
        "title": "GCD Sort of an Array",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing. For example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\". Return the resulting string. Example 1: Input: word = \"abcdefd\", ch = \"d\" Output: \"dcbaefd\" Explanation: The first occurrence of \"d\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\". Example 2: Input: word = \"xyxzxe\", ch = \"z\" Output: \"zxyxxe\" Explanation: The first and only occurrence of \"z\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\". Example 3: Input: word = \"abcd\", ch = \"z\" Output: \"abcd\" Explanation: \"z\" does not exist in word. You should not do any reverse operation, the resulting string is \"abcd\". Constraints: 1 <= word.length <= 250 word consists of lowercase English letters. ch is a lowercase English letter.",
        "title": "Reverse Prefix of Word",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The Leetcode file system keeps a log each time some user performs a change folder operation. The operations are described below: \"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). \"./\" : Remain in the same folder. \"x/\" : Move to the child folder named x (This folder is guaranteed to always exist). You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed. Return the minimum number of operations needed to go back to the main folder after the change folder operations. Example 1: Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"] Output: 2 Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder. Example 2: Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"] Output: 3 Example 3: Input: logs = [\"d1/\",\"../\",\"../\",\"../\"] Output: 0 Constraints: 1 <= logs.length <= 103 2 <= logs[i].length <= 10 logs[i] contains lowercase English letters, digits, '.', and '/'. logs[i] follows the format described in the statement. Folder names consist of lowercase English letters and digits.",
        "title": "Crawler Log Folder",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given two strings, word1 and word2. You want to construct a string in the following manner: Choose some non-empty subsequence subsequence1 from word1. Choose some non-empty subsequence subsequence2 from word2. Concatenate the subsequences: subsequence1 + subsequence2, to make the string. Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0. A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters. A palindrome is a string that reads the same forward as well as backward. Example 1: Input: word1 = \"cacb\", word2 = \"cbba\" Output: 5 Explanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome. Example 2: Input: word1 = \"ab\", word2 = \"ab\" Output: 3 Explanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome. Example 3: Input: word1 = \"aa\", word2 = \"bb\" Output: 0 Explanation: You cannot construct a palindrome from the described method, so return 0. Constraints: 1 <= word1.length, word2.length <= 1000 word1 and word2 consist of lowercase English letters.",
        "title": "Maximize Palindrome Length From Subsequences",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s. Example 1: Input: sentence = \"i love eating burger\", searchWord = \"burg\" Output: 4 Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence. Example 2: Input: sentence = \"this problem is an easy problem\", searchWord = \"pro\" Output: 2 Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3: Input: sentence = \"i am tired\", searchWord = \"you\" Output: -1 Explanation: \"you\" is not a prefix of any word in the sentence. Constraints: 1 <= sentence.length <= 100 1 <= searchWord.length <= 10 sentence consists of lowercase English letters and spaces. searchWord consists of lowercase English letters.",
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a binary tree with the following rules: root.val == 0 If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1 If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2 Now the binary tree is contaminated, which means all treeNode.val have been changed to -1. Implement the FindElements class: FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it. bool find(int target) Returns true if the target value exists in the recovered binary tree. Example 1: Input [\"FindElements\",\"find\",\"find\"] [[[-1,null,-1]],[1],[2]] Output [null,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2: Input [\"FindElements\",\"find\",\"find\",\"find\"] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] Output [null,true,true,false] Explanation FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False Example 3: Input [\"FindElements\",\"find\",\"find\",\"find\",\"find\"] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] Output [null,true,false,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True Constraints: TreeNode.val == -1 The height of the binary tree is less than or equal to 20 The total number of nodes is between [1, 104] Total calls of find() is between [1, 104] 0 <= target <= 106",
        "title": "Find Elements in a Contaminated Binary Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique. The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i. Example 1: Input: intervals = [[1,2]] Output: [-1] Explanation: There is only one interval in the collection, so it outputs -1. Example 2: Input: intervals = [[3,4],[2,3],[1,2]] Output: [-1,0,1] Explanation: There is no right interval for [3,4]. The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3. The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2. Example 3: Input: intervals = [[1,4],[2,3],[3,4]] Output: [-1,2,-1] Explanation: There is no right interval for [1,4] and [3,4]. The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3. Constraints: 1 <= intervals.length <= 2 * 104 intervals[i].length == 2 -106 <= starti <= endi <= 106 The start point of each interval is unique.",
        "title": "Find Right Interval",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word. Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text. Return the string after rearranging the spaces. Example 1: Input: text = \" this is a sentence \" Output: \"this is a sentence\" Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces. Example 2: Input: text = \" practice makes perfect\" Output: \"practice makes perfect \" Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string. Constraints: 1 <= text.length <= 100 text consists of lowercase English letters and ' '. text contains at least one word.",
        "title": "Rearrange Spaces Between Words",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors. More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i]. Return any rearrangement of nums that meets the requirements. Example 1: Input: nums = [1,2,3,4,5] Output: [1,2,4,5,3] Explanation: When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5. When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5. When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5. Example 2: Input: nums = [6,2,0,9,7] Output: [9,7,6,2,0] Explanation: When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5. When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5. When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3. Constraints: 3 <= nums.length <= 105 0 <= nums[i] <= 105",
        "title": "Array With Elements Not Equal to Average of Neighbors",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "content": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6) \"KJF\" with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Input: s = \"12\" Output: 2 Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). Constraints: 1 <= s.length <= 100 s contains only digits and may contain leading zero(s).",
        "title": "Decode Ways",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes. Example 1: Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 2: Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 3: Input: root = [9] Output: 1 Constraints: The number of nodes in the tree is in the range [1, 105]. 1 <= Node.val <= 9",
        "title": "Pseudo-Palindromic Paths in a Binary Tree",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination. The instructions are represented as a string, where each character is either: 'H', meaning move horizontally (go right), or 'V', meaning move vertically (go down). Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both \"HHHVV\" and \"HVHVH\" are valid instructions. However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed. Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination. Example 1: Input: destination = [2,3], k = 1 Output: \"HHHVV\" Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows: [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]. Example 2: Input: destination = [2,3], k = 2 Output: \"HHVHV\" Example 3: Input: destination = [2,3], k = 3 Output: \"HHVVH\" Constraints: destination.length == 2 1 <= row, column <= 15 1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b\u200b\u200b\u200b\u200b\u200b.",
        "title": "Kth Smallest Instructions",
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function: You want to use the modify function to covert arr to nums using the minimum number of calls. Return the minimum number of function calls to make nums from arr. The test cases are generated so that the answer fits in a 32-bit signed integer. Example 1: Input: nums = [1,5] Output: 5 Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation). Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations). Increment by 1 (both elements) [0, 4] -> [1, 4] -> [1, 5] (2 operations). Total of operations: 1 + 2 + 2 = 5. Example 2: Input: nums = [2,2] Output: 3 Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations). Double all the elements: [1, 1] -> [2, 2] (1 operation). Total of operations: 2 + 1 = 3. Example 3: Input: nums = [4,2,5] Output: 6 Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums). Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109",
        "title": "Minimum Numbers of Function Calls to Make Target Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times: Choose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once. Return the minimum possible total number of stones remaining after applying the k operations. floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down). Example 1: Input: piles = [5,4,9], k = 2 Output: 12 Explanation: Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [5,4,5]. - Apply the operation on pile 0. The resulting piles are [3,4,5]. The total number of stones in [3,4,5] is 12. Example 2: Input: piles = [4,3,6,7], k = 3 Output: 12 Explanation: Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [4,3,3,7]. - Apply the operation on pile 3. The resulting piles are [4,3,3,4]. - Apply the operation on pile 0. The resulting piles are [2,3,3,4]. The total number of stones in [2,3,3,4] is 12. Constraints: 1 <= piles.length <= 105 1 <= piles[i] <= 104 1 <= k <= 105",
        "title": "Remove Stones to Minimize the Total",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums that is sorted in non-decreasing order. Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true: Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer). All subsequences have a length of 3 or more. Return true if you can split nums according to the above conditions, or false otherwise. A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not). Example 1: Input: nums = [1,2,3,3,4,5] Output: true Explanation: nums can be split into the following subsequences: [1,2,3,3,4,5] --> 1, 2, 3 [1,2,3,3,4,5] --> 3, 4, 5 Example 2: Input: nums = [1,2,3,3,4,4,5,5] Output: true Explanation: nums can be split into the following subsequences: [1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5 [1,2,3,3,4,4,5,5] --> 3, 4, 5 Example 3: Input: nums = [1,2,3,4,4,5] Output: false Explanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more. Constraints: 1 <= nums.length <= 104 -1000 <= nums[i] <= 1000 nums is sorted in non-decreasing order.",
        "title": "Split Array into Consecutive Subsequences",
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules: The cost of painting a digit (i + 1) is given by cost[i] (0-indexed). The total cost used must be equal to target. The integer does not have 0 digits. Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return \"0\". Example 1: Input: cost = [4,3,2,5,6,7,2,5,5], target = 9 Output: \"7772\" Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number. Digit cost 1 -> 4 2 -> 3 3 -> 2 4 -> 5 5 -> 6 6 -> 7 7 -> 2 8 -> 5 9 -> 5 Example 2: Input: cost = [7,6,5,5,5,6,8,7,8], target = 12 Output: \"85\" Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12. Example 3: Input: cost = [2,4,6,2,4,6,4,4,4], target = 5 Output: \"0\" Explanation: It is impossible to paint any integer with total cost equal to target. Constraints: cost.length == 9 1 <= cost[i], target <= 5000",
        "title": "Form Largest Integer With Digits That Add up to Target",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]), and (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length. Example 1: Input: strs = [\"babca\",\"bbazb\"] Output: 3 Explanation: After deleting columns 0, 1, and 4, the final array is strs = [\"bc\", \"az\"]. Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]). Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order. Example 2: Input: strs = [\"edcba\"] Output: 4 Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted. Example 3: Input: strs = [\"ghi\",\"def\",\"abc\"] Output: 0 Explanation: All rows are already lexicographically sorted. Constraints: n == strs.length 1 <= n <= 100 1 <= strs[i].length <= 100 strs[i] consists of lowercase English letters.",
        "title": "Delete Columns to Make Sorted III",
        "class": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. You want to determine if there is a valid path that exists from vertex source to vertex destination. Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise. Example 1: Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 \u2192 1 \u2192 2 - 0 \u2192 2 Example 2: Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. Constraints: 1 <= n <= 2 * 105 0 <= edges.length <= 2 * 105 edges[i].length == 2 0 <= ui, vi <= n - 1 ui != vi 0 <= source, destination <= n - 1 There are no duplicate edges. There are no self edges.",
        "title": "Find if Path Exists in Graph",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. For example, given s = \"EnjoyYourCoffee\" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain \"Enjoy Your Coffee\". Return the modified string after the spaces have been added. Example 1: Input: s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15] Output: \"Leetcode Helps Me Learn\" Explanation: The indices 8, 13, and 15 correspond to the underlined characters in \"LeetcodeHelpsMeLearn\". We then place spaces before those characters. Example 2: Input: s = \"icodeinpython\", spaces = [1,5,7,9] Output: \"i code in py thon\" Explanation: The indices 1, 5, 7, and 9 correspond to the underlined characters in \"icodeinpython\". We then place spaces before those characters. Example 3: Input: s = \"spacing\", spaces = [0,1,2,3,4,5,6] Output: \" s p a c i n g\" Explanation: We are also able to place spaces before the first character of the string. Constraints: 1 <= s.length <= 3 * 105 s consists only of lowercase and uppercase English letters. 1 <= spaces.length <= 3 * 105 0 <= spaces[i] <= s.length - 1 All the values of spaces are strictly increasing.",
        "title": "Adding Spaces to a String",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t. Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction: 'L' means to go from a node to its left child node. 'R' means to go from a node to its right child node. 'U' means to go from a node to its parent node. Return the step-by-step directions of the shortest path from node s to node t. Example 1: Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 Output: \"UURL\" Explanation: The shortest path is: 3 \u2192 1 \u2192 5 \u2192 2 \u2192 6. Example 2: Input: root = [2,1], startValue = 2, destValue = 1 Output: \"L\" Explanation: The shortest path is: 2 \u2192 1. Constraints: The number of nodes in the tree is n. 2 <= n <= 105 1 <= Node.val <= n All the values in the tree are unique. 1 <= startValue, destValue <= n startValue != destValue",
        "title": "Step-By-Step Directions From a Binary Tree Node to Another",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given k identical eggs and you have access to a building with n floors labeled from 1 to n. You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. Each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves. Return the minimum number of moves that you need to determine with certainty what the value of f is. Example 1: Input: k = 1, n = 2 Output: 2 Explanation: Drop the egg from floor 1. If it breaks, we know that f = 0. Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1. If it does not break, then we know f = 2. Hence, we need at minimum 2 moves to determine with certainty what the value of f is. Example 2: Input: k = 2, n = 6 Output: 3 Example 3: Input: k = 3, n = 14 Output: 4 Constraints: 1 <= k <= 100 1 <= n <= 104",
        "title": "Super Egg Drop",
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the minimum possible value of answer.length. Example 1: Input: strs = [\"ca\",\"bb\",\"ac\"] Output: 1 Explanation: After deleting the first column, strs = [\"a\", \"b\", \"c\"]. Now strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]). We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1. Example 2: Input: strs = [\"xc\",\"yb\",\"za\"] Output: 0 Explanation: strs is already in lexicographic order, so we do not need to delete anything. Note that the rows of strs are not necessarily in lexicographic order: i.e., it is NOT necessarily true that (strs[0][0] <= strs[0][1] <= ...) Example 3: Input: strs = [\"zyx\",\"wvu\",\"tsr\"] Output: 3 Explanation: We have to delete every column. Constraints: n == strs.length 1 <= n <= 100 1 <= strs[i].length <= 100 strs[i] consists of lowercase English letters.",
        "title": "Delete Columns to Make Sorted II",
        "class": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Given a list of words, list of single letters (might be repeating) and score of every character. Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times). It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively. Example 1: Input: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] Output: 23 Explanation: Score a=1, c=9, d=5, g=3, o=2 Given letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23. Words \"dad\" and \"dog\" only get a score of 21. Example 2: Input: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] Output: 27 Explanation: Score a=4, b=4, c=4, x=5, z=10 Given letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27. Word \"xxxz\" only get a score of 25. Example 3: Input: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] Output: 0 Explanation: Letter \"e\" can only be used once. Constraints: 1 <= words.length <= 14 1 <= words[i].length <= 15 1 <= letters.length <= 100 letters[i].length == 1 score.length == 26 0 <= score[i] <= 10 words[i], letters[i] contains only lower case English letters.",
        "title": "Maximum Score Words Formed by Letters",
        "class": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction. Example 1: Input: stones = [0,1,3,5,6,8,12,17] Output: true Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example 2: Input: stones = [0,1,2,3,4,8,9,11] Output: false Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. Constraints: 2 <= stones.length <= 2000 0 <= stones[i] <= 231 - 1 stones[0] == 0 stones is sorted in a strictly increasing order.",
        "title": "Frog Jump",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter. If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false. Return a boolean array answer where answer[i] is the result of the ith query queries[i]. Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s. Example : Input: s = \"abcda\", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] Output: [true,false,false,true,true] Explanation: queries[0]: substring = \"d\", is palidrome. queries[1]: substring = \"bc\", is not palidrome. queries[2]: substring = \"abcd\", is not palidrome after replacing only 1 character. queries[3]: substring = \"abcd\", could be changed to \"abba\" which is palidrome. Also this can be changed to \"baab\" first rearrange it \"bacd\" then replace \"cd\" with \"ab\". queries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palidrome. Example 2: Input: s = \"lyb\", queries = [[0,1,0],[2,2,1]] Output: [false,true] Constraints: 1 <= s.length, queries.length <= 105 0 <= lefti <= righti < s.length 0 <= ki <= s.length s consists of lowercase English letters.",
        "title": "Can Make Palindrome from Substring",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences. For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative. In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero. A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order. Given an integer array nums, return the length of the longest wiggle subsequence of nums. Example 1: Input: nums = [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3). Example 2: Input: nums = [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8). Example 3: Input: nums = [1,2,3,4,5,6,7,8,9] Output: 2 Constraints: 1 <= nums.length <= 1000 0 <= nums[i] <= 1000 Follow up: Could you solve this in O(n) time?",
        "title": "Wiggle Subsequence",
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values. For examples, if arr = [2,3,4], the median is 3. For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5. You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted. Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] Explanation: Window position Median --------------- ----- [1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Example 2: Input: nums = [1,2,3,4,2,3,1,4,2], k = 3 Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000] Constraints: 1 <= k <= nums.length <= 105 -231 <= nums[i] <= 231 - 1",
        "title": "Sliding Window Median",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram: A chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell). Given an integer n, return how many distinct phone numbers of length n we can dial. You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps. As the answer may be very large, return the answer modulo 109 + 7. Example 1: Input: n = 1 Output: 10 Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient. Example 2: Input: n = 2 Output: 20 Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94] Example 3: Input: n = 3131 Output: 136006598 Explanation: Please take care of the mod. Constraints: 1 <= n <= 5000",
        "title": "Knight Dialer",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Example 1: Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]] Output: 7 Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN. Example 2: Input: dungeon = [[0]] Output: 1 Constraints: m == dungeon.length n == dungeon[i].length 1 <= m, n <= 200 -1000 <= dungeon[i][j] <= 1000",
        "title": "Dungeon Game",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple. Example 1: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 2: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output: 6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 3: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output: 0 Constraints: 1 <= n <= 105 edges.length == n - 1 edges[i].length == 2 0 <= ai < bi <= n - 1 fromi < toi hasApple.length == n",
        "title": "Minimum Time to Collect All Apples in a Tree",
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d]. You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]). Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num. A substring is a contiguous sequence of characters within the string. Example 1: Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8] Output: \"832\" Explanation: Replace the substring \"1\": - 1 maps to change[1] = 8. Thus, \"132\" becomes \"832\". \"832\" is the largest number that can be created, so return it. Example 2: Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6] Output: \"934\" Explanation: Replace the substring \"021\": - 0 maps to change[0] = 9. - 2 maps to change[2] = 3. - 1 maps to change[1] = 4. Thus, \"021\" becomes \"934\". \"934\" is the largest number that can be created, so return it. Example 3: Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4] Output: \"5\" Explanation: \"5\" is already the largest number that can be created, so return it. Constraints: 1 <= num.length <= 105 num consists of only digits 0-9. change.length == 10 0 <= change[d] <= 9",
        "title": "Largest Number After Mutating Substring",
        "class": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute. On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied. The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once. Return the maximum number of customers that can be satisfied throughout the day. Example 1: Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. Example 2: Input: customers = [1], grumpy = [0], minutes = 1 Output: 1 Constraints: n == customers.length == grumpy.length 1 <= minutes <= n <= 2 * 104 0 <= customers[i] <= 1000 grumpy[i] is either 0 or 1.",
        "title": "Grumpy Bookstore Owner",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:\r \r \r In the beginning, you have the permutation P=[1,2,3,...,m].\r For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].\r \r \r Return an array containing the result for the given queries.\r \r \r Example 1:\r \r \r Input: queries = [3,1,2,1], m = 5\r Output: [2,1,2,1] \r Explanation: The queries are processed as follow: \r For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \r For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \r For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \r For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \r Therefore, the array containing the result is [2,1,2,1]. \r \r \r Example 2:\r \r \r Input: queries = [4,1,2,2], m = 4\r Output: [3,1,2,0]\r \r \r Example 3:\r \r \r Input: queries = [7,5,5,8,3], m = 8\r Output: [6,5,0,7,5]\r \r \r \r Constraints:\r \r \r 1 <= m <= 10^3\r 1 <= queries.length <= m\r 1 <= queries[i] <= m",
        "title": "Queries on a Permutation With Key",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s. Example 1: Input: s = \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: Input: s = \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: Input: s = \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Constraints: 1 <= s.length <= 105 s[i] is either '(' or ')'. s is a valid parentheses string.",
        "title": "Remove Outermost Parentheses",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Example 1: Input: num = 3 Output: \"III\" Explanation: 3 is represented as 3 ones. Example 2: Input: num = 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 3: Input: num = 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: 1 <= num <= 3999",
        "title": "Integer to Roman",
        "class": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. Example 1: Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]] Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000] Explanation: Given: a / b = 2.0, b / c = 3.0 queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? return: [6.0, 0.5, -1.0, 1.0, -1.0 ] Example 2: Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]] Output: [3.75000,0.40000,5.00000,0.20000] Example 3: Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]] Output: [0.50000,2.00000,-1.00000,-1.00000] Constraints: 1 <= equations.length <= 20 equations[i].length == 2 1 <= Ai.length, Bi.length <= 5 values.length == equations.length 0.0 < values[i] <= 20.0 1 <= queries.length <= 20 queries[i].length == 2 1 <= Cj.length, Dj.length <= 5 Ai, Bi, Cj, Dj consist of lower case English letters and digits.",
        "title": "Evaluate Division",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring. For example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right. Return an integer array answer where answer[i] is the answer to the ith query. Example 1: Input: s = \"**|**|***|\", queries = [[2,5],[5,9]] Output: [2,3] Explanation: - queries[0] has two plates between candles. - queries[1] has three plates between candles. Example 2: Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] Output: [9,0,0,0,0] Explanation: - queries[0] has nine plates between candles. - The other queries have zero plates between candles. Constraints: 3 <= s.length <= 105 s consists of '*' and '|' characters. 1 <= queries.length <= 105 queries[i].length == 2 0 <= lefti <= righti < s.length",
        "title": "Plates Between Candles",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. Example 1: Input: path = \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: path = \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints: 1 <= path.length <= 3000 path consists of English letters, digits, period '.', slash '/' or '_'. path is a valid absolute Unix path.",
        "title": "Simplify Path",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes. The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes. Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2 Output: 0.78333 Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333. Example 2: Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 Output: 0.53485 Constraints: 1 <= classes.length <= 105 classes[i].length == 2 1 <= passi <= totali <= 105 1 <= extraStudents <= 105",
        "title": "Maximum Average Pass Ratio",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "You are given two positive integer arrays nums1 and nums2, both of length n. The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed). You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference. Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7. |x| is defined as: x if x >= 0, or -x if x < 0. Example 1: Input: nums1 = [1,7,5], nums2 = [2,3,5] Output: 3 Explanation: There are two possible optimal solutions: - Replace the second element with the first: [1,7,5] => [1,1,5], or - Replace the second element with the third: [1,7,5] => [1,5,5]. Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3. Example 2: Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10] Output: 0 Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an absolute sum difference of 0. Example 3: Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4] Output: 20 Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7]. This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20 Constraints: n == nums1.length n == nums2.length 1 <= n <= 105 1 <= nums1[i], nums2[i] <= 105",
        "title": "Minimum Absolute Sum Difference",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities. There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively. Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all. A subpath of a path is a contiguous sequence of cities within that path. Example 1: Input: n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] Output: 2 Explanation: The longest common subpath is [2,3]. Example 2: Input: n = 3, paths = [[0],[1],[2]] Output: 0 Explanation: There is no common subpath shared by the three paths. Example 3: Input: n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] Output: 1 Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1. Constraints: 1 <= n <= 105 m == paths.length 2 <= m <= 105 sum(paths[i].length) <= 105 0 <= paths[i][j] < n The same city is not listed multiple times consecutively in paths[i].",
        "title": "Longest Common Subpath",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house. Return the maximum distance between two houses with different colors. The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x. Example 1: Input: colors = [1,1,1,6,1,1,1] Output: 3 Explanation: In the above image, color 1 is blue, and color 6 is red. The furthest two houses with different colors are house 0 and house 3. House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3. Note that houses 3 and 6 can also produce the optimal answer. Example 2: Input: colors = [1,8,3,8,3] Output: 4 Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green. The furthest two houses with different colors are house 0 and house 4. House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4. Example 3: Input: colors = [0,1] Output: 1 Explanation: The furthest two houses with different colors are house 0 and house 1. House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1. Constraints: n == colors.length 2 <= n <= 100 0 <= colors[i] <= 100 Test data are generated such that at least two houses have different colors.",
        "title": "Two Furthest Houses With Different Colors",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "Let's play the minesweeper game (Wikipedia, online game)! You are given an m x n char matrix board representing the game board where: 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals), digit ('1' to '8') represents how many mines are adjacent to this revealed square, and 'X' represents a revealed mine. You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E'). Return the board after revealing this position according to the following rules: If a mine 'M' is revealed, then the game is over. You should change it to 'X'. If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively. If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed. Example 1: Input: board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0] Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]] Example 2: Input: board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2] Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 50 board[i][j] is either 'M', 'E', 'B', or a digit from '1' to '8'. click.length == 2 0 <= clickr < m 0 <= clickc < n board[clickr][clickc] is either 'M' or 'E'.",
        "title": "Minesweeper",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happen before addition and subtraction. It is not allowed to use the unary negation operator (-). For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. Example 2: Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations. Constraints: 2 <= x <= 100 1 <= target <= 2 * 108",
        "title": "Least Operators to Express Number",
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer n, the number of teams in a tournament that has strange rules: If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round. If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round. Return the number of matches played in the tournament until a winner is decided. Example 1: Input: n = 7 Output: 6 Explanation: Details of the tournament: - 1st Round: Teams = 7, Matches = 3, and 4 teams advance. - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. Example 2: Input: n = 14 Output: 13 Explanation: Details of the tournament: - 1st Round: Teams = 14, Matches = 7, and 7 teams advance. - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. Constraints: 1 <= n <= 200",
        "title": "Count of Matches in Tournament",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a 0-indexed array of distinct integers nums. There is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array. A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array. Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array. Example 1: Input: nums = [2,10,7,5,4,1,8,6] Output: 5 Explanation: The minimum element in the array is nums[5], which is 1. The maximum element in the array is nums[1], which is 10. We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back. This results in 2 + 3 = 5 deletions, which is the minimum number possible. Example 2: Input: nums = [0,-4,19,1,8,-2,-3,5] Output: 3 Explanation: The minimum element in the array is nums[1], which is -4. The maximum element in the array is nums[2], which is 19. We can remove both the minimum and maximum by removing 3 elements from the front. This results in only 3 deletions, which is the minimum number possible. Example 3: Input: nums = [101] Output: 1 Explanation: There is only one element in the array, which makes it both the minimum and maximum element. We can remove it with 1 deletion. Constraints: 1 <= nums.length <= 105 -105 <= nums[i] <= 105 The integers in nums are distinct.",
        "title": "Removing Minimum and Maximum From Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "A website domain \"discuss.leetcode.com\" consists of various subdomains. At the top level, we have \"com\", at the next level, we have \"leetcode.com\" and at the lowest level, \"discuss.leetcode.com\". When we visit a domain like \"discuss.leetcode.com\", we will also visit the parent domains \"leetcode.com\" and \"com\" implicitly. A count-paired domain is a domain that has one of the two formats \"rep d1.d2.d3\" or \"rep d1.d2\" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself. For example, \"9001 discuss.leetcode.com\" is a count-paired domain that indicates that discuss.leetcode.com was visited 9001 times. Given an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order. Example 1: Input: cpdomains = [\"9001 discuss.leetcode.com\"] Output: [\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"] Explanation: We only have one website domain: \"discuss.leetcode.com\". As discussed above, the subdomain \"leetcode.com\" and \"com\" will also be visited. So they will all be visited 9001 times. Example 2: Input: cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"] Output: [\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"] Explanation: We will visit \"google.mail.com\" 900 times, \"yahoo.com\" 50 times, \"intel.mail.com\" once and \"wiki.org\" 5 times. For the subdomains, we will visit \"mail.com\" 900 + 1 = 901 times, \"com\" 900 + 50 + 1 = 951 times, and \"org\" 5 times. Constraints: 1 <= cpdomain.length <= 100 1 <= cpdomain[i].length <= 100 cpdomain[i] follows either the \"repi d1i.d2i.d3i\" format or the \"repi d1i.d2i\" format. repi is an integer in the range [1, 104]. d1i, d2i, and d3i consist of lowercase English letters.",
        "title": "Subdomain Visit Count",
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes. Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise. Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query. Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. Constraints: 2 <= n <= 105 1 <= edgeList.length, queries.length <= 105 edgeList[i].length == 3 queries[j].length == 3 0 <= ui, vi, pj, qj <= n - 1 ui != vi pj != qj 1 <= disi, limitj <= 109 There may be multiple edges between two nodes.",
        "title": "Checking Existence of Edge Length Limited Paths",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. Example 1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example 2: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. Example 3: Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] Output: 0 Constraints: n == source.length == target.length 1 <= n <= 105 1 <= source[i], target[i] <= 105 0 <= allowedSwaps.length <= 105 allowedSwaps[i].length == 2 0 <= ai, bi <= n - 1 ai != bi",
        "title": "Minimize Hamming Distance After Swap Operations",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. Example 1: Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Example 2: Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 Constraints: n == grid.length n == grid[i].length 1 <= n <= 50 grid[i][j] is -1, 0, or 1. grid[0][0] != -1 grid[n - 1][n - 1] != -1",
        "title": "Cherry Pickup",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "Design a stack which supports the following operations. Implement the CustomStack class: CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize. void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize. int pop() Pops and returns the top of stack or -1 if the stack is empty. void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack. Example 1: Input [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] Output [null,null,null,2,null,null,null,null,null,103,202,201,-1] Explanation CustomStack customStack = new CustomStack(3); // Stack is Empty [] customStack.push(1); // stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.pop(); // return 2 --> Return top of the stack 2, stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.push(3); // stack becomes [1, 2, 3] customStack.push(4); // stack still [1, 2, 3], Don't add another elements as size is 4 customStack.increment(5, 100); // stack becomes [101, 102, 103] customStack.increment(2, 100); // stack becomes [201, 202, 103] customStack.pop(); // return 103 --> Return top of the stack 103, stack becomes [201, 202] customStack.pop(); // return 202 --> Return top of the stack 102, stack becomes [201] customStack.pop(); // return 201 --> Return top of the stack 101, stack becomes [] customStack.pop(); // return -1 --> Stack is empty return -1. Constraints: 1 <= maxSize <= 1000 1 <= x <= 1000 1 <= k <= 1000 0 <= val <= 100 At most 1000 calls will be made to each method of increment, push and pop each separately.",
        "title": "Design a Stack With Increment Operation",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. All inputs are integral coordinates. Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. All actions happen simultaneously. You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape. Return true if it is possible to escape regardless of how the ghosts move, otherwise return false. Example 1: Input: ghosts = [[1,0],[0,3]], target = [0,1] Output: true Explanation: You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you. Example 2: Input: ghosts = [[1,0]], target = [2,0] Output: false Explanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination. Example 3: Input: ghosts = [[2,0]], target = [1,0] Output: false Explanation: The ghost can reach the target at the same time as you. Constraints: 1 <= ghosts.length <= 100 ghosts[i].length == 2 -104 <= xi, yi <= 104 There can be multiple ghosts in the same location. target.length == 2 -104 <= xtarget, ytarget <= 104",
        "title": "Escape The Ghosts",
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell. You have two robots that can collect cherries for you: Robot #1 is located at the top-left corner (0, 0), and Robot #2 is located at the top-right corner (0, cols - 1). Return the maximum number of cherries collection using both robots by following the rules below: From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1). When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell. When both robots stay in the same cell, only one takes the cherries. Both robots cannot move outside of the grid at any moment. Both robots should reach the bottom row in grid. Example 1: Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]] Output: 24 Explanation: Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12. Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of cherries: 12 + 12 = 24. Example 2: Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]] Output: 28 Explanation: Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17. Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11. Total of cherries: 17 + 11 = 28. Constraints: rows == grid.length cols == grid[i].length 2 <= rows, cols <= 70 0 <= grid[i][j] <= 100",
        "title": "Cherry Pickup II",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time. Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] Output: 4 Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes. The four ways to get there in 7 minutes are: - 0 \u279d 6 - 0 \u279d 4 \u279d 6 - 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6 - 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6 Example 2: Input: n = 2, roads = [[1,0,10]] Output: 1 Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes. Constraints: 1 <= n <= 200 n - 1 <= roads.length <= n * (n - 1) / 2 roads[i].length == 3 0 <= ui, vi <= n - 1 1 <= timei <= 109 ui != vi There is at most one road connecting any two intersections. You can reach any intersection from any other intersection.",
        "title": "Number of Ways to Arrive at Destination",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "A string s can be partitioned into groups of size k using the following procedure: The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group. For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure. Example 1: Input: s = \"abcdefghi\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\"] Explanation: The first 3 characters \"abc\" form the first group. The next 3 characters \"def\" form the second group. The last 3 characters \"ghi\" form the third group. Since all groups can be completely filled by characters from the string, we do not need to use fill. Thus, the groups formed are \"abc\", \"def\", and \"ghi\". Example 2: Input: s = \"abcdefghij\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\",\"jxx\"] Explanation: Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\". For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice. Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\". Constraints: 1 <= s.length <= 100 s consists of lowercase English letters only. 1 <= k <= 100 fill is a lowercase English letter.",
        "title": "Divide a String Into Groups of Size k",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations. You can perform the following operation at most maxOperations times: Take any bag of balls and divide it into two new bags with a positive number of balls. For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls. Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations. Return the minimum possible penalty after performing the operations. Example 1: Input: nums = [9], maxOperations = 2 Output: 3 Explanation: - Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3]. - Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3]. The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3. Example 2: Input: nums = [2,4,8,2], maxOperations = 4 Output: 2 Explanation: - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2]. The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2. Example 3: Input: nums = [7,17], maxOperations = 2 Output: 7 Constraints: 1 <= nums.length <= 105 1 <= maxOperations, nums[i] <= 109",
        "title": "Minimum Limit of Balls in a Bag",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold. Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path. Example 1: Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 Output: 3 Explanation: The figure above describes the graph. The neighboring cities at a distanceThreshold = 4 for each city are: City 0 -> [City 1, City 2] City 1 -> [City 0, City 2, City 3] City 2 -> [City 0, City 1, City 3] City 3 -> [City 1, City 2] Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. Example 2: Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 Output: 0 Explanation: The figure above describes the graph. The neighboring cities at a distanceThreshold = 2 for each city are: City 0 -> [City 1] City 1 -> [City 0, City 4] City 2 -> [City 3, City 4] City 3 -> [City 2, City 4] City 4 -> [City 1, City 2, City 3] The city 0 has 1 neighboring city at a distanceThreshold = 2. Constraints: 2 <= n <= 100 1 <= edges.length <= n * (n - 1) / 2 edges[i].length == 3 0 <= fromi < toi < n 1 <= weighti, distanceThreshold <= 10^4 All pairs (fromi, toi) are distinct.",
        "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options: If word1 is non-empty, append the first character in word1 to merge and delete it from word1. For example, if word1 = \"abc\" and merge = \"dv\", then after choosing this operation, word1 = \"bc\" and merge = \"dva\". If word2 is non-empty, append the first character in word2 to merge and delete it from word2. For example, if word2 = \"abc\" and merge = \"\", then after choosing this operation, word2 = \"bc\" and merge = \"a\". Return the lexicographically largest merge you can construct. A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c. Example 1: Input: word1 = \"cabaa\", word2 = \"bcaaa\" Output: \"cbcabaaaaa\" Explanation: One way to get the lexicographically largest merge is: - Take from word1: merge = \"c\", word1 = \"abaa\", word2 = \"bcaaa\" - Take from word2: merge = \"cb\", word1 = \"abaa\", word2 = \"caaa\" - Take from word2: merge = \"cbc\", word1 = \"abaa\", word2 = \"aaa\" - Take from word1: merge = \"cbca\", word1 = \"baa\", word2 = \"aaa\" - Take from word1: merge = \"cbcab\", word1 = \"aa\", word2 = \"aaa\" - Append the remaining 5 a's from word1 and word2 at the end of merge. Example 2: Input: word1 = \"abcabc\", word2 = \"abdcaba\" Output: \"abdcabcabcaba\" Constraints: 1 <= word1.length, word2.length <= 3000 word1 and word2 consist only of lowercase English letters.",
        "title": "Largest Merge Of Two Strings",
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]: lefti is the x coordinate of the left edge of the ith building. righti is the x coordinate of the right edge of the ith building. heighti is the height of the ith building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...] Example 1: Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] Explanation: Figure A shows the buildings of the input. Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list. Example 2: Input: buildings = [[0,2,3],[2,5,3]] Output: [[0,3],[5,0]] Constraints: 1 <= buildings.length <= 104 0 <= lefti < righti <= 231 - 1 1 <= heighti <= 231 - 1 buildings is sorted by lefti in non-decreasing order.",
        "title": "The Skyline Problem",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time. The ith day is a good day to rob the bank if: There are at least time days before and after the ith day, The number of guards at the bank for the time days before i are non-increasing, and The number of guards at the bank for the time days after i are non-decreasing. More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]. Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter. Example 1: Input: security = [5,3,3,3,5,6,2], time = 2 Output: [2,3] Explanation: On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4]. On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5]. No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank. Example 2: Input: security = [1,1,1,1,1], time = 0 Output: [0,1,2,3,4] Explanation: Since time equals 0, every day is a good day to rob the bank, so return every day. Example 3: Input: security = [1,2,3,4,5,6], time = 2 Output: [] Explanation: No day has 2 days before it that have a non-increasing number of guards. Thus, no day is a good day to rob the bank, so return an empty list. Constraints: 1 <= security.length <= 105 0 <= security[i], time <= 105",
        "title": "Find Good Days to Rob the Bank",
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at. In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit. Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists. Example 1: Input: maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2] Output: 1 Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3]. Initially, you are at the entrance cell [1,2]. - You can reach [1,0] by moving 2 steps left. - You can reach [0,2] by moving 1 step up. It is impossible to reach [2,3] from the entrance. Thus, the nearest exit is [0,2], which is 1 step away. Example 2: Input: maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0] Output: 2 Explanation: There is 1 exit in this maze at [1,2]. [1,0] does not count as an exit since it is the entrance cell. Initially, you are at the entrance cell [1,0]. - You can reach [1,2] by moving 2 steps right. Thus, the nearest exit is [1,2], which is 2 steps away. Example 3: Input: maze = [[\".\",\"+\"]], entrance = [0,0] Output: -1 Explanation: There are no exits in this maze. Constraints: maze.length == m maze[i].length == n 1 <= m, n <= 100 maze[i][j] is either '.' or '+'. entrance.length == 2 0 <= entrancerow < m 0 <= entrancecol < n entrance will always be an empty cell.",
        "title": "Nearest Exit from Entrance in Maze",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture: Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext. In text form, it looks like this (with \u27f6 representing the tab character): dir \u27f6 subdir1 \u27f6 \u27f6 file1.ext \u27f6 \u27f6 subsubdir1 \u27f6 subdir2 \u27f6 \u27f6 subsubdir2 \u27f6 \u27f6 \u27f6 file2.ext If we were to write this representation in code, it will look like this: \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\". Note that the '\\n' and '\\t' are the new-line and tab characters. Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is \"dir/subdir2/subsubdir2/file2.ext\". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces. Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0. Example 1: Input: input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" Output: 20 Explanation: We have only one file, and the absolute path is \"dir/subdir2/file.ext\" of length 20. Example 2: Input: input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" Output: 32 Explanation: We have two files: \"dir/subdir1/file1.ext\" of length 21 \"dir/subdir2/subsubdir2/file2.ext\" of length 32. We return 32 since it is the longest absolute path to a file. Example 3: Input: input = \"a\" Output: 0 Explanation: We do not have any files, just a single directory named \"a\". Constraints: 1 <= input.length <= 104 input may contain lowercase or uppercase English letters, a new line character '\\n', a tab character '\\t', a dot '.', a space ' ', and digits.",
        "title": "Longest Absolute File Path",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3. Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise. The frequency of a letter x is the number of times it occurs in the string. Example 1: Input: word1 = \"aaaa\", word2 = \"bccb\" Output: false Explanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\". The difference is 4, which is more than the allowed 3. Example 2: Input: word1 = \"abcdeef\", word2 = \"abaaacc\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3. - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0. - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1. - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1. - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2. - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1. Example 3: Input: word1 = \"cccddabba\", word2 = \"babababab\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2. - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3. - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3. - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2. Constraints: n == word1.length == word2.length 1 <= n <= 100 word1 and word2 consist only of lowercase English letters.",
        "title": "Check Whether Two Strings are Almost Equivalent",
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps: if x is even then x = x / 2 if x is odd then x = 3 * x + 1 For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1). Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order. Return the kth integer in the range [lo, hi] sorted by the power value. Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer. Example 1: Input: lo = 12, hi = 15, k = 2 Output: 13 Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1) The power of 13 is 9 The power of 14 is 17 The power of 15 is 17 The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13. Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15. Example 2: Input: lo = 7, hi = 11, k = 4 Output: 7 Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14]. The interval sorted by power is [8, 10, 11, 7, 9]. The fourth number in the sorted array is 7. Constraints: 1 <= lo <= hi <= 1000 1 <= k <= hi - lo + 1",
        "title": "Sort Integers by The Power Value",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "content": "Given an array of integers arr and an integer k. A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array. If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j]. Return a list of the strongest k values in the array. return the answer in any arbitrary order. Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed). For arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6. For arr = [-7, 22, 17,&thinsp;3], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3. Example 1: Input: arr = [1,2,3,4,5], k = 2 Output: [5,1] Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer. Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1. Example 2: Input: arr = [1,1,3,5,5], k = 2 Output: [5,5] Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5]. Example 3: Input: arr = [6,7,11,7,6,8], k = 5 Output: [11,8,6,6,7] Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7]. Any permutation of [11,8,6,6,7] is accepted. Constraints: 1 <= arr.length <= 105 -105 <= arr[i] <= 105 1 <= k <= arr.length",
        "title": "The k Strongest Values in an Array",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner: lower[i] = arr[i] - k, for every index i where 0 <= i < n higher[i] = arr[i] + k, for every index i where 0 <= i < n Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array. Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array. Note: The test cases are generated such that there exists at least one valid array arr. Example 1: Input: nums = [2,10,6,4,8,12] Output: [3,7,11] Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12]. Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums. Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. Example 2: Input: nums = [1,1,3,3] Output: [2,2] Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3]. Combining lower and higher gives us [1,1,3,3], which is equal to nums. Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0. This is invalid since k must be positive. Example 3: Input: nums = [5,435] Output: [220] Explanation: The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435]. Constraints: 2 * n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 109 The test cases are generated such that there exists at least one valid array arr.",
        "title": "Recover the Original Array",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "content": "There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively. Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1). You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down). Return the last day where it is possible to walk from the top to the bottom by only walking on land cells. Example 1: Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] Output: 2 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2. Example 2: Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] Output: 1 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 1. Example 3: Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] Output: 3 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 3. Constraints: 2 <= row, col <= 2 * 104 4 <= row * col <= 2 * 104 cells.length == row * col 1 <= ri <= row 1 <= ci <= col All the values of cells are unique.",
        "title": "Last Day Where You Can Still Cross",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also removing a random element. Implement the RandomizedCollection class: RandomizedCollection() Initializes the empty RandomizedCollection object. bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise. bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them. int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of same values the multiset contains. You must implement the functions of the class such that each function works on average O(1) time complexity. Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection. Example 1: Input [\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"] [[], [1], [1], [2], [], [1], []] Output [null, true, false, true, 2, true, 1] Explanation RandomizedCollection randomizedCollection = new RandomizedCollection(); randomizedCollection.insert(1); // return true since the collection does not contain 1. // Inserts 1 into the collection. randomizedCollection.insert(1); // return false since the collection contains 1. // Inserts another 1 into the collection. Collection now contains [1,1]. randomizedCollection.insert(2); // return true since the collection does not contain 2. // Inserts 2 into the collection. Collection now contains [1,1,2]. randomizedCollection.getRandom(); // getRandom should: // - return 1 with probability 2/3, or // - return 2 with probability 1/3. randomizedCollection.remove(1); // return true since the collection contains 1. // Removes 1 from the collection. Collection now contains [1,2]. randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely. Constraints: -231 <= val <= 231 - 1 At most 2 * 105 calls in total will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called.",
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]). The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree. Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i. A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes. Example 1: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\" Output: [2,1,1,1,1,1,1] Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree. Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself). Example 2: Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\" Output: [4,2,1,1] Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1. The sub-tree of node 3 contains only node 3, so the answer is 1. The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2. The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4. Example 3: Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\" Output: [3,2,1,1,1] Constraints: 1 <= n <= 105 edges.length == n - 1 edges[i].length == 2 0 <= ai, bi < n ai != bi labels.length == n labels is consisting of only of lowercase English letters.",
        "title": "Number of Nodes in the Sub-Tree With the Same Label",
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": "You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance. You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable. The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula \u230aqi / (1 + d)\u230b, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers. Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate. Note: A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either: x1 < x2, or x1 == x2 and y1 < y2. \u230aval\u230b is the greatest integer less than or equal to val (the floor function). Example 1: Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2 Output: [2,1] Explanation: At coordinate (2, 1) the total quality is 13. - Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7 - Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2 - Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4 No other coordinate has a higher network quality. Example 2: Input: towers = [[23,11,21]], radius = 9 Output: [23,11] Explanation: Since there is only one tower, the network quality is highest right at the tower's location. Example 3: Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2 Output: [1,2] Explanation: Coordinate (1, 2) has the highest network quality. Constraints: 1 <= towers.length <= 50 towers[i].length == 3 0 <= xi, yi, qi <= 50 1 <= radius <= 50",
        "title": "Coordinate With Maximum Network Quality",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If all elements of a are the same, the minimum absolute difference is -1. For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different. You are given an integer array nums and the array queries where queries[i] = [li, ri]. For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive). Return an array ans where ans[i] is the answer to the ith query. A subarray is a contiguous sequence of elements in an array. The value of |x| is defined as: x if x >= 0. -x if x < 0. Example 1: Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] Output: [2,1,4,1] Explanation: The queries are processed as follows: - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2. - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1. - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4. - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1. Example 2: Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]] Output: [-1,1,1,3] Explanation: The queries are processed as follows: - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the elements are the same. - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1. - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1. - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3. Constraints: 2 <= nums.length <= 105 1 <= nums[i] <= 100 1 <= queries.length <= 2 * 104 0 <= li < ri < nums.length",
        "title": "Minimum Absolute Difference Queries",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity. Implement the DinnerPlates class: DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity. void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity. int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty. int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty. Example 1: Input [\"DinnerPlates\", \"push\", \"push\", \"push\", \"push\", \"push\", \"popAtStack\", \"push\", \"push\", \"popAtStack\", \"popAtStack\", \"pop\", \"pop\", \"pop\", \"pop\", \"pop\"] [[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []] Output [null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1] Explanation: DinnerPlates D = DinnerPlates(2); // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5); // The stacks are now: 2 4 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 2. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(20); // The stacks are now: 20 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(21); // The stacks are now: 20 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 20. The stacks are now: 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(2); // Returns 21. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.pop() // Returns 5. The stacks are now: 4 1 3 \ufe48 \ufe48 D.pop() // Returns 4. The stacks are now: 1 3 \ufe48 \ufe48 D.pop() // Returns 3. The stacks are now: 1 \ufe48 D.pop() // Returns 1. There are no stacks. D.pop() // Returns -1. There are still no stacks. Constraints: 1 <= capacity <= 2 * 104 1 <= val <= 2 * 104 0 <= index <= 105 At most 2 * 105 calls will be made to push, pop, and popAtStack.",
        "title": "Dinner Plate Stacks",
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows. originalText is placed first in a top-left to bottom-right manner. The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText. encodedText is then formed by appending all characters of the matrix in a row-wise fashion. The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner: The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\". Given the encoded string encodedText and number of rows rows, return the original string originalText. Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText. Example 1: Input: encodedText = \"ch ie pr\", rows = 3 Output: \"cipher\" Explanation: This is the same example described in the problem description. Example 2: Input: encodedText = \"iveo eed l te olc\", rows = 4 Output: \"i love leetcode\" Explanation: The figure above denotes the matrix that was used to encode originalText. The blue arrows show how we can find originalText from encodedText. Example 3: Input: encodedText = \"coding\", rows = 1 Output: \"coding\" Explanation: Since there is only 1 row, both originalText and encodedText are the same. Constraints: 0 <= encodedText.length <= 106 encodedText consists of lowercase English letters and ' ' only. encodedText is a valid encoding of some originalText that does not have trailing spaces. 1 <= rows <= 1000 The testcases are generated such that there is only one possible originalText.",
        "title": "Decode the Slanted Ciphertext",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order. While the exact formula is hidden, the function is monotonically increasing, i.e.: f(x, y) < f(x + 1, y) f(x, y) < f(x, y + 1) The function interface is defined like this: interface CustomFunction { public: // Returns some positive integer f(x, y) for two positive integers x and y based on a formula. int f(int x, int y); }; We will judge your solution as follows: The judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z. The judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z. The judge will call your findSolution and compare your results with the answer key. If your results match the answer key, your solution will be Accepted. Example 1: Input: function_id = 1, z = 5 Output: [[1,4],[2,3],[3,2],[4,1]] Explanation: The hidden formula for function_id = 1 is f(x, y) = x + y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=4 -> f(1, 4) = 1 + 4 = 5. x=2, y=3 -> f(2, 3) = 2 + 3 = 5. x=3, y=2 -> f(3, 2) = 3 + 2 = 5. x=4, y=1 -> f(4, 1) = 4 + 1 = 5. Example 2: Input: function_id = 2, z = 5 Output: [[1,5],[5,1]] Explanation: The hidden formula for function_id = 2 is f(x, y) = x * y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=5 -> f(1, 5) = 1 * 5 = 5. x=5, y=1 -> f(5, 1) = 5 * 1 = 5. Constraints: 1 <= function_id <= 9 1 <= z <= 100 It is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000. It is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000.",
        "title": "Find Positive Integer Solution for a Given Equation",
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix. Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another. The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot. Example 1: Input: grid = [[2,5,4],[1,5,1]] Output: 4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 0 + 4 + 0 = 4 points. Example 2: Input: grid = [[3,3,1],[8,5,2]] Output: 4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 3 + 1 + 0 = 4 points. Example 3: Input: grid = [[1,3,1,15],[1,3,3,1]] Output: 7 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points. Constraints: grid.length == 2 n == grid[r].length 1 <= n <= 5 * 104 1 <= grid[r][c] <= 105",
        "title": "Grid Game",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i]. Execute all the valid transactions. A transaction is valid if: The given account number(s) are between 1 and n, and The amount of money withdrawn or transferred from is less than or equal to the balance of the account. Implement the Bank class: Bank(long[] balance) Initializes the object with the 0-indexed integer array balance. boolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise. boolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise. boolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise. Example 1: Input [\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"] [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]] Output [null, true, true, true, false, false] Explanation Bank bank = new Bank([10, 100, 20, 50, 30]); bank.withdraw(3, 10); // return true, account 3 has a balance of $20, so it is valid to withdraw $10. // Account 3 has $20 - $10 = $10. bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20. // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30. bank.deposit(5, 20); // return true, it is valid to deposit $20 to account 5. // Account 5 has $10 + $20 = $30. bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10, // so it is invalid to transfer $15 from it. bank.withdraw(10, 50); // return false, it is invalid because account 10 does not exist. Constraints: n == balance.length 1 <= n, account, account1, account2 <= 105 0 <= balance[i], money <= 1012 At most 104 calls will be made to each function transfer, deposit, withdraw.",
        "title": "Simple Bank System",
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark. Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time. Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point. Example 1: Input: dist = [1,3,2], hour = 6 Output: 1 Explanation: At speed 1: - The first train ride takes 1/1 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours. - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours. - You will arrive at exactly the 6 hour mark. Example 2: Input: dist = [1,3,2], hour = 2.7 Output: 3 Explanation: At speed 3: - The first train ride takes 1/3 = 0.33333 hours. - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours. - You will arrive at the 2.66667 hour mark. Example 3: Input: dist = [1,3,2], hour = 1.9 Output: -1 Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark. Constraints: n == dist.length 1 <= n <= 105 1 <= dist[i] <= 105 1 <= hour <= 109 There will be at most two digits after the decimal point in hour.",
        "title": "Minimum Speed to Arrive on Time",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. For example, if the row consists of players 1, 2, 4, 6, 7 Player 1 competes against player 7. Player 2 competes against player 6. Player 4 automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order). The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round. Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively. Example 1: Input: n = 11, firstPlayer = 2, secondPlayer = 4 Output: [3,4] Explanation: One possible scenario which leads to the earliest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 2, 3, 4, 5, 6, 11 Third round: 2, 3, 4 One possible scenario which leads to the latest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 1, 2, 3, 4, 5, 6 Third round: 1, 2, 4 Fourth round: 2, 4 Example 2: Input: n = 5, firstPlayer = 1, secondPlayer = 5 Output: [1,1] Explanation: The players numbered 1 and 5 compete in the first round. There is no way to make them compete in any other round. Constraints: 2 <= n <= 28 1 <= firstPlayer < secondPlayer <= n",
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6) \"KJF\" with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". In addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent. Given a string s consisting of digits and '*' characters, return the number of ways to decode it. Since the answer may be very large, return it modulo 109 + 7. Example 1: Input: s = \"*\" Output: 9 Explanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\". Each of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively. Hence, there are a total of 9 ways to decode \"*\". Example 2: Input: s = \"1*\" Output: 18 Explanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Each of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\"). Hence, there are a total of 9 * 2 = 18 ways to decode \"1*\". Example 3: Input: s = \"2*\" Output: 15 Explanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\". \"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way. Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\". Constraints: 1 <= s.length <= 105 s[i] is a digit or '*'.",
        "title": "Decode Ways II",
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": "There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has. You can work on the projects following these two rules: Every week, you will finish exactly one milestone of one project. You must work every week. You cannot work on two milestones from the same project for two consecutive weeks. Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints. Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above. Example 1: Input: milestones = [1,2,3] Output: 6 Explanation: One possible scenario is: \u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 2. - During the 3rd week, you will work on a milestone of project 1. - During the 4th week, you will work on a milestone of project 2. - During the 5th week, you will work on a milestone of project 1. - During the 6th week, you will work on a milestone of project 2. The total number of weeks is 6. Example 2: Input: milestones = [5,2,1] Output: 7 Explanation: One possible scenario is: - During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 1. - During the 3rd week, you will work on a milestone of project 0. - During the 4th week, you will work on a milestone of project 1. - During the 5th week, you will work on a milestone of project 0. - During the 6th week, you will work on a milestone of project 2. - During the 7th week, you will work on a milestone of project 0. The total number of weeks is 7. Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules. Thus, one milestone in project 0 will remain unfinished. Constraints: n == milestones.length 1 <= n <= 105 1 <= milestones[i] <= 109",
        "title": "Maximum Number of Weeks for Which You Can Work",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm: The ith (0-indexed) request arrives. If all servers are busy, the request is dropped (not handled at all). If the (i % k)th server is available, assign the request to that server. Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on. You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers. Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order. Example 1: Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] Output: [1] Explanation: All of the servers start out available. The first 3 requests are handled by the first 3 servers in order. Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1. Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped. Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server. Example 2: Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2] Output: [0] Explanation: The first 3 requests are handled by first 3 servers. Request 3 comes in. It is handled by server 0 since the server is available. Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server. Example 3: Input: k = 3, arrival = [1,2,3], load = [10,12,11] Output: [0,1,2] Explanation: Each server handles a single request, so they are all considered the busiest. Constraints: 1 <= k <= 105 1 <= arrival.length, load.length <= 105 arrival.length == load.length 1 <= arrival[i], load[i] <= 109 arrival is strictly increasing.",
        "title": "Find Servers That Handled Most Number of Requests",
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "content": "A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time. You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released. The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0]. Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration. Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses. Example 1: Input: releaseTimes = [9,29,49,50], keysPressed = \"cbcd\" Output: \"c\" Explanation: The keypresses were as follows: Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9). Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29). Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49). Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50). The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20. 'c' is lexicographically larger than 'b', so the answer is 'c'. Example 2: Input: releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\" Output: \"a\" Explanation: The keypresses were as follows: Keypress for 's' had a duration of 12. Keypress for 'p' had a duration of 23 - 12 = 11. Keypress for 'u' had a duration of 36 - 23 = 13. Keypress for 'd' had a duration of 46 - 36 = 10. Keypress for 'a' had a duration of 62 - 46 = 16. The longest of these was the keypress for 'a' with duration 16. Constraints: releaseTimes.length == n keysPressed.length == n 2 <= n <= 1000 1 <= releaseTimes[i] <= 109 releaseTimes[i] < releaseTimes[i+1] keysPressed contains only lowercase English letters.",
        "title": "Slowest Key",
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold: The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. Example 1: Input: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\" Output: true Explanation: The code is wrapped in a closed tag : <DIV> and </DIV>. The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true. Example 2: Input: code = \"<DIV>>> ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\" Output: true Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> \"<DIV>\" end_tag -> \"</DIV>\" tag_content could also be separated into : text1|cdata|text2. text1 -> \">> ![cdata[]] \" cdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\" text2 -> \"]]>>]\" The reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6. The reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7. Example 3: Input: code = \"<A> <B> </A> </B>\" Output: false Explanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa. Constraints: 1 <= code.length <= 500 code consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '.",
        "title": "Tag Validator",
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": "You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. The orderTypei is:\r \r \r 0 if it is a batch of buy orders, or\r 1 if it is a batch of sell orders.\r \r \r Note that orders[i] represents a batch of amounti independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.\r \r There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\r \r \r If the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.\r Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.\r \r \r Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.\r \r \r Example 1:\r \r \r Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\r Output: 6\r Explanation: Here is what happens with the orders:\r - 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\r - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\r - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\r - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.\r Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.\r \r \r Example 2:\r \r \r Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\r Output: 999999984\r Explanation: Here is what happens with the orders:\r - 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.\r - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\r - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\r - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\r Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).\r \r \r \r Constraints:\r \r \r 1 <= orders.length <= 105\r orders[i].length == 3\r 1 <= pricei, amounti <= 109\r orderTypei is either 0 or 1.",
        "title": "Number of Orders in the Backlog",
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    }
]