[
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given two integers a and b, return the sum of the two integers without using the operators + and -. Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = 2, b = 3 Output: 5 Constraints: -1000 <= a, b <= 1000",
        "title": "Sum of Two Integers"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a binary tree, return the leftmost value in the last row of the tree. Example 1: Input: root = [2,1,3] Output: 1 Example 2: Input: root = [1,2,3,4,null,5,6,null,null,7] Output: 7 Constraints: The number of nodes in the tree is in the range [1, 104]. -231 <= Node.val <= 231 - 1",
        "title": "Find Bottom Left Tree Value"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once. Example 1: Input: s = \"bcabc\" Output: \"abc\" Example 2: Input: s = \"cbacdcbc\" Output: \"acdb\" Constraints: 1 <= s.length <= 1000 s consists of lowercase English letters. Note: This question is the same as 316: https://leetcode.com/problems/remove-duplicate-letters/",
        "title": "Smallest Subsequence of Distinct Characters"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases. Example 1: Input: s = \"hello\" Output: \"holle\" Example 2: Input: s = \"leetcode\" Output: \"leotcede\" Constraints: 1 <= s.length <= 3 * 105 s consist of printable ASCII characters.",
        "title": "Reverse Vowels of a String"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n. Example 1: Input: n = 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99 Example 2: Input: n = 0 Output: 1 Constraints: 0 <= n <= 8",
        "title": "Count Numbers with Unique Digits"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2: Input: nums = [0] Output: [[],[0]] Constraints: 1 <= nums.length <= 10 -10 <= nums[i] <= 10 All the numbers of nums are unique.",
        "title": "Subsets"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree. Example 1: Input: root = [4,2,6,1,3] Output: 1 Example 2: Input: root = [1,0,48,null,null,12,49] Output: 1 Constraints: The number of nodes in the tree is in the range [2, 100]. 0 <= Node.val <= 105 Note: This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "title": "Minimum Distance Between BST Nodes"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 <= k <= nums.length <= 104 -104 <= nums[i] <= 104",
        "title": "Kth Largest Element in an Array"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 104]. -100 <= Node.val <= 100",
        "title": "Maximum Depth of Binary Tree"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... Example 1: Input: columnNumber = 1 Output: \"A\" Example 2: Input: columnNumber = 28 Output: \"AB\" Example 3: Input: columnNumber = 701 Output: \"ZY\" Constraints: 1 <= columnNumber <= 231 - 1",
        "title": "Excel Sheet Column Title"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given two arrays of integers with equal lengths, return the maximum value of:\r \r |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\r \r where the maximum is taken over all 0 <= i, j < arr1.length.\r Example 1: Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6] Output: 13 Example 2: Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4] Output: 20 Constraints: 2 <= arr1.length == arr2.length <= 40000 -10^6 <= arr1[i], arr2[i] <= 10^6",
        "title": "Maximum of Absolute Value Expression"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example 1: Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2: Input: matrix = [[\"0\"]] Output: 0 Example 3: Input: matrix = [[\"1\"]] Output: 1 Constraints: rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is '0' or '1'.",
        "title": "Maximal Rectangle"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. Example 2: Input: s = \"a\" Output: 0 Example 3: Input: s = \"ab\" Output: 1 Constraints: 1 <= s.length <= 2000 s consists of lowercase English letters only.",
        "title": "Palindrome Partitioning II"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x. Example 1: Input: n = 16 Output: true Example 2: Input: n = 5 Output: false Example 3: Input: n = 1 Output: true Constraints: -231 <= n <= 231 - 1 Follow up: Could you solve it without loops/recursion?",
        "title": "Power of Four"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Follow up: Could you minimize the total number of operations done?",
        "title": "Move Zeroes"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false. An integer m is a divisor of n if there exists an integer k such that n = k * m. Example 1: Input: n = 2 Output: false Explantion: 2 has only two divisors: 1 and 2. Example 2: Input: n = 4 Output: true Explantion: 4 has three divisors: 1, 2, and 4. Constraints: 1 <= n <= 104",
        "title": "Three Divisors"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise. Example 1: Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input: arr = [1,2] Output: false Example 3: Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true Constraints: 1 <= arr.length <= 1000 -1000 <= arr[i] <= 1000",
        "title": "Unique Number of Occurrences"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. Example 1: Input: n = 1 Output: true Explanation: 20 = 1 Example 2: Input: n = 16 Output: true Explanation: 24 = 16 Example 3: Input: n = 3 Output: false Constraints: -231 <= n <= 231 - 1 Follow up: Could you solve it without loops/recursion?",
        "title": "Power of Two"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... Example 1: Input: columnTitle = \"A\" Output: 1 Example 2: Input: columnTitle = \"AB\" Output: 28 Example 3: Input: columnTitle = \"ZY\" Output: 701 Constraints: 1 <= columnTitle.length <= 7 columnTitle consists only of uppercase English letters. columnTitle is in the range [\"A\", \"FXSHRXW\"].",
        "title": "Excel Sheet Column Number"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ],
        "content": "Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Example 1: Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. Example 2: Input: nums = [1,2,4,8] Output: [1,2,4,8] Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 2 * 109 All the integers in nums are unique.",
        "title": "Largest Divisible Subset"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false. An integer y is a power of three if there exists an integer x such that y == 3x. Example 1: Input: n = 12 Output: true Explanation: 12 = 31 + 32 Example 2: Input: n = 91 Output: true Explanation: 91 = 30 + 32 + 34 Example 3: Input: n = 21 Output: false Constraints: 1 <= n <= 107",
        "title": "Check if Number is a Sum of Powers of Three"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "The beauty of a string is the difference in frequencies between the most frequent and least frequent characters. For example, the beauty of \"abaacc\" is 3 - 1 = 2. Given a string s, return the sum of beauty of all of its substrings. Example 1: Input: s = \"aabcb\" Output: 5 Explanation: The substrings with non-zero beauty are [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"], each with beauty equal to 1. Example 2: Input: s = \"aabcbaa\" Output: 17 Constraints: 1 <= s.length <= 500 s consists of only lowercase English letters.",
        "title": "Sum of Beauty of All Substrings"
    },
    {
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false Constraints: The number of nodes in the tree is in the range [1, 104]. -104 <= Node.val <= 104 root is guaranteed to be a valid binary search tree. -105 <= k <= 105",
        "title": "Two Sum IV - Input is a BST"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Example 1: Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums is sorted in non-decreasing order. Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?",
        "title": "Squares of a Sorted Array"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 105 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.",
        "title": "Top K Frequent Elements"
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. Example 1: Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"] Output: 16 Explanation: The two words can be \"abcw\", \"xtfn\". Example 2: Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"] Output: 4 Explanation: The two words can be \"ab\", \"cd\". Example 3: Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: 0 Explanation: No such pair of words. Constraints: 2 <= words.length <= 1000 1 <= words[i].length <= 1000 words[i] consists only of lowercase English letters.",
        "title": "Maximum Product of Word Lengths"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,3] and [3,1] are both a height-balanced BSTs. Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums is sorted in a strictly increasing order.",
        "title": "Convert Sorted Array to Binary Search Tree"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Example 3: Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 105 -109 <= nums[i] <= 109 nums is a non-decreasing array. -109 <= target <= 109",
        "title": "Find First and Last Position of Element in Sorted Array"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right]. Example 1: Input: left = 1, right = 22 Output: [1,2,3,4,5,6,7,8,9,11,12,15,22] Example 2: Input: left = 47, right = 85 Output: [48,55,66,77] Constraints: 1 <= left <= right <= 104",
        "title": "Self Dividing Numbers"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0. Example 1: Input: nums = [21,4,7] Output: 32 Explanation: 21 has 4 divisors: 1, 3, 7, 21 4 has 3 divisors: 1, 2, 4 7 has 2 divisors: 1, 7 The answer is the sum of divisors of 21 only. Example 2: Input: nums = [21,21] Output: 64 Example 3: Input: nums = [1,2,3,4,5] Output: 0 Constraints: 1 <= nums.length <= 104 1 <= nums[i] <= 105",
        "title": "Four Divisors"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter. Example 1: Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[3,3],[2,4],[4,2]] Example 2: Input: points = [[1,2],[2,2],[4,2]] Output: [[4,2],[2,2],[1,2]] Constraints: 1 <= points.length <= 3000 points[i].length == 2 0 <= xi, yi <= 100 All the given points are unique.",
        "title": "Erect the Fence"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Constraints: 0 <= s.length <= 5 * 104 s consists of English letters, digits, symbols and spaces.",
        "title": "Longest Substring Without Repeating Characters"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. Example 1: Input: nums = [1,2,3,4] Output: 3 Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself. Example 2: Input: nums = [1] Output: 0 Constraints: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000",
        "title": "Arithmetic Slices"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of integers distance. You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself, and false if it does not. Example 1: Input: distance = [2,1,1,2] Output: true Example 2: Input: distance = [1,2,3,4] Output: false Example 3: Input: distance = [1,1,1,1] Output: true Constraints: 1 <= distance.length <= 105 1 <= distance[i] <= 105",
        "title": "Self Crossing"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array of integers arr, return the number of subarrays with an odd sum. Since the answer can be very large, return it modulo 109 + 7. Example 1: Input: arr = [1,3,5] Output: 4 Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]] All sub-arrays sum are [1,4,9,3,8,5]. Odd sums are [1,9,3,5] so the answer is 4. Example 2: Input: arr = [2,4,6] Output: 0 Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]] All sub-arrays sum are [2,6,12,4,10,6]. All sub-arrays have even sum and the answer is 0. Example 3: Input: arr = [1,2,3,4,5,6,7] Output: 16 Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 100",
        "title": "Number of Sub-arrays With Odd Sum"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2). Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: Input: nums = [4,2,1] Output: false Explanation: You can't get a non-decreasing array by modify at most one element. Constraints: n == nums.length 1 <= n <= 104 -105 <= nums[i] <= 105",
        "title": "Non-decreasing Array"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order. Example 1: Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2: Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] Constraints: 1 <= arr1.length, arr2.length <= 1000 0 <= arr1[i], arr2[i] <= 1000 All the elements of arr2 are distinct. Each arr2[i] is in arr1.",
        "title": "Relative Sort Array"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an integer array nums and two integers k and t, return true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. Example 1: Input: nums = [1,2,3,1], k = 3, t = 0 Output: true Example 2: Input: nums = [1,0,1,1], k = 1, t = 2 Output: true Example 3: Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false Constraints: 1 <= nums.length <= 2 * 104 -231 <= nums[i] <= 231 - 1 0 <= k <= 104 0 <= t <= 231 - 1",
        "title": "Contains Duplicate III"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node. Example 1: Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property \"every subtree not containing a 1\". The diagram on the right represents the answer. Example 2: Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] Example 3: Input: root = [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1] Constraints: The number of nodes in the tree is in the range [1, 200]. Node.val is either 0 or 1.",
        "title": "Binary Tree Pruning"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k. After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10. Example 1: Input: n = 34, k = 6 Output: 9 Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9. Example 2: Input: n = 10, k = 10 Output: 1 Explanation: n is already in base 10. 1 + 0 = 1. Constraints: 1 <= n <= 100 2 <= k <= 10",
        "title": "Sum of Digits in Base K"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Example 1: Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2: Input: nums = [2,0,1] Output: [0,1,2] Constraints: n == nums.length 1 <= n <= 300 nums[i] is either 0, 1, or 2. Follow up: Could you come up with a one-pass algorithm using only constant extra space?",
        "title": "Sort Colors"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: true Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: false Constraints: 1 <= flowerbed.length <= 2 * 104 flowerbed[i] is 0 or 1. There are no two adjacent flowers in flowerbed. 0 <= n <= flowerbed.length",
        "title": "Can Place Flowers"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1. Example 1: Input: arr = [2,2,3,4] Output: 2 Explanation: The only lucky number in the array is 2 because frequency[2] == 2. Example 2: Input: arr = [1,2,2,3,3,3] Output: 3 Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them. Example 3: Input: arr = [2,2,2,3,3] Output: -1 Explanation: There are no lucky numbers in the array. Constraints: 1 <= arr.length <= 500 1 <= arr[i] <= 500",
        "title": "Find Lucky Integer in an Array"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\r \r Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\r \r A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\r \r \r Example 1:\r \r \r Input: nums = [1,3,2,2,5,2,3,7]\r Output: 5\r Explanation: The longest harmonious subsequence is [3,2,2,2,3].\r \r \r Example 2:\r \r \r Input: nums = [1,2,3,4]\r Output: 2\r \r \r Example 3:\r \r \r Input: nums = [1,1,1,1]\r Output: 0\r \r \r \r Constraints:\r \r \r 1 <= nums.length <= 2 * 104\r -109 <= nums[i] <= 109",
        "title": "Longest Harmonious Subsequence"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Take their own seat if it is still available, and Pick other seats randomly when they find their seat occupied Return the probability that the nth person gets his own seat. Example 1: Input: n = 1 Output: 1.00000 Explanation: The first person can only get the first seat. Example 2: Input: n = 2 Output: 0.50000 Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat). Constraints: 1 <= n <= 105",
        "title": "Airplane Seat Assignment Probability"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?). The valid times are those inclusively between 00:00 and 23:59. Return the latest valid time you can get from time by replacing the hidden digits. Example 1: Input: time = \"2?:?0\" Output: \"23:50\" Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50. Example 2: Input: time = \"0?:3?\" Output: \"09:39\" Example 3: Input: time = \"1?:22\" Output: \"19:22\" Constraints: time is in the format hh:mm. It is guaranteed that you can produce a valid time from the given string.",
        "title": "Latest Time by Replacing Hidden Digits"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 grid[i][j] is either 0 or 1.",
        "title": "Max Area of Island"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1: Input: s = \"ab#c\", t = \"ad#c\" Output: true Explanation: Both s and t become \"ac\". Example 2: Input: s = \"ab##\", t = \"c#d#\" Output: true Explanation: Both s and t become \"\". Example 3: Input: s = \"a#c\", t = \"b\" Output: false Explanation: s becomes \"c\" while t becomes \"b\". Constraints: 1 <= s.length, t.length <= 200 s and t only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(n) time and O(1) space?",
        "title": "Backspace String Compare"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes. Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7. In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile. Example 1: Input: n = 3 Output: 5 Explanation: The five different ways are show above. Example 2: Input: n = 1 Output: 1 Constraints: 1 <= n <= 1000",
        "title": "Domino and Tromino Tiling"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive). Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false. Example 1: Input: matrix = [[1,2,3],[3,1,2],[2,3,1]] Output: true Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. Example 2: Input: matrix = [[1,1,1],[1,2,3],[1,2,3]] Output: false Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. Constraints: n == matrix.length == matrix[i].length 1 <= n <= 100 1 <= matrix[i][j] <= n",
        "title": "Check if Every Row and Column Contains All Numbers"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise. Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 Output: true Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] Example 2: Input: hand = [1,2,3,4,5], groupSize = 4 Output: false Explanation: Alice's hand can not be rearranged into groups of 4. Constraints: 1 <= hand.length <= 104 0 <= hand[i] <= 109 1 <= groupSize <= hand.length Note: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/",
        "title": "Hand of Straights"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves). Example 1: Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2: Input: grid = [[0]] Output: 1 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 20 grid[i][j] is either 0 or 1.",
        "title": "Score After Flipping Matrix"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1: Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2: Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Example 3: Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. Constraints: n == nums.length 1 <= n <= 2 * 105 -109 <= nums[i] <= 109",
        "title": "132 Pattern"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return the smallest prime palindrome greater than or equal to n. An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11, and 13 are all primes. An integer is a palindrome if it reads the same from left to right as it does from right to left. For example, 101 and 12321 are palindromes. The test cases are generated so that the answer always exists and is in the range [2, 2 * 108]. Example 1: Input: n = 6 Output: 7 Example 2: Input: n = 8 Output: 11 Example 3: Input: n = 13 Output: 101 Constraints: 1 <= n <= 108",
        "title": "Prime Palindrome"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return true if the square is white, and false if the square is black. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. Example 1: Input: coordinates = \"a1\" Output: false Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false. Example 2: Input: coordinates = \"h3\" Output: true Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true. Example 3: Input: coordinates = \"c7\" Output: false Constraints: coordinates.length == 2 'a' <= coordinates[0] <= 'h' '1' <= coordinates[1] <= '8'",
        "title": "Determine Color of a Chessboard Square"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "The array-form of an integer num is an array representing its digits in left to right order. For example, for num = 1321, the array form is [1,3,2,1]. Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k. Example 1: Input: num = [1,2,0,0], k = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 Example 2: Input: num = [2,7,4], k = 181 Output: [4,5,5] Explanation: 274 + 181 = 455 Example 3: Input: num = [2,1,5], k = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021 Constraints: 1 <= num.length <= 104 0 <= num[i] <= 9 num does not contain any leading zeros except for the zero itself. 1 <= k <= 104",
        "title": "Add to Array-Form of Integer"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: Input: target = 4, nums = [1,4,4] Output: 1 Example 3: Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0 Constraints: 1 <= target <= 109 1 <= nums.length <= 105 1 <= nums[i] <= 105 Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
        "title": "Minimum Size Subarray Sum"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Example 1: Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"] Output: \"world\" Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\". Example 2: Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"] Output: \"apple\" Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\". Constraints: 1 <= words.length <= 1000 1 <= words[i].length <= 30 words[i] consists of lowercase English letters.",
        "title": "Longest Word in Dictionary"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid. Example 2: Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid. Constraints: The number of nodes in the tree is in the range [2, 1000]. -231 <= Node.val <= 231 - 1 Follow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?",
        "title": "Recover Binary Search Tree"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example 1: Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 200 board[i][j] is 'X' or 'O'.",
        "title": "Surrounded Regions"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return \"No solution\" if there is no solution for the equation, or \"Infinite solutions\" if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer. Example 1: Input: equation = \"x+5-3+x=6+x-2\" Output: \"x=2\" Example 2: Input: equation = \"x=x\" Output: \"Infinite solutions\" Example 3: Input: equation = \"2x=x\" Output: \"x=0\" Constraints: 3 <= equation.length <= 1000 equation has exactly one '='. equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable 'x'.",
        "title": "Solve the Equation"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "There is a broken calculator that has the integer startValue on its display initially. In one operation, you can: multiply the number on display by 2, or subtract 1 from the number on display. Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator. Example 1: Input: startValue = 2, target = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}. Example 2: Input: startValue = 5, target = 8 Output: 2 Explanation: Use decrement and then double {5 -> 4 -> 8}. Example 3: Input: startValue = 3, target = 10 Output: 3 Explanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}. Constraints: 1 <= x, y <= 109",
        "title": "Broken Calculator"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. Example 1: Input: n = 4 Output: \"pppz\" Explanation: \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\". Example 2: Input: n = 2 Output: \"xy\" Explanation: \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\". Example 3: Input: n = 7 Output: \"holasss\" Constraints: 1 <= n <= 500",
        "title": "Generate a String With Characters That Have Odd Counts"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted. Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7. Example 1: Input: m = 1, n = 1 Output: 3 Explanation: The three possible colorings are shown in the image above. Example 2: Input: m = 1, n = 2 Output: 6 Explanation: The six possible colorings are shown in the image above. Example 3: Input: m = 5, n = 5 Output: 580986 Constraints: 1 <= m <= 5 1 <= n <= 1000",
        "title": "Painting a Grid With Three Different Colors"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given an array nums of integers, return the length of the longest arithmetic subsequence in nums. Recall that a subsequence of an array nums is a list nums[i1], nums[i2], ..., nums[ik] with 0 <= i1 < i2 < ... < ik <= nums.length - 1, and that a sequence seq is arithmetic if seq[i+1] - seq[i] are all the same value (for 0 <= i < seq.length - 1). Example 1: Input: nums = [3,6,9,12] Output: 4 Explanation: The whole array is an arithmetic sequence with steps of length = 3. Example 2: Input: nums = [9,4,7,2,10] Output: 3 Explanation: The longest arithmetic subsequence is [4,7,10]. Example 3: Input: nums = [20,1,15,3,10,5,8] Output: 4 Explanation: The longest arithmetic subsequence is [20,15,10,5]. Constraints: 2 <= nums.length <= 1000 0 <= nums[i] <= 500",
        "title": "Longest Arithmetic Subsequence"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them. A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s. Example 1: Input: str1 = \"abac\", str2 = \"cab\" Output: \"cabac\" Explanation: str1 = \"abac\" is a subsequence of \"cabac\" because we can delete the first \"c\". str2 = \"cab\" is a subsequence of \"cabac\" because we can delete the last \"ac\". The answer provided is the shortest such string that satisfies these properties. Example 2: Input: str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\" Output: \"aaaaaaaa\" Constraints: 1 <= str1.length, str2.length <= 1000 str1 and str2 consist of lowercase English letters.",
        "title": "Shortest Common Supersequence "
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string text. You can swap two of the characters in the text. Return the length of the longest substring with repeated characters. Example 1: Input: text = \"ababa\" Output: 3 Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\" with length 3. Example 2: Input: text = \"aaabaaa\" Output: 6 Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\" with length 6. Example 3: Input: text = \"aaaaa\" Output: 5 Explanation: No need to swap, longest repeated character substring is \"aaaaa\" with length is 5. Constraints: 1 <= text.length <= 2 * 104 text consist of lowercase English characters only.",
        "title": "Swap For Longest Repeated Character Substring"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points. Return the maximum points you can get. Example 1: Input: boxes = [1,3,2,2,2,3,4,3,1] Output: 23 Explanation: [1, 3, 2, 2, 2, 3, 4, 3, 1] ----> [1, 3, 3, 4, 3, 1] (3*3=9 points) ----> [1, 3, 3, 3, 1] (1*1=1 points) ----> [1, 1] (3*3=9 points) ----> [] (2*2=4 points) Example 2: Input: boxes = [1,1,1] Output: 9 Example 3: Input: boxes = [1] Output: 1 Constraints: 1 <= boxes.length <= 100 1 <= boxes[i] <= 100",
        "title": "Remove Boxes"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome. Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right]. Example 1: Input: left = \"4\", right = \"1000\" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome. Example 2: Input: left = \"1\", right = \"2\" Output: 1 Constraints: 1 <= left.length, right.length <= 18 left and right consist of only digits. left and right cannot have leading zeros. left and right represent integers in the range [1, 1018 - 1]. left is less than or equal to right.",
        "title": "Super Palindromes"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them. A grid is said to be valid if all the cells above the main diagonal are zeros. Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid. The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n). Example 1: Input: grid = [[0,0,1],[1,1,0],[1,0,0]] Output: 3 Example 2: Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]] Output: -1 Explanation: All rows are similar, swaps have no effect on the grid. Example 3: Input: grid = [[1,0,0],[1,1,0],[1,1,1]] Output: 0 Constraints: n == grid.length == grid[i].length 1 <= n <= 200 grid[i][j] is either 0 or 1",
        "title": "Minimum Swaps to Arrange a Binary Grid"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints: 1 <= nums1.length, nums2.length <= 1000 0 <= nums1[i], nums2[i] <= 1000 Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
        "title": "Intersection of Two Arrays II"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [7,2,4,3], l2 = [5,6,4] Output: [7,8,0,7] Example 2: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [8,0,7] Example 3: Input: l1 = [0], l2 = [0] Output: [0] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Follow up: Could you solve it without reversing the input lists?",
        "title": "Add Two Numbers II"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A substring is a contiguous (non-empty) sequence of characters within a string. A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given a string word, return the number of vowel substrings in word. Example 1: Input: word = \"aeiouu\" Output: 2 Explanation: The vowel substrings of word are as follows (underlined): - \"aeiouu\" - \"aeiouu\" Example 2: Input: word = \"unicornarihan\" Output: 0 Explanation: Not all 5 vowels are present, so there are no vowel substrings. Example 3: Input: word = \"cuaieuouac\" Output: 7 Explanation: The vowel substrings of word are as follows (underlined): - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" - \"cuaieuouac\" Constraints: 1 <= word.length <= 100 word consists of lowercase English letters only.",
        "title": "Count Vowel Substrings of a String"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the maximum number of ocurrences of any substring under the following rules: The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive. Example 1: Input: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4 Output: 2 Explanation: Substring \"aab\" has 2 ocurrences in the original string. It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize). Example 2: Input: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3 Output: 2 Explanation: Substring \"aaa\" occur 2 times in the string. It can overlap. Constraints: 1 <= s.length <= 105 1 <= maxLetters <= 26 1 <= minSize <= maxSize <= min(26, s.length) s consists of only lowercase English letters.",
        "title": "Maximum Number of Occurrences of a Substring"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an m x n binary matrix matrix. You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa). Return the maximum number of rows that have all values equal after some number of flips. Example 1: Input: matrix = [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal. Example 2: Input: matrix = [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values. Example 3: Input: matrix = [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values. Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 300 matrix[i][j] is either 0 or 1.",
        "title": "Flip Columns For Maximum Number of Equal Rows"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1]. Example 1: Input: nums = [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3. Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element 4. Example 2: Input: nums = [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly increasing. Constraints: 1 <= nums.length <= 104 -109 <= nums[i] <= 109",
        "title": "Longest Continuous Increasing Subsequence"
    },
    {
        "class": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. An integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0. You may return the answer in any order. In your answer, each value should occur at most once. Example 1: Input: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation: 2 = 20 + 30 3 = 21 + 30 4 = 20 + 31 5 = 21 + 31 7 = 22 + 31 9 = 23 + 30 10 = 20 + 32 Example 2: Input: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14] Constraints: 1 <= x, y <= 100 0 <= bound <= 106",
        "title": "Powerful Integers"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path. Example 1: Input: grid = [[0,1],[1,0]] Output: 2 Example 2: Input: grid = [[0,0,0],[1,1,0],[1,1,0]] Output: 4 Example 3: Input: grid = [[1,0,0],[1,1,0],[1,1,0]] Output: -1 Constraints: n == grid.length n == grid[i].length 1 <= n <= 100 grid[i][j] is 0 or 1",
        "title": "Shortest Path in Binary Matrix"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.\r \r A string is homogenous if all the characters of the string are the same.\r \r A substring is a contiguous sequence of characters within a string.\r \r \r Example 1:\r \r \r Input: s = \"abbcccaa\"\r Output: 13\r Explanation: The homogenous substrings are listed as below:\r \"a\" appears 3 times.\r \"aa\" appears 1 time.\r \"b\" appears 2 times.\r \"bb\" appears 1 time.\r \"c\" appears 3 times.\r \"cc\" appears 2 times.\r \"ccc\" appears 1 time.\r 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.\r \r Example 2:\r \r \r Input: s = \"xy\"\r Output: 2\r Explanation: The homogenous substrings are \"x\" and \"y\".\r \r Example 3:\r \r \r Input: s = \"zzzzz\"\r Output: 15\r \r \r \r Constraints:\r \r \r 1 <= s.length <= 105\r s consists of lowercase letters.",
        "title": "Count Number of Homogenous Substrings"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise. Example 1: Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5. Example 2: Input: root1 = [], root2 = [] Output: true Example 3: Input: root1 = [], root2 = [1] Output: false Constraints: The number of nodes in each tree is in the range [0, 100]. Each tree will have unique node values in the range [0, 99].",
        "title": "Flip Equivalent Binary Trees"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums. The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers. Example 1: Input: nums = [2,5,6,9,10] Output: 2 Explanation: The smallest number in nums is 2. The largest number in nums is 10. The greatest common divisor of 2 and 10 is 2. Example 2: Input: nums = [7,5,6,8,3] Output: 1 Explanation: The smallest number in nums is 3. The largest number in nums is 8. The greatest common divisor of 3 and 8 is 1. Example 3: Input: nums = [3,3] Output: 3 Explanation: The smallest number in nums is 3. The largest number in nums is 3. The greatest common divisor of 3 and 3 is 3. Constraints: 2 <= nums.length <= 1000 1 <= nums[i] <= 1000",
        "title": "Find Greatest Common Divisor of Array"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7. A subsequence of a string is obtained by deleting zero or more characters from the string. A sequence is palindromic if it is equal to the sequence reversed. Two sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi. Example 1: Input: s = \"bccb\" Output: 6 Explanation: The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice. Example 2: Input: s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\" Output: 104860361 Explanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7. Constraints: 1 <= s.length <= 1000 s[i] is either 'a', 'b', 'c', or 'd'.",
        "title": "Count Different Palindromic Subsequences"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 <= s.length <= 105 s[i] is either'(' , ')', or lowercase English letter.",
        "title": "Minimum Remove to Make Valid Parentheses"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled: i + minJump <= j <= min(i + maxJump, s.length - 1), and s[j] == '0'. Return true if you can reach index s.length - 1 in s, or false otherwise. Example 1: Input: s = \"011010\", minJump = 2, maxJump = 3 Output: true Explanation: In the first step, move from index 0 to index 3. In the second step, move from index 3 to index 5. Example 2: Input: s = \"01101110\", minJump = 2, maxJump = 3 Output: false Constraints: 2 <= s.length <= 105 s[i] is either '0' or '1'. s[0] == '0' 1 <= minJump <= maxJump < s.length",
        "title": "Jump Game VII"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer. Example 1: Input: root = [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 Example 2: Input: root = [0] Output: 0 Constraints: The number of nodes in the tree is in the range [1, 1000]. Node.val is 0 or 1.",
        "title": "Sum of Root To Leaf Binary Numbers"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. Example 1: Input [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"] [[], [1], [2], [1], [3], [2], [2], [2], [2]] Output [null, null, null, true, false, null, true, null, false] Explanation MyHashSet myHashSet = new MyHashSet(); myHashSet.add(1); // set = [1] myHashSet.add(2); // set = [1, 2] myHashSet.contains(1); // return True myHashSet.contains(3); // return False, (not found) myHashSet.add(2); // set = [1, 2] myHashSet.contains(2); // return True myHashSet.remove(2); // set = [1] myHashSet.contains(2); // return False, (already removed) Constraints: 0 <= key <= 106 At most 104 calls will be made to add, remove, and contains.",
        "title": "Design HashSet"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false Example 3: Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3] Output: false Constraints: rect1.length == 4 rect2.length == 4 -109 <= rec1[i], rec2[i] <= 109 rec1 and rec2 represent a valid rectangle with a non-zero area.",
        "title": "Rectangle Overlap"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 1 <= k <= nums.length",
        "title": "Sliding Window Maximum"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, determine if it is valid. A string s is valid if, starting with an empty string t = \"\", you can transform t into s after performing the following operation any number of times: Insert string \"abc\" into any position in t. More formally, t becomes tleft + \"abc\" + tright, where t == tleft + tright. Note that tleft and tright may be empty. Return true if s is a valid string, otherwise, return false. Example 1: Input: s = \"aabcbc\" Output: true Explanation: \"\" -> \"abc\" -> \"aabcbc\" Thus, \"aabcbc\" is valid. Example 2: Input: s = \"abcabcababcc\" Output: true Explanation: \"\" -> \"abc\" -> \"abcabc\" -> \"abcabcabc\" -> \"abcabcababcc\" Thus, \"abcabcababcc\" is valid. Example 3: Input: s = \"abccba\" Output: false Explanation: It is impossible to get \"abccba\" using the operation. Constraints: 1 <= s.length <= 2 * 104 s consists of letters 'a', 'b', and 'c'",
        "title": "Check If Word Is Valid After Substitutions"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n). Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams). Example 1: Input: rating = [2,5,3,4,1] Output: 3 Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2: Input: rating = [2,1,3] Output: 0 Explanation: We can't form any team given the conditions. Example 3: Input: rating = [1,2,3,4] Output: 4 Constraints: n == rating.length 3 <= n <= 1000 1 <= rating[i] <= 105 All the integers in rating are unique.",
        "title": "Count Number of Teams"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. Example 1: Input: s = \"book\" Output: true Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. Example 2: Input: s = \"textbook\" Output: false Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. Constraints: 2 <= s.length <= 1000 s.length is even. s consists of uppercase and lowercase letters.",
        "title": "Determine if String Halves Are Alike"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.. Return the lexicographically smallest string you could have after applying the mentioned step any number of moves. Example 1: Input: s = \"cba\", k = 1 Output: \"acb\" Explanation: In the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\". In the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\". Example 2: Input: s = \"baaca\", k = 3 Output: \"aaabc\" Explanation: In the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\". In the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\". Constraints: 1 <= k <= s.length <= 1000 s consist of lowercase English letters.",
        "title": "Orderly Queue"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a strange printer with the following two special requirements: On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle. Once the printer has used a color for the above operation, the same color cannot be used again. You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid. Return true if it is possible to print the matrix targetGrid, otherwise, return false. Example 1: Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]] Output: true Example 2: Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]] Output: true Example 3: Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]] Output: false Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns. Constraints: m == targetGrid.length n == targetGrid[i].length 1 <= m, n <= 60 1 <= targetGrid[row][col] <= 60",
        "title": "Strange Printer II"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: nums = [1,2,2,3,1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2: Input: nums = [1,2,2,3,1,4,2] Output: 6 Explanation: The degree is 3 because the element 2 is repeated 3 times. So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6. Constraints: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.",
        "title": "Degree of an Array"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5. Example 1: Input: nums = [3,5,2,6], k = 2 Output: [2,6] Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive. Example 2: Input: nums = [2,4,3,3,5,4,9,6], k = 4 Output: [2,3,3,4] Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109 1 <= k <= nums.length",
        "title": "Find the Most Competitive Subsequence"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two. You can pick any two different foods to make a good meal. Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b item of food, return the number of different good meals you can make from this list modulo 109 + 7. Note that items with different indices are considered different even if they have the same deliciousness value. Example 1: Input: deliciousness = [1,3,5,7,9] Output: 4 Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9). Their respective sums are 4, 8, 8, and 16, all of which are powers of 2. Example 2: Input: deliciousness = [1,1,1,3,3,3,7] Output: 15 Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways. Constraints: 1 <= deliciousness.length <= 105 0 <= deliciousness[i] <= 220",
        "title": "Count Good Meals"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation. Example 1: Input: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]. Example 2: Input: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums. Example 3: Input: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums. Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100",
        "title": "Check if Array Is Sorted and Rotated"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "You are given an integer array nums and an integer k. For each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after changing the values at each index. Example 1: Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: Input: nums = [1,3,6], k = 3 Output: 3 Explanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3. Constraints: 1 <= nums.length <= 104 0 <= nums[i] <= 104 0 <= k <= 104",
        "title": "Smallest Range II"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti]. For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where answer[i] is the answer to the ith query. Example 1: Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2: Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] Output: [8,0,4,4] Constraints: 1 <= arr.length, queries.length <= 3 * 104 1 <= arr[i] <= 109 queries[i].length == 2 0 <= lefti <= righti < arr.length",
        "title": "XOR Queries of a Subarray"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. Example 1: Input: s = \"tree\" Output: \"eert\" Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer. Example 2: Input: s = \"cccaaa\" Output: \"aaaccc\" Explanation: Both 'c' and 'a' appear three times, so both \"cccaaa\" and \"aaaccc\" are valid answers. Note that \"cacaca\" is incorrect, as the same characters must be together. Example 3: Input: s = \"Aabb\" Output: \"bbAa\" Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters. Constraints: 1 <= s.length <= 5 * 105 s consists of uppercase and lowercase English letters and digits.",
        "title": "Sort Characters By Frequency"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. Example 1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2: Input: arr = [1,7], k = 1 Output: [1,7] Constraints: 2 <= arr.length <= 1000 1 <= arr[i] <= 3 * 104 arr[0] == 1 arr[i] is a prime number for i > 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 <= k <= arr.length * (arr.length - 1) / 2",
        "title": "K-th Smallest Prime Fraction"
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters. For example, \"/leetcode\" and \"/leetcode/problems\" are valid paths while an empty string and \"/\" are not. Example 1: Input: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"] Output: [\"/a\",\"/c/d\",\"/c/f\"] Explanation: Folders \"/a/b/\" is a subfolder of \"/a\" and \"/c/d/e\" is inside of folder \"/c/d\" in our filesystem. Example 2: Input: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"] Output: [\"/a\"] Explanation: Folders \"/a/b/c\" and \"/a/b/d/\" will be removed because they are subfolders of \"/a\". Example 3: Input: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] Output: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] Constraints: 1 <= folder.length <= 4 * 104 2 <= folder[i].length <= 100 folder[i] contains only lowercase letters and '/'. folder[i] always starts with the character '/'. Each folder name is unique.",
        "title": "Remove Sub-Folders from the Filesystem"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given a binary tree root and a linked list with head as the first node. Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False. In this context downward path means a path that starts at some node and goes downwards. Example 1: Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: true Explanation: Nodes in blue form a subpath in the binary Tree. Example 2: Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: true Example 3: Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: false Explanation: There is no path in the binary tree that contains all the elements of the linked list from head. Constraints: The number of nodes in the tree will be in the range [1, 2500]. The number of nodes in the list will be in the range [1, 100]. 1 <= Node.val <= 100 for each node in the linked list and binary tree.",
        "title": "Linked List in Binary Tree"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other. Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1. A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent. Example 1: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown. The first move swaps the first and second column. The second move swaps the second and third row. Example 2: Input: board = [[0,1],[1,0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard. Example 3: Input: board = [[1,0],[1,0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard. Constraints: n == board.length n == board[i].length 2 <= n <= 30 board[i][j] is either 0 or 1.",
        "title": "Transform to Chessboard"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 400",
        "title": "House Robber"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure : let x be the sum of all elements currently in your array. choose index i, such that 0 <= i < n and set the value of arr at index i to x. You may repeat this procedure as many times as needed. Return true if it is possible to construct the target array from arr, otherwise, return false. Example 1: Input: target = [9,3,5] Output: true Explanation: Start with arr = [1, 1, 1] [1, 1, 1], sum = 3 choose index 1 [1, 3, 1], sum = 5 choose index 2 [1, 3, 5], sum = 9 choose index 0 [9, 3, 5] Done Example 2: Input: target = [1,1,1,2] Output: false Explanation: Impossible to create target array from [1,1,1,1]. Example 3: Input: target = [8,5] Output: true Constraints: n == target.length 1 <= n <= 5 * 104 1 <= target[i] <= 109",
        "title": "Construct Target Array With Multiple Sums"
    },
    {
        "class": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. Example 1: Input: nums = [23,2,4,6,7], k = 6 Output: true Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2: Input: nums = [23,2,6,4,7], k = 6 Output: true Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3: Input: nums = [23,2,6,4,7], k = 13 Output: false Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109 0 <= sum(nums[i]) <= 231 - 1 1 <= k <= 231 - 1",
        "title": "Continuous Subarray Sum"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j]. For example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\". Example 1: Input: s = \"ab\", goal = \"ba\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal. Example 2: Input: s = \"ab\", goal = \"ab\" Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal. Example 3: Input: s = \"aa\", goal = \"aa\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal. Constraints: 1 <= s.length, goal.length <= 2 * 104 s and goal consist of lowercase letters.",
        "title": "Buddy Strings"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ],
        "content": "Given two strings s and t, transform string s into string t using the following operation any number of times: Choose a non-empty substring in s and sort it in place so the characters are in ascending order. For example, applying the operation on the underlined substring in \"14234\" results in \"12344\". Return true if it is possible to transform s into t. Otherwise, return false. A substring is a contiguous sequence of characters within a string. Example 1: Input: s = \"84532\", t = \"34852\" Output: true Explanation: You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" Example 2: Input: s = \"34521\", t = \"23415\" Output: true Explanation: You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" Example 3: Input: s = \"12345\", t = \"12435\" Output: false Constraints: s.length == t.length 1 <= s.length <= 105 s and t consist of only digits.",
        "title": "Check If String Is Transformable With Substring Sort Operations"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: 'a' maps to \".-\", 'b' maps to \"-...\", 'c' maps to \"-.-.\", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. Example 1: Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" There are 2 different transformations: \"--...-.\" and \"--...--.\". Example 2: Input: words = [\"a\"] Output: 1 Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 12 words[i] consists of lowercase English letters.",
        "title": "Unique Morse Code Words"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string of digits num, such as \"123456579\". We can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list f of non-negative integers such that: 0 <= f[i] < 231, (that is, each integer fits in a 32-bit signed integer type), f.length >= 3, and f[i] + f[i + 1] == f[i + 2] for all 0 <= i < f.length - 2. Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from num, or return [] if it cannot be done. Example 1: Input: num = \"1101111\" Output: [11,0,11,11] Explanation: The output [110, 1, 111] would also be accepted. Example 2: Input: num = \"112358130\" Output: [] Explanation: The task is impossible. Example 3: Input: num = \"0123\" Output: [] Explanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid. Constraints: 1 <= num.length <= 200 num contains only digits.",
        "title": "Split Array into Fibonacci Sequence"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].\r \r Here, board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"], as shown in the diagram below.\r \r \r \r We may make the following moves:\r \r \r 'U' moves our position up one row, if the position exists on the board;\r 'D' moves our position down one row, if the position exists on the board;\r 'L' moves our position left one column, if the position exists on the board;\r 'R' moves our position right one column, if the position exists on the board;\r '!' adds the character board[r][c] at our current position (r, c) to the answer.\r \r \r (Here, the only positions that exist on the board are positions with letters on them.)\r \r Return a sequence of moves that makes our answer equal to target in the minimum number of moves. You may return any path that does so.\r \r \r Example 1:\r Input: target = \"leet\"\r Output: \"DDR!UURRR!!DDD!\"\r Example 2:\r Input: target = \"code\"\r Output: \"RR!DDRR!UUL!R!\"\r \r \r Constraints:\r \r \r 1 <= target.length <= 100\r target consists only of English lowercase letters.",
        "title": "Alphabet Board Path"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = \"dcce\" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2. You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words. Return an integer array answer, where each answer[i] is the answer to the ith query. Example 1: Input: queries = [\"cbd\"], words = [\"zaaaz\"] Output: [1] Explanation: On the first query we have f(\"cbd\") = 1, f(\"zaaaz\") = 3 so f(\"cbd\") < f(\"zaaaz\"). Example 2: Input: queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: [1,2] Explanation: On the first query only f(\"bbb\") < f(\"aaaa\"). On the second query both f(\"aaa\") and f(\"aaaa\") are both > f(\"cc\"). Constraints: 1 <= queries.length <= 2000 1 <= words.length <= 2000 1 <= queries[i].length, words[i].length <= 10 queries[i][j], words[i][j] consist of lowercase English letters.",
        "title": "Compare Strings by Frequency of the Smallest Character"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k. The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all the coordinates of matrix. Example 1: Input: matrix = [[5,2],[1,6]], k = 1 Output: 7 Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. Example 2: Input: matrix = [[5,2],[1,6]], k = 2 Output: 5 Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. Example 3: Input: matrix = [[5,2],[1,6]], k = 3 Output: 4 Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 1000 0 <= matrix[i][j] <= 106 1 <= k <= m * n",
        "title": "Find Kth Largest XOR Coordinate Value"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A string is considered beautiful if it satisfies the following conditions: Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it. The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.). For example, strings \"aeiou\" and \"aaaaaaeiiiioou\" are considered beautiful, but \"uaeio\", \"aeoiu\", and \"aaaeeeooo\" are not beautiful. Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0. A substring is a contiguous sequence of characters in a string. Example 1: Input: word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\" Output: 13 Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13. Example 2: Input: word = \"aeeeiiiioooauuuaeiou\" Output: 5 Explanation: The longest beautiful substring in word is \"aeiou\" of length 5. Example 3: Input: word = \"a\" Output: 0 Explanation: There is no beautiful substring, so return 0. Constraints: 1 <= word.length <= 5 * 105 word consists of characters 'a', 'e', 'i', 'o', and 'u'.",
        "title": "Longest Substring Of All Vowels in Order"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"ababbb\" Output: 9 Explanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Example 2: Input: s = \"zaaaxbbby\" Output: 9 Explanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Constraints: 2 <= s.length <= 105 s consists of lowercase English letters.",
        "title": "Maximum Product of the Length of Two Palindromic Substrings"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times.",
        "title": "Find Minimum in Rotated Sorted Array"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized. Return the minimum possible maximum working time of any assignment. Example 1: Input: jobs = [3,2,3], k = 3 Output: 3 Explanation: By assigning each person one job, the maximum time is 3. Example 2: Input: jobs = [1,2,4,7,8], k = 2 Output: 11 Explanation: Assign the jobs the following way: Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11) Worker 2: 4, 7 (working time = 4 + 7 = 11) The maximum working time is 11. Constraints: 1 <= k <= jobs.length <= 12 1 <= jobs[i] <= 107",
        "title": "Find Minimum Time to Finish All Jobs"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are playing the following Nim Game with your friend: Initially, there is a heap of stones on the table. You and your friend will alternate taking turns, and you go first. On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. The one who removes the last stone is the winner. Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. Example 1: Input: n = 4 Output: false Explanation: These are the possible outcomes: 1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins. 2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins. 3. You remove 3 stones. Your friend removes the last stone. Your friend wins. In all outcomes, your friend wins. Example 2: Input: n = 1 Output: true Example 3: Input: n = 2 Output: true Constraints: 1 <= n <= 231 - 1",
        "title": "Nim Game"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ],
        "content": "A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time. Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i]. Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation. Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value. Example 1: Input: satisfaction = [-1,-8,0,5,-9] Output: 14 Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time. Example 2: Input: satisfaction = [4,3,2] Output: 20 Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20) Example 3: Input: satisfaction = [-1,-4,-5] Output: 0 Explanation: People do not like the dishes. No dish is prepared. Constraints: n == satisfaction.length 1 <= n <= 500 -1000 <= satisfaction[i] <= 1000",
        "title": "Reducing Dishes"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "A transaction is possibly invalid if: the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city. You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction. Return a list of transactions that are possibly invalid. You may return the answer in any order. Example 1: Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"] Output: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"] Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. Example 2: Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"] Output: [\"alice,50,1200,mtv\"] Example 3: Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"] Output: [\"bob,50,1200,mtv\"] Constraints: transactions.length <= 1000 Each transactions[i] takes the form \"{name},{time},{amount},{city}\" Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10. Each {time} consist of digits, and represent an integer between 0 and 1000. Each {amount} consist of digits, and represent an integer between 0 and 2000.",
        "title": "Invalid Transactions"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -> index 4 -> index 1 -> index 3 index 5 -> index 6 -> index 4 -> index 1 -> index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -> index 4 -> index 1 -> index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0. Constraints: 1 <= arr.length <= 5 * 104 0 <= arr[i] < arr.length 0 <= start < arr.length",
        "title": "Jump Game III"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same. If it cannot be done, return -1. Example 1: Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2] Output: 2 Explanation: The first figure represents the dominoes as given by tops and bottoms: before we do any rotations. If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure. Example 2: Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4] Output: -1 Explanation: In this case, it is not possible to rotate the dominoes to make one row of values equal. Constraints: 2 <= tops.length <= 2 * 104 bottoms.length == tops.length 1 <= tops[i], bottoms[i] <= 6",
        "title": "Minimum Domino Rotations For Equal Row"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Given a m * n matrix seats that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character. Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible.. Students must be placed in seats in good condition. Example 1: Input: seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"], [\".\",\"#\",\"#\",\"#\",\"#\",\".\"], [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]] Output: 4 Explanation: Teacher can place 4 students in available seats so they don't cheat on the exam. Example 2: Input: seats = [[\".\",\"#\"], [\"#\",\"#\"], [\"#\",\".\"], [\"#\",\"#\"], [\".\",\"#\"]] Output: 3 Explanation: Place all students in available seats. Example 3: Input: seats = [[\"#\",\".\",\".\",\".\",\"#\"], [\".\",\"#\",\".\",\"#\",\".\"], [\".\",\".\",\"#\",\".\",\".\"], [\".\",\"#\",\".\",\"#\",\".\"], [\"#\",\".\",\".\",\".\",\"#\"]] Output: 10 Explanation: Place students in available seats in column 1, 3 and 5. Constraints: seats contains only characters '.' and'#'. m == seats.length n == seats[i].length 1 <= m <= 8 1 <= n <= 8",
        "title": "Maximum Students Taking Exam"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0). Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order. Example 1: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]] Output: [0,1,4] Explanation: Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. Person with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]. Example 2: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]] Output: [0,1] Explanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1]. Example 3: Input: favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]] Output: [0,1,2,3] Constraints: 1 <= favoriteCompanies.length <= 100 1 <= favoriteCompanies[i].length <= 500 1 <= favoriteCompanies[i][j].length <= 20 All strings in favoriteCompanies[i] are distinct. All lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j]. All strings consist of lowercase English letters only.",
        "title": "People Whose List of Favorite Companies Is Not a Subset of Another List"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones). A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]. If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0. Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index. Example 1: Input: nums = [2,3,-1,8,4] Output: 3 Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4 The sum of the numbers after index 3 is: 4 = 4 Example 2: Input: nums = [1,-1,4] Output: 2 Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0 The sum of the numbers after index 2 is: 0 Example 3: Input: nums = [2,5] Output: -1 Explanation: There is no valid middleIndex. Constraints: 1 <= nums.length <= 100 -1000 <= nums[i] <= 1000 Note: This question is the same as 724: https://leetcode.com/problems/find-pivot-index/",
        "title": "Find the Middle Index in Array"
    },
    {
        "class": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string s, return the number of unique palindromes of length three that are a subsequence of s. Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once. A palindrome is a string that reads the same forwards and backwards. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". Example 1: Input: s = \"aabca\" Output: 3 Explanation: The 3 palindromic subsequences of length 3 are: - \"aba\" (subsequence of \"aabca\") - \"aaa\" (subsequence of \"aabca\") - \"aca\" (subsequence of \"aabca\") Example 2: Input: s = \"adc\" Output: 0 Explanation: There are no palindromic subsequences of length 3 in \"adc\". Example 3: Input: s = \"bbcbaba\" Output: 4 Explanation: The 4 palindromic subsequences of length 3 are: - \"bbb\" (subsequence of \"bbcbaba\") - \"bcb\" (subsequence of \"bbcbaba\") - \"bab\" (subsequence of \"bbcbaba\") - \"aba\" (subsequence of \"bbcbaba\") Constraints: 3 <= s.length <= 105 s consists of only lowercase English letters.",
        "title": "Unique Length-3 Palindromic Subsequences"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array nums and an integer k. In one operation, you can choose any index i where 0 <= i < nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after applying the mentioned operation at most once for each index in it. Example 1: Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: Input: nums = [1,3,6], k = 3 Output: 0 Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0. Constraints: 1 <= nums.length <= 104 0 <= nums[i] <= 104 0 <= k <= 104",
        "title": "Smallest Range I"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty. Return the maximum amount of gold you can collect under the conditions: Every time you are located in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can't visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold. Example 1: Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 -> 8 -> 7. Example 2: Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] Output: 28 Explanation: [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 15 0 <= grid[i][j] <= 100 There are at most 25 cells containing gold.",
        "title": "Path with Maximum Gold"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word. A substring is a contiguous sequence of characters within a string. Example 1: Input: patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\" Output: 3 Explanation: - \"a\" appears as a substring in \"abc\". - \"abc\" appears as a substring in \"abc\". - \"bc\" appears as a substring in \"abc\". - \"d\" does not appear as a substring in \"abc\". 3 of the strings in patterns appear as a substring in word. Example 2: Input: patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\" Output: 2 Explanation: - \"a\" appears as a substring in \"aaaaabbbbb\". - \"b\" appears as a substring in \"aaaaabbbbb\". - \"c\" does not appear as a substring in \"aaaaabbbbb\". 2 of the strings in patterns appear as a substring in word. Example 3: Input: patterns = [\"a\",\"a\",\"a\"], word = \"ab\" Output: 3 Explanation: Each of the patterns appears as a substring in word \"ab\". Constraints: 1 <= patterns.length <= 100 1 <= patterns[i].length <= 100 1 <= word.length <= 100 patterns[i] and word consist of lowercase English letters.",
        "title": "Number of Strings That Appear as Substrings in Word"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "content": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique. The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank: The 1st place athlete's rank is \"Gold Medal\". The 2nd place athlete's rank is \"Silver Medal\". The 3rd place athlete's rank is \"Bronze Medal\". For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\"). Return an array answer of size n where answer[i] is the rank of the ith athlete. Example 1: Input: score = [5,4,3,2,1] Output: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2: Input: score = [10,3,8,9,4] Output: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints: n == score.length 1 <= n <= 104 0 <= score[i] <= 106 All the values in score are unique.",
        "title": "Relative Ranks"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '\u2205', where '\u2205' is defined as the blank character which is less than any other character (More info). Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in words[i] and order are English lowercase letters.",
        "title": "Verifying an Alien Dictionary"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: Solution(ListNode head) Initializes the object with the head of the singly-linked list head. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen. Example 1: Input [\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 3, 2, 2, 3] Explanation Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // return 1 solution.getRandom(); // return 3 solution.getRandom(); // return 2 solution.getRandom(); // return 2 solution.getRandom(); // return 3 // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. Constraints: The number of nodes in the linked list will be in the range [1, 104]. -104 <= Node.val <= 104 At most 104 calls will be made to getRandom. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?",
        "title": "Linked List Random Node"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed). There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. Return that maximum distance to the closest person. Example 1: Input: seats = [1,0,0,0,1,0,1] Output: 2 Explanation: If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2. Example 2: Input: seats = [1,0,0,0] Output: 3 Explanation: If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3. Example 3: Input: seats = [0,1] Output: 1 Constraints: 2 <= seats.length <= 2 * 104 seats[i] is 0 or 1. At least one seat is empty. At least one seat is occupied.",
        "title": "Maximize Distance to Closest Person"
    },
    {
        "class": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input: expression = \"-1/2+1/2\" Output: \"0/1\" Example 2: Input: expression = \"-1/2+1/2+1/3\" Output: \"1/3\" Example 3: Input: expression = \"1/3-1/2\" Output: \"-1/6\" Constraints: The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1, 10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.",
        "title": "Fraction Addition and Subtraction"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums, return the number of AND triples. An AND triple is a triple of indices (i, j, k) such that: 0 <= i < nums.length 0 <= j < nums.length 0 <= k < nums.length nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator. Example 1: Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 & 2 & 1 (i=0, j=1, k=0) : 2 & 1 & 2 (i=0, j=1, k=1) : 2 & 1 & 1 (i=0, j=1, k=2) : 2 & 1 & 3 (i=0, j=2, k=1) : 2 & 3 & 1 (i=1, j=0, k=0) : 1 & 2 & 2 (i=1, j=0, k=1) : 1 & 2 & 1 (i=1, j=0, k=2) : 1 & 2 & 3 (i=1, j=1, k=0) : 1 & 1 & 2 (i=1, j=2, k=0) : 1 & 3 & 2 (i=2, j=0, k=1) : 3 & 2 & 1 (i=2, j=1, k=0) : 3 & 1 & 2 Example 2: Input: nums = [0,0,0] Output: 27 Constraints: 1 <= nums.length <= 1000 0 <= nums[i] < 216",
        "title": "Triples with Bitwise AND Equal To Zero"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array. Return the length of the smallest subarray that you need to remove, or -1 if it's impossible. A subarray is defined as a contiguous block of elements in the array. Example 1: Input: nums = [3,1,4,2], p = 6 Output: 1 Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6. Example 2: Input: nums = [6,3,5,2], p = 9 Output: 2 Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9. Example 3: Input: nums = [1,2,3], p = 3 Output: 0 Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 109 1 <= p <= 109",
        "title": "Make Sum Divisible by P"
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "The Leetcode file system keeps a log each time some user performs a change folder operation. The operations are described below: \"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). \"./\" : Remain in the same folder. \"x/\" : Move to the child folder named x (This folder is guaranteed to always exist). You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed. Return the minimum number of operations needed to go back to the main folder after the change folder operations. Example 1: Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"] Output: 2 Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder. Example 2: Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"] Output: 3 Example 3: Input: logs = [\"d1/\",\"../\",\"../\",\"../\"] Output: 0 Constraints: 1 <= logs.length <= 103 2 <= logs[i].length <= 10 logs[i] contains lowercase English letters, digits, '.', and '/'. logs[i] follows the format described in the statement. Folder names consist of lowercase English letters and digits.",
        "title": "Crawler Log Folder"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ],
        "content": "You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized. Return this maximum sum. Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1. Example 1: Input: events = [[1,3,2],[4,5,2],[2,4,3]] Output: 4 Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4. Example 2: Input: events = [[1,3,2],[4,5,2],[1,5,5]] Output: 5 Explanation: Choose event 2 for a sum of 5. Example 3: Input: events = [[1,5,3],[1,5,1],[6,6,5]] Output: 8 Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8. Constraints: 2 <= events.length <= 105 events[i].length == 3 1 <= startTimei <= endTimei <= 109 1 <= valuei <= 106",
        "title": "Two Best Non-Overlapping Events"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0. Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0. An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's. Example 1: Input: n = 5, mines = [[4,2]] Output: 2 Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown. Example 2: Input: n = 1, mines = [[0,0]] Output: 0 Explanation: There is no plus sign, so return 0. Constraints: 1 <= n <= 500 1 <= mines.length <= 5000 0 <= xi, yi < n All the pairs (xi, yi) are unique.",
        "title": "Largest Plus Sign"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design a data structure to find the frequency of a given value in a given subarray. The frequency of a value in a subarray is the number of occurrences of that value in the subarray. Implement the RangeFreqQuery class: RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr. int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left...right]. A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive). Example 1: Input [\"RangeFreqQuery\", \"query\", \"query\"] [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]] Output [null, 1, 2] Explanation RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]); rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4] rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array. Constraints: 1 <= arr.length <= 105 1 <= arr[i], value <= 104 0 <= left <= right < arr.length At most 105 calls will be made to query",
        "title": "Range Frequency Queries"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array arr of distinct integers and an integer k. A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds. Return the integer which will win the game. It is guaranteed that there will be a winner of the game. Example 1: Input: arr = [2,1,3,5,4,6,7], k = 2 Output: 5 Explanation: Let's see the rounds of the game: Round | arr | winner | win_count 1 | [2,1,3,5,4,6,7] | 2 | 1 2 | [2,3,5,4,6,7,1] | 3 | 1 3 | [3,5,4,6,7,1,2] | 5 | 1 4 | [5,4,6,7,1,2,3] | 5 | 2 So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games. Example 2: Input: arr = [3,2,1], k = 10 Output: 3 Explanation: 3 will win the first 10 rounds consecutively. Constraints: 2 <= arr.length <= 105 1 <= arr[i] <= 106 arr contains distinct integers. 1 <= k <= 109",
        "title": "Find the Winner of an Array Game"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "Given a sentence text (A sentence is a string of space-separated words) in the following format: First letter is in upper case. Each word in text are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above. Example 1: Input: text = \"Leetcode is cool\" Output: \"Is cool leetcode\" Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4. Output is ordered by length and the new first word starts with capital letter. Example 2: Input: text = \"Keep calm and code on\" Output: \"On and keep calm code\" Explanation: Output is ordered as follows: \"On\" 2 letters. \"and\" 3 letters. \"keep\" 4 letters in case of tie order by position in original text. \"calm\" 4 letters. \"code\" 4 letters. Example 3: Input: text = \"To be or not to be\" Output: \"To be or to be not\" Constraints: text begins with a capital letter and then contains lowercase letters and single space between words. 1 <= text.length <= 10^5",
        "title": "Rearrange Words in a Sentence"
    },
    {
        "class": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given an equation, represented by words on the left side and the result on the right side. You need to check if the equation is solvable under the following rules: Each character is decoded as one digit (0 - 9). Every pair of different characters must map to different digits. Each words[i] and result are decoded as one number without leading zeros. Sum of numbers on the left side (words) will equal to the number on the right side (result). Return true if the equation is solvable, otherwise return false. Example 1: Input: words = [\"SEND\",\"MORE\"], result = \"MONEY\" Output: true Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2' Such that: \"SEND\" + \"MORE\" = \"MONEY\" , 9567 + 1085 = 10652 Example 2: Input: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\" Output: true Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4 Such that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" , 650 + 68782 + 68782 = 138214 Example 3: Input: words = [\"LEET\",\"CODE\"], result = \"POINT\" Output: false Constraints: 2 <= words.length <= 5 1 <= words[i].length, result.length <= 7 words[i], result contain only uppercase English letters. The number of different characters used in the expression is at most 10.",
        "title": "Verbal Arithmetic Puzzle"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates. You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj. For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside. Return an array answer, where answer[j] is the answer to the jth query. Example 1: Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]] Output: [3,2,2] Explanation: The points and circles are shown above. queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle. Example 2: Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]] Output: [2,3,2,4] Explanation: The points and circles are shown above. queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple. Constraints: 1 <= points.length <= 500 points[i].length == 2 0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500 1 <= queries.length <= 500 queries[j].length == 3 0 <= xj, yj <= 500 1 <= rj <= 500 All coordinates are integers. Follow up: Could you find the answer for each query in better complexity than O(n)?",
        "title": "Queries on Number of Points Inside a Circle"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\", while invalid words are \"beefed\" (does not include 'a') and \"based\" (includes 's' which is not in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i]. Example 1: Input: words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for \"aboveyz\" : \"aaaa\" 1 valid word for \"abrodyz\" : \"aaaa\" 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\" 2 valid words for \"absoryz\" : \"aaaa\", \"asas\" 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\" There are no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'. Example 2: Input: words = [\"apple\",\"pleas\",\"please\"], puzzles = [\"aelwxyz\",\"aelpxyz\",\"aelpsxy\",\"saelpxy\",\"xaelpsy\"] Output: [0,1,3,2,0] Constraints: 1 <= words.length <= 105 4 <= words[i].length <= 50 1 <= puzzles.length <= 104 puzzles[i].length == 7 words[i] and puzzles[i] consist of lowercase English letters. Each puzzles[i] does not contain repeated characters.",
        "title": "Number of Valid Words for Each Puzzle"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order. -1000 <= target <= 1000 The tests are generated such that there is exactly one solution.",
        "title": "Two Sum II - Input Array Is Sorted"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied). You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements: Cover all the empty cells. Do not cover any of the occupied cells. We can put as many stamps as we want. Stamps can overlap with each other. Stamps are not allowed to be rotated. Stamps must stay completely inside the grid. Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false. Example 1: Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 Output: true Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. Example 2: Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 Output: false Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 105 1 <= m * n <= 2 * 105 grid[r][c] is either 0 or 1. 1 <= stampHeight, stampWidth <= 105",
        "title": "Stamping the Grid"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination. The instructions are represented as a string, where each character is either: 'H', meaning move horizontally (go right), or 'V', meaning move vertically (go down). Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both \"HHHVV\" and \"HVHVH\" are valid instructions. However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed. Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination. Example 1: Input: destination = [2,3], k = 1 Output: \"HHHVV\" Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows: [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]. Example 2: Input: destination = [2,3], k = 2 Output: \"HHVHV\" Example 3: Input: destination = [2,3], k = 3 Output: \"HHVVH\" Constraints: destination.length == 2 1 <= row, column <= 15 1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b\u200b\u200b\u200b\u200b\u200b.",
        "title": "Kth Smallest Instructions"
    },
    {
        "class": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences, where each sentences[i] represents a single sentence. Return the maximum number of words that appear in a single sentence. Example 1: Input: sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"] Output: 6 Explanation: - The first sentence, \"alice and bob love leetcode\", has 5 words in total. - The second sentence, \"i think so too\", has 4 words in total. - The third sentence, \"this is great thanks very much\", has 6 words in total. Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words. Example 2: Input: sentences = [\"please wait\", \"continue to fight\", \"continue to win\"] Output: 3 Explanation: It is possible that multiple sentences contain the same number of words. In this example, the second and third sentences (underlined) have the same number of words. Constraints: 1 <= sentences.length <= 100 1 <= sentences[i].length <= 100 sentences[i] consists only of lowercase English letters and ' ' only. sentences[i] does not have leading or trailing spaces. All the words in sentences[i] are separated by a single space.",
        "title": "Maximum Number of Words Found in Sentences"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs.\r \r A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.\r \r \r Example 1:\r \r \r Input: nums = [1,4,2,7], low = 2, high = 6\r Output: 6\r Explanation: All nice pairs (i, j) are as follows:\r - (0, 1): nums[0] XOR nums[1] = 5 \r - (0, 2): nums[0] XOR nums[2] = 3\r - (0, 3): nums[0] XOR nums[3] = 6\r - (1, 2): nums[1] XOR nums[2] = 6\r - (1, 3): nums[1] XOR nums[3] = 3\r - (2, 3): nums[2] XOR nums[3] = 5\r \r \r Example 2:\r \r \r Input: nums = [9,8,4,2,1], low = 5, high = 14\r Output: 8\r Explanation: All nice pairs (i, j) are as follows:\r \u200b\u200b\u200b\u200b\u200b - (0, 2): nums[0] XOR nums[2] = 13\r - (0, 3): nums[0] XOR nums[3] = 11\r - (0, 4): nums[0] XOR nums[4] = 8\r - (1, 2): nums[1] XOR nums[2] = 12\r - (1, 3): nums[1] XOR nums[3] = 10\r - (1, 4): nums[1] XOR nums[4] = 9\r - (2, 3): nums[2] XOR nums[3] = 6\r - (2, 4): nums[2] XOR nums[4] = 5\r \r \r Constraints:\r \r \r 1 <= nums.length <= 2 * 104\r 1 <= nums[i] <= 2 * 104\r 1 <= low <= high <= 2 * 104",
        "title": "Count Pairs With XOR in a Range"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\r \r \r It is the empty string, or\r It can be written as AB (A concatenated with B), where A and B are VPS's, or\r It can be written as (A), where A is a VPS.\r \r \r We can similarly define the nesting depth depth(S) of any VPS S as follows:\r \r \r depth(\"\") = 0\r depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's\r depth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\r \r \r For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\r \r \r \r Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).\r \r Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.\r \r Return an answer array (of length seq.length) that encodes such a choice of A and B: answer[i] = 0 if seq[i] is part of A, else answer[i] = 1. Note that even though multiple answers may exist, you may return any of them.\r Example 1: Input: seq = \"(()())\" Output: [0,1,1,1,1,0] Example 2: Input: seq = \"()(())()\" Output: [0,0,0,1,1,0,1,1] Constraints: 1 <= seq.size <= 10000",
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive. The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5. Return the minimum number of moves required to make nums complementary. Example 1: Input: nums = [1,2,4,3], limit = 4 Output: 1 Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed). nums[0] + nums[3] = 1 + 3 = 4. nums[1] + nums[2] = 2 + 2 = 4. nums[2] + nums[1] = 2 + 2 = 4. nums[3] + nums[0] = 3 + 1 = 4. Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary. Example 2: Input: nums = [1,2,2,1], limit = 2 Output: 2 Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit. Example 3: Input: nums = [1,2,1,2], limit = 2 Output: 0 Explanation: nums is already complementary. Constraints: n == nums.length 2 <= n <= 105 1 <= nums[i] <= limit <= 105 n is even.",
        "title": "Minimum Moves to Make Array Complementary"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word. For example, the word \"apple\" becomes \"applema\". If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\". For example, the word \"goat\" becomes \"oatgma\". Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on. Return the final sentence representing the conversion from sentence to Goat Latin. Example 1: Input: sentence = \"I speak Goat Latin\" Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" Example 2: Input: sentence = \"The quick brown fox jumped over the lazy dog\" Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" Constraints: 1 <= sentence.length <= 150 sentence consists of English letters and spaces. sentence has no leading or trailing spaces. All the words in sentence are separated by a single space.",
        "title": "Goat Latin"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1] Return an array of the most visited sectors sorted in ascending order. Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example). Example 1: Input: n = 4, rounds = [1,3,1,2] Output: [1,2] Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows: 1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon) We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once. Example 2: Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2] Output: [2] Example 3: Input: n = 7, rounds = [1,3,5,7] Output: [1,2,3,4,5,6,7] Constraints: 2 <= n <= 100 1 <= m <= 100 rounds.length == m + 1 1 <= rounds[i] <= n rounds[i] != rounds[i + 1] for 0 <= i < m",
        "title": "Most Visited Sector in  a Circular Track"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w). For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%). Example 1: Input [\"Solution\",\"pickIndex\"] [[[1]],[]] Output [null,0] Explanation Solution solution = new Solution([1]); solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w. Example 2: Input [\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"] [[[1,3]],[],[],[],[],[]] Output [null,1,1,1,1,0] Explanation Solution solution = new Solution([1, 3]); solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4. solution.pickIndex(); // return 1 solution.pickIndex(); // return 1 solution.pickIndex(); // return 1 solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4. Since this is a randomization problem, multiple answers are allowed. All of the following outputs can be considered correct: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] ...... and so on. Constraints: 1 <= w.length <= 104 1 <= w[i] <= 105 pickIndex will be called at most 104 times.",
        "title": "Random Pick with Weight"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Write an API that generates fancy sequences using the append, addAll, and multAll operations. Implement the Fancy class: Fancy() Initializes the object with an empty sequence. void append(val) Appends an integer val to the end of the sequence. void addAll(inc) Increments all existing values in the sequence by an integer inc. void multAll(m) Multiplies all existing values in the sequence by an integer m. int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1. Example 1: Input [\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"] [[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]] Output [null, null, null, null, null, 10, null, null, null, 26, 34, 20] Explanation Fancy fancy = new Fancy(); fancy.append(2); // fancy sequence: [2] fancy.addAll(3); // fancy sequence: [2+3] -> [5] fancy.append(7); // fancy sequence: [5, 7] fancy.multAll(2); // fancy sequence: [5*2, 7*2] -> [10, 14] fancy.getIndex(0); // return 10 fancy.addAll(3); // fancy sequence: [10+3, 14+3] -> [13, 17] fancy.append(10); // fancy sequence: [13, 17, 10] fancy.multAll(2); // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20] fancy.getIndex(0); // return 26 fancy.getIndex(1); // return 34 fancy.getIndex(2); // return 20 Constraints: 1 <= val, inc, m <= 100 0 <= idx <= 105 At most 105 calls total will be made to append, addAll, multAll, and getIndex.",
        "title": "Fancy Sequence"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:\r \r \r In the beginning, you have the permutation P=[1,2,3,...,m].\r For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].\r \r \r Return an array containing the result for the given queries.\r \r \r Example 1:\r \r \r Input: queries = [3,1,2,1], m = 5\r Output: [2,1,2,1] \r Explanation: The queries are processed as follow: \r For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \r For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \r For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \r For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \r Therefore, the array containing the result is [2,1,2,1]. \r \r \r Example 2:\r \r \r Input: queries = [4,1,2,2], m = 4\r Output: [3,1,2,0]\r \r \r Example 3:\r \r \r Input: queries = [7,5,5,8,3], m = 8\r Output: [6,5,0,7,5]\r \r \r \r Constraints:\r \r \r 1 <= m <= 10^3\r 1 <= queries.length <= m\r 1 <= queries[i] <= m",
        "title": "Queries on a Permutation With Key"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend. You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day. Return the maximum sum of values that you can receive by attending events. Example 1: Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2 Output: 7 Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7. Example 2: Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2 Output: 10 Explanation: Choose event 2 for a total value of 10. Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events. Example 3: Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3 Output: 9 Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three. Constraints: 1 <= k <= events.length 1 <= k * events.length <= 106 1 <= startDayi <= endDayi <= 109 1 <= valuei <= 106",
        "title": "Maximum Number of Events That Can Be Attended II"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree. Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect: Flip the smallest number of nodes so that the pre-order traversal of the tree matches voyage. Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1]. Example 1: Input: root = [1,2], voyage = [2,1] Output: [-1] Explanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage. Example 2: Input: root = [1,2,3], voyage = [1,3,2] Output: [1] Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage. Example 3: Input: root = [1,2,3], voyage = [1,2,3] Output: [] Explanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped. Constraints: The number of nodes in the tree is n. n == voyage.length 1 <= n <= 100 1 <= Node.val, voyage[i] <= n All the values in the tree are unique. All the values in voyage are unique.",
        "title": "Flip Binary Tree To Match Preorder Traversal"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s. Example 1: Input: s = \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: Input: s = \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: Input: s = \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Constraints: 1 <= s.length <= 105 s[i] is either '(' or ')'. s is a valid parentheses string.",
        "title": "Remove Outermost Parentheses"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties. Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins. Example 1: Input: piles = [5,3,4,5] Output: true Explanation: Alice starts first, and can only take the first 5 or the last 5. Say she takes the first 5, so that the row becomes [3, 4, 5]. If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points. If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alice, so we return true. Example 2: Input: piles = [3,7,2,3] Output: true Constraints: 2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles[i]) is odd.",
        "title": "Stone Game"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. Example 1: Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]] Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000] Explanation: Given: a / b = 2.0, b / c = 3.0 queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? return: [6.0, 0.5, -1.0, 1.0, -1.0 ] Example 2: Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]] Output: [3.75000,0.40000,5.00000,0.20000] Example 3: Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]] Output: [0.50000,2.00000,-1.00000,-1.00000] Constraints: 1 <= equations.length <= 20 equations[i].length == 2 1 <= Ai.length, Bi.length <= 5 values.length == equations.length 0.0 < values[i] <= 20.0 1 <= queries.length <= 20 queries[i].length == 2 1 <= Cj.length, Dj.length <= 5 Ai, Bi, Cj, Dj consist of lower case English letters and digits.",
        "title": "Evaluate Division"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an array arr that represents a permutation of numbers from 1 to n. You have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1. You are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction. Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1. Example 1: Input: arr = [3,5,1,2,4], m = 1 Output: 4 Explanation: Step 1: \"00100\", groups: [\"1\"] Step 2: \"00101\", groups: [\"1\", \"1\"] Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"] Step 4: \"11101\", groups: [\"111\", \"1\"] Step 5: \"11111\", groups: [\"11111\"] The latest step at which there exists a group of size 1 is step 4. Example 2: Input: arr = [3,1,5,4,2], m = 2 Output: -1 Explanation: Step 1: \"00100\", groups: [\"1\"] Step 2: \"10100\", groups: [\"1\", \"1\"] Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"] Step 4: \"10111\", groups: [\"1\", \"111\"] Step 5: \"11111\", groups: [\"11111\"] No group of size 2 exists during any step. Constraints: n == arr.length 1 <= m <= n <= 105 1 <= arr[i] <= n All integers in arr are distinct.",
        "title": "Find Latest Group of Size M"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents: positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1. speedi is the initial speed of the ith car in meters per second. For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet. Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted. Example 1: Input: cars = [[1,2],[2,1],[4,3],[7,2]] Output: [1.00000,-1.00000,3.00000,-1.00000] Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s. Example 2: Input: cars = [[3,4],[5,4],[6,3],[9,1]] Output: [2.00000,1.00000,1.50000,-1.00000] Constraints: 1 <= cars.length <= 105 1 <= positioni, speedi <= 106 positioni < positioni+1",
        "title": "Car Fleet II"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions: The value of the first element in arr must be 1. The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x. There are 2 types of operations that you can perform any number of times: Decrease the value of any element of arr to a smaller positive integer. Rearrange the elements of arr to be in any order. Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions. Example 1: Input: arr = [2,2,1,2,1] Output: 2 Explanation: We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1]. The largest element in arr is 2. Example 2: Input: arr = [100,1,1000] Output: 3 Explanation: One possible way to satisfy the conditions is by doing the following: 1. Rearrange arr so it becomes [1,100,1000]. 2. Decrease the value of the second element to 2. 3. Decrease the value of the third element to 3. Now arr = [1,2,3], which satisfies the conditions. The largest element in arr is 3. Example 3: Input: arr = [1,2,3,4,5] Output: 5 Explanation: The array already satisfies the conditions, and the largest element is 5. Constraints: 1 <= arr.length <= 105 1 <= arr[i] <= 109",
        "title": "Maximum Element After Decreasing and Rearranging"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned. Example 1: Input: timeSeries = [1,4], duration = 2 Output: 4 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5. Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total. Example 2: Input: timeSeries = [1,2], duration = 2 Output: 3 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3. Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total. Constraints: 1 <= timeSeries.length <= 104 0 <= timeSeries[i], duration <= 107 timeSeries is sorted in non-decreasing order.",
        "title": "Teemo Attacking"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions: 1 <= pivot < n nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1] You are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged. Return the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element. Example 1: Input: nums = [2,-1,2], k = 3 Output: 1 Explanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2]. There is one way to partition the array: - For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2. Example 2: Input: nums = [0,0,0], k = 1 Output: 2 Explanation: The optimal approach is to leave the array unchanged. There are two ways to partition the array: - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0. - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0. Example 3: Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33 Output: 4 Explanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14]. There are four ways to partition the array. Constraints: n == nums.length 2 <= n <= 105 -105 <= k, nums[i] <= 105",
        "title": "Maximum Number of Ways to Partition an Array"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a string licensePlate and an array of strings words, find the shortest completing word in words. A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more. For example, if licensePlate = \"aBc 12c\", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are \"abccdef\", \"caaacab\", and \"cbca\". Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words. Example 1: Input: licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"] Output: \"steps\" Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'. \"step\" contains 't' and 'p', but only contains 1 's'. \"steps\" contains 't', 'p', and both 's' characters. \"stripe\" is missing an 's'. \"stepple\" is missing an 's'. Since \"steps\" is the only word containing all the letters, that is the answer. Example 2: Input: licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"] Output: \"pest\" Explanation: licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3. Constraints: 1 <= licensePlate.length <= 7 licensePlate contains digits, letters (uppercase or lowercase), or space ' '. 1 <= words.length <= 1000 1 <= words[i].length <= 15 words[i] consists of lower case English letters.",
        "title": "Shortest Completing Word"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design your implementation of the circular double-ended queue (deque). Implement the MyCircularDeque class: MyCircularDeque(int k) Initializes the deque with a maximum size of k. boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise. boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise. boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise. boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise. int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty. int getRear() Returns the last item from Deque. Returns -1 if the deque is empty. boolean isEmpty() Returns true if the deque is empty, or false otherwise. boolean isFull() Returns true if the deque is full, or false otherwise. Example 1: Input [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"] [[3], [1], [2], [3], [4], [], [], [], [4], []] Output [null, true, true, true, false, 2, true, true, true, 4] Explanation MyCircularDeque myCircularDeque = new MyCircularDeque(3); myCircularDeque.insertLast(1); // return True myCircularDeque.insertLast(2); // return True myCircularDeque.insertFront(3); // return True myCircularDeque.insertFront(4); // return False, the queue is full. myCircularDeque.getRear(); // return 2 myCircularDeque.isFull(); // return True myCircularDeque.deleteLast(); // return True myCircularDeque.insertFront(4); // return True myCircularDeque.getFront(); // return 4 Constraints: 1 <= k <= 1000 0 <= value <= 1000 At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.",
        "title": "Design Circular Deque"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '. A token is a valid word if all three of the following are true: It only contains lowercase letters, hyphens, and/or punctuation (no digits). There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters (\"a-b\" is valid, but \"-ab\" and \"ab-\" are not valid). There is at most one punctuation mark. If present, it must be at the end of the token (\"ab,\", \"cd!\", and \".\" are valid, but \"a!b\" and \"c.,\" are not valid). Examples of valid words include \"a-b.\", \"afad\", \"ba-c\", \"a!\", and \"!\". Given a string sentence, return the number of valid words in sentence. Example 1: Input: sentence = \"cat and dog\" Output: 3 Explanation: The valid words in the sentence are \"cat\", \"and\", and \"dog\". Example 2: Input: sentence = \"!this 1-s b8d!\" Output: 0 Explanation: There are no valid words in the sentence. \"!this\" is invalid because it starts with a punctuation mark. \"1-s\" and \"b8d\" are invalid because they contain digits. Example 3: Input: sentence = \"alice and bob are playing stone-game10\" Output: 5 Explanation: The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\". \"stone-game10\" is invalid because it contains digits. Constraints: 1 <= sentence.length <= 1000 sentence only contains lowercase English letters, digits, ' ', '-', '!', '.', and ','. There will be at least 1 token.",
        "title": "Number of Valid Words in a Sentence"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false. Example 1: Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2. Example 2: Input: root = [1,2,3], n = 3, x = 1 Output: false Constraints: The number of nodes in the tree is n. 1 <= x <= n <= 100 n is odd. 1 <= Node.val <= n All the values of the tree are unique.",
        "title": "Binary Tree Coloring Game"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "You have an inventory of different colored balls, and there is a customer that wants orders balls of any color. The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer). You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order. Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7. Example 1: Input: inventory = [2,5], orders = 4 Output: 14 Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3). The maximum total value is 2 + 5 + 4 + 3 = 14. Example 2: Input: inventory = [3,5], orders = 6 Output: 19 Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2). The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19. Constraints: 1 <= inventory.length <= 105 1 <= inventory[i] <= 109 1 <= orders <= min(sum(inventory[i]), 109)",
        "title": "Sell Diminishing-Valued Colored Balls"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. All inputs are integral coordinates. Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. All actions happen simultaneously. You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape. Return true if it is possible to escape regardless of how the ghosts move, otherwise return false. Example 1: Input: ghosts = [[1,0],[0,3]], target = [0,1] Output: true Explanation: You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you. Example 2: Input: ghosts = [[1,0]], target = [2,0] Output: false Explanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination. Example 3: Input: ghosts = [[2,0]], target = [1,0] Output: false Explanation: The ghost can reach the target at the same time as you. Constraints: 1 <= ghosts.length <= 100 ghosts[i].length == 2 -104 <= xi, yi <= 104 There can be multiple ghosts in the same location. target.length == 2 -104 <= xtarget, ytarget <= 104",
        "title": "Escape The Ghosts"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. Example 1: Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Example 2: Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 25 board[i][j] is 0 or 1. Follow up: Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",
        "title": "Game of Life"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted. Example 1: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Constraints: 1 <= n <= 100 edges.length == n - 1 edges[i].length == 2 1 <= ai, bi <= n 1 <= t <= 50 1 <= target <= n",
        "title": "Frog Position After T Seconds"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "content": "You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid. You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed. Return true if all asteroids can be destroyed. Otherwise, return false. Example 1: Input: mass = 10, asteroids = [3,9,19,5,21] Output: true Explanation: One way to order the asteroids is [9,19,5,3,21]: - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19 - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38 - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43 - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46 - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67 All asteroids are destroyed. Example 2: Input: mass = 5, asteroids = [4,9,23,4] Output: false Explanation: The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23. After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22. This is less than 23, so a collision would not destroy the last asteroid. Constraints: 1 <= mass <= 105 1 <= asteroids.length <= 105 1 <= asteroids[i] <= 105",
        "title": "Destroying Asteroids"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "A string s can be partitioned into groups of size k using the following procedure: The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group. For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure. Example 1: Input: s = \"abcdefghi\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\"] Explanation: The first 3 characters \"abc\" form the first group. The next 3 characters \"def\" form the second group. The last 3 characters \"ghi\" form the third group. Since all groups can be completely filled by characters from the string, we do not need to use fill. Thus, the groups formed are \"abc\", \"def\", and \"ghi\". Example 2: Input: s = \"abcdefghij\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\",\"jxx\"] Explanation: Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\". For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice. Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\". Constraints: 1 <= s.length <= 100 s consists of lowercase English letters only. 1 <= k <= 100 fill is a lowercase English letter.",
        "title": "Divide a String Into Groups of Size k"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There are several squares being dropped onto the X-axis of a 2D plane. You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti. Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved. After each square is dropped, you must record the height of the current tallest stack of squares. Return an integer array ans where ans[i] represents the height described above after dropping the ith square. Example 1: Input: positions = [[1,2],[2,3],[6,1]] Output: [2,5,5] Explanation: After the first drop, the tallest stack is square 1 with a height of 2. After the second drop, the tallest stack is squares 1 and 2 with a height of 5. After the third drop, the tallest stack is still squares 1 and 2 with a height of 5. Thus, we return an answer of [2, 5, 5]. Example 2: Input: positions = [[100,100],[200,100]] Output: [100,100] Explanation: After the first drop, the tallest stack is square 1 with a height of 100. After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100. Thus, we return an answer of [100, 100]. Note that square 2 only brushes the right side of square 1, which does not count as landing on it. Constraints: 1 <= positions.length <= 1000 1 <= lefti <= 108 1 <= sideLengthi <= 106",
        "title": "Falling Squares"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "content": "You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate. For example, the letter 'A' is located at coordinate (0, 0), the letter 'B' is located at coordinate (0, 1), the letter 'P' is located at coordinate (2, 3) and the letter 'Z' is located at coordinate (4, 1). Given the string word, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. Note that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters. Example 1: Input: word = \"CAKE\" Output: 3 Explanation: Using two fingers, one optimal way to type \"CAKE\" is: Finger 1 on letter 'C' -> cost = 0 Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 Finger 2 on letter 'K' -> cost = 0 Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 Total distance = 3 Example 2: Input: word = \"HAPPY\" Output: 6 Explanation: Using two fingers, one optimal way to type \"HAPPY\" is: Finger 1 on letter 'H' -> cost = 0 Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2 Finger 2 on letter 'P' -> cost = 0 Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0 Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4 Total distance = 6 Constraints: 2 <= word.length <= 300 word consists of uppercase English letters.",
        "title": "Minimum Distance to Type a Word Using Two Fingers"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time). Return an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x. Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation: answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0. answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7. The other answers can be filled out with similar reasoning. Example 2: Input: richer = [], quiet = [0] Output: [0] Constraints: n == quiet.length 1 <= n <= 500 0 <= quiet[i] < n All the values of quiet are unique. 0 <= richer.length <= n * (n - 1) / 2 0 <= ai, bi < n ai != bi All the pairs of richer are unique. The observations in richer are all logically consistent.",
        "title": "Loud and Rich"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri]. The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question. For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]: If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2. If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3. Return the maximum points you can earn for the exam. Example 1: Input: questions = [[3,2],[4,3],[4,4],[2,5]] Output: 5 Explanation: The maximum points can be earned by solving questions 0 and 3. - Solve question 0: Earn 3 points, will be unable to solve the next 2 questions - Unable to solve questions 1 and 2 - Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. Example 2: Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: 7 Explanation: The maximum points can be earned by solving questions 1 and 4. - Skip question 0 - Solve question 1: Earn 2 points, will be unable to solve the next 2 questions - Unable to solve questions 2 and 3 - Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. Constraints: 1 <= questions.length <= 105 questions[i].length == 2 1 <= pointsi, brainpoweri <= 105",
        "title": "Solving Questions With Brainpower"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]. You play a game with the following rules: You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1. You must eat at least one candy per day until you have eaten all the candies. Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return the constructed array answer. Example 1: Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] Output: [true,false,true] Explanation: 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2. 2- You can eat at most 4 candies each day. If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1. On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2. 3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13. Example 2: Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] Output: [false,true,true,false,false] Constraints: 1 <= candiesCount.length <= 105 1 <= candiesCount[i] <= 105 1 <= queries.length <= 105 queries[i].length == 3 0 <= favoriteTypei < candiesCount.length 0 <= favoriteDayi <= 109 1 <= dailyCapi <= 109",
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right]. Since the product may be very large, you will abbreviate it following these steps: Count all trailing zeros in the product and remove them. Let us denote this count as C. For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546. Denote the remaining number of digits in the product as d. If d > 10, then express the product as <pre>...<suf> where <pre> denotes the first 5 digits of the product, and <suf> denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged. For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567. Finally, represent the product as a string \"<pre>...<suf>eC\". For example, 12345678987600000 will be represented as \"12345...89876e5\". Return a string denoting the abbreviated product of all integers in the inclusive range [left, right]. Example 1: Input: left = 1, right = 4 Output: \"24e0\" Explanation: The product is 1 \u00d7 2 \u00d7 3 \u00d7 4 = 24. There are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\". Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further. Thus, the final representation is \"24e0\". Example 2: Input: left = 2, right = 11 Output: \"399168e2\" Explanation: The product is 39916800. There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\". The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further. Hence, the abbreviated product is \"399168e2\". Example 3: Input: left = 371, right = 375 Output: \"7219856259e3\" Explanation: The product is 7219856259000. Constraints: 1 <= left <= right <= 104",
        "title": "Abbreviating the Product of a Range"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 1 <= nums.length <= 3 * 104 -104 <= nums[i] <= 104 nums is sorted in non-decreasing order.",
        "title": "Remove Duplicates from Sorted Array II"
    },
    {
        "class": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. Each node has a value associated with it, and the root of the tree is node 0. To represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree. Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y. An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself. Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor. Example 1: Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]] Output: [-1,0,0,1] Explanation: In the above figure, each node's value is in parentheses. - Node 0 has no coprime ancestors. - Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1). - Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor. - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its closest valid ancestor. Example 2: Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]] Output: [-1,0,-1,0,0,0,-1] Constraints: nums.length == n 1 <= nums[i] <= 50 1 <= n <= 105 edges.length == n - 1 edges[j].length == 2 0 <= uj, vj < n uj != vj",
        "title": "Tree of Coprimes"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "content": "In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition. The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter. Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above. Return a string of all teams sorted by the ranking system. Example 1: Input: votes = [\"ABC\",\"ACB\",\"ABC\",\"ACB\",\"ACB\"] Output: \"ACB\" Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team. Team B was ranked second by 2 voters and was ranked third by 3 voters. Team C was ranked second by 3 voters and was ranked third by 2 voters. As most of the voters ranked C second, team C is the second team and team B is the third. Example 2: Input: votes = [\"WXYZ\",\"XYZW\"] Output: \"XWYZ\" Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. Example 3: Input: votes = [\"ZMNAGUEDSJYLBOPHRQICWFXTVK\"] Output: \"ZMNAGUEDSJYLBOPHRQICWFXTVK\" Explanation: Only one voter so his votes are used for the ranking. Constraints: 1 <= votes.length <= 1000 1 <= votes[i].length <= 26 votes[i].length == votes[j].length for 0 <= i, j < votes.length. votes[i][j] is an English uppercase letter. All characters of votes[i] are unique. All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.",
        "title": "Rank Teams by Votes"
    },
    {
        "class": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "content": "Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\" It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: \"directory_path/file_name.txt\" Example 1: Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"] Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]] Example 2: Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"] Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]] Constraints: 1 <= paths.length <= 2 * 104 1 <= paths[i].length <= 3000 1 <= sum(paths[i].length) <= 5 * 105 paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info. Follow up: Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive?",
        "title": "Find Duplicate File in System"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol). The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n. If the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r]. If the robot moves left or right into a cell whose column is c, then this move costs colCosts[c]. Return the minimum total cost for this robot to return home. Example 1: Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7] Output: 18 Explanation: One optimal path is that: Starting from (1, 0) -> It goes down to (2, 0). This move costs rowCosts[2] = 3. -> It goes right to (2, 1). This move costs colCosts[1] = 2. -> It goes right to (2, 2). This move costs colCosts[2] = 6. -> It goes right to (2, 3). This move costs colCosts[3] = 7. The total cost is 3 + 2 + 6 + 7 = 18 Example 2: Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26] Output: 0 Explanation: The robot is already at its home. Since no moves occur, the total cost is 0. Constraints: m == rowCosts.length n == colCosts.length 1 <= m, n <= 105 0 <= rowCosts[r], colCosts[c] <= 104 startPos.length == 2 homePos.length == 2 0 <= startrow, homerow < m 0 <= startcol, homecol < n",
        "title": "Minimum Cost Homecoming of a Robot in a Grid"
    },
    {
        "class": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "content": "You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. For example, \"ABC\" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from \"BAC\" where 'B' is on the left bottom and 'A' is on the right bottom. You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid. Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise. Example 1: Input: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"] Output: true Explanation: The allowed triangular patterns are shown on the right. Starting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"E\" on level 1. There are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed. Example 2: Input: bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"] Output: false Explanation: The allowed triangular patterns are shown on the right. Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1. Constraints: 2 <= bottom.length <= 6 0 <= allowed.length <= 216 allowed[i].length == 3 The letters in all input strings are from the set {'A', 'B', 'C', 'D', 'E', 'F'}. All the values of allowed are unique.",
        "title": "Pyramid Transition Matrix"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "content": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way. You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point. For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2. The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane. For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3. Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0. Note: There will be no obstacles on points 0 and n. Example 1: Input: obstacles = [0,1,2,3,0] Output: 2 Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows). Note that the frog can jump over obstacles only when making side jumps (as shown at point 2). Example 2: Input: obstacles = [0,1,1,3,3,0] Output: 0 Explanation: There are no obstacles on lane 2. No side jumps are required. Example 3: Input: obstacles = [0,2,1,0,3,0] Output: 2 Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps. Constraints: obstacles.length == n + 1 1 <= n <= 5 * 105 0 <= obstacles[i] <= 3 obstacles[0] == obstacles[n] == 0",
        "title": "Minimum Sideway Jumps"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1: Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4], cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Constraints: gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104",
        "title": "Gas Station"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique. You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return the maximum total number of fruits you can harvest. Example 1: Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 Output: 9 Explanation: The optimal way is to: - Move right to position 6 and harvest 3 fruits - Move right to position 8 and harvest 6 fruits You moved 3 steps and harvested 3 + 6 = 9 fruits in total. Example 2: Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 Output: 14 Explanation: You can move at most k = 4 steps, so you cannot reach position 0 nor 10. The optimal way is to: - Harvest the 7 fruits at the starting position 5 - Move left to position 4 and harvest 1 fruit - Move right to position 6 and harvest 2 fruits - Move right to position 7 and harvest 4 fruits You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total. Example 3: Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 Output: 0 Explanation: You can move at most k = 2 steps and cannot reach any position with fruits. Constraints: 1 <= fruits.length <= 105 fruits[i].length == 2 0 <= startPos, positioni <= 2 * 105 positioni-1 < positioni for any i > 0 (0-indexed) 1 <= amounti <= 104 0 <= k <= 2 * 105",
        "title": "Maximum Fruits Harvested After at Most K Steps"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1. Example 1: Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. Example 2: Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3: Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 Output: 12 Explanation: We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. Constraints: bloomDay.length == n 1 <= n <= 105 1 <= bloomDay[i] <= 109 1 <= m <= 106 1 <= k <= n",
        "title": "Minimum Number of Days to Make m Bouquets"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ],
        "content": "You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides. Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left. A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1. A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1. We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall of the box. Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box. Example 1: Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]] Output: [1,-1,-1,-1,-1] Explanation: This example is shown in the photo. Ball b0 is dropped at column 0 and falls out of the box at column 1. Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1. Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0. Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0. Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1. Example 2: Input: grid = [[-1]] Output: [-1] Explanation: The ball gets stuck against the left wall. Example 3: Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]] Output: [0,1,2,3,4,-1] Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 100 grid[i][j] is 1 or -1.",
        "title": "Where Will the Ball Fall"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a 0-indexed array nums of n integers, and an integer k. The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1. Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i. The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2. Example 1: Input: nums = [7,4,3,9,1,8,5,2,6], k = 3 Output: [-1,-1,-1,5,4,4,-1,-1,-1] Explanation: - avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index. - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using integer division, avg[3] = 37 / 7 = 5. - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. - avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index. Example 2: Input: nums = [100000], k = 0 Output: [100000] Explanation: - The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. Example 3: Input: nums = [8], k = 100000 Output: [-1] Explanation: - avg[0] is -1 because there are less than k elements before and after index 0. Constraints: n == nums.length 1 <= n <= 105 0 <= nums[i], k <= 105",
        "title": "K Radius Subarray Averages"
    },
    {
        "class": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "content": "Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the ith stone. Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn). Assuming both players play optimally, return true if Alice wins and false if Bob wins. Example 1: Input: stones = [2,1] Output: true Explanation: The game will be played as follows: - Turn 1: Alice can remove either stone. - Turn 2: Bob removes the remaining stone. The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game. Example 2: Input: stones = [2] Output: false Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game. Example 3: Input: stones = [5,1,2,4,3] Output: false Explanation: Bob will always win. One possible way for Bob to win is shown below: - Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1. - Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4. - Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8. - Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10. - Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15. Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game. Constraints: 1 <= stones.length <= 105 1 <= stones[i] <= 104",
        "title": "Stone Game IX"
    },
    {
        "class": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "content": "In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\". Example 1: Input: senate = \"RD\" Output: \"Radiant\" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. Example 2: Input: senate = \"RDD\" Output: \"Dire\" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. Constraints: n == senate.length 1 <= n <= 104 senate[i] is either 'R' or 'D'.",
        "title": "Dota2 Senate"
    },
    {
        "class": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1. void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated. To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, 3, null, -1, 3, 4] Explanation // cnt(x) = the use counter for key x // cache=[] will show the last used order for tiebreakers (leftmost element is most recent) LFUCache lfu = new LFUCache(2); lfu.put(1, 1); // cache=[1,_], cnt(1)=1 lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1 lfu.get(1); // return 1 // cache=[1,2], cnt(2)=1, cnt(1)=2 lfu.put(3, 3); // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2. // cache=[3,1], cnt(3)=1, cnt(1)=2 lfu.get(2); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,1], cnt(3)=2, cnt(1)=2 lfu.put(4, 4); // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1. // cache=[4,3], cnt(4)=1, cnt(3)=2 lfu.get(1); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,4], cnt(4)=1, cnt(3)=3 lfu.get(4); // return 4 // cache=[4,3], cnt(4)=2, cnt(3)=3 Constraints: 0 <= capacity <= 104 0 <= key <= 105 0 <= value <= 109 At most 2 * 105 calls will be made to get and put.",
        "title": "LFU Cache"
    },
    {
        "class": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark. Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time. Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point. Example 1: Input: dist = [1,3,2], hour = 6 Output: 1 Explanation: At speed 1: - The first train ride takes 1/1 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours. - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours. - You will arrive at exactly the 6 hour mark. Example 2: Input: dist = [1,3,2], hour = 2.7 Output: 3 Explanation: At speed 3: - The first train ride takes 1/3 = 0.33333 hours. - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours. - You will arrive at the 2.66667 hour mark. Example 3: Input: dist = [1,3,2], hour = 1.9 Output: -1 Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark. Constraints: n == dist.length 1 <= n <= 105 1 <= dist[i] <= 105 1 <= hour <= 109 There will be at most two digits after the decimal point in hour.",
        "title": "Minimum Speed to Arrive on Time"
    },
    {
        "class": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "content": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i]. When a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product). The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100). Implement the Cashier class: Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices. double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted. Example 1: Input [\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"] [[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]] Output [null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0] Explanation Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]); cashier.getBill([1,2],[1,2]); // return 500.0. 1st customer, no discount. // bill = 1 * 100 + 2 * 200 = 500. cashier.getBill([3,7],[10,10]); // return 4000.0. 2nd customer, no discount. // bill = 10 * 300 + 10 * 100 = 4000. cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]); // return 800.0. 3rd customer, 50% discount. // Original bill = 1600 // Actual bill = 1600 * ((100 - 50) / 100) = 800. cashier.getBill([4],[10]); // return 4000.0. 4th customer, no discount. cashier.getBill([7,3],[10,10]); // return 4000.0. 5th customer, no discount. cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount. // Original bill = 14700, but with // Actual bill = 14700 * ((100 - 50) / 100) = 7350. cashier.getBill([2,3,5],[5,3,2]); // return 2500.0. 6th customer, no discount. Constraints: 1 <= n <= 104 0 <= discount <= 100 1 <= products.length <= 200 prices.length == products.length 1 <= products[i] <= 200 1 <= prices[i] <= 1000 The elements in products are unique. 1 <= product.length <= products.length amount.length == product.length product[j] exists in products. 1 <= amount[j] <= 1000 The elements of product are unique. At most 1000 calls will be made to getBill. Answers within 10-5 of the actual value will be accepted.",
        "title": "Apply Discount Every n Orders"
    }
]